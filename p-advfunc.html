<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>19 函数进阶 | R语言教程</title>
  <meta name="description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="19 函数进阶 | R语言教程" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="19 函数进阶 | R语言教程" />
  
  <meta name="twitter:description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  

<meta name="author" content="李东风" />


<meta name="date" content="2020-12-28" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="prog-prof.html"/>
<link rel="next" href="knitr.html"/>
<script src="static/js/jquery.min.js"></script>
<link href="static/css/style.css" rel="stylesheet" />
<link href="static/css/plugin-table.css" rel="stylesheet" />
<link href="static/css/plugin-bookdown.css" rel="stylesheet" />
<link href="static/css/plugin-highlight.css" rel="stylesheet" />
<link href="static/css/plugin-search.css" rel="stylesheet" />
<link href="static/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="static/css/plugin-clipboard.css" rel="stylesheet" />









<script src="static/js/empty-anchor.js"></script>
<script src="static/js/htmlwidgets.js"></script>
<link href="static/css/str_view.css" rel="stylesheet" />
<script src="static/js/str_view.js"></script>
<link href="static/css/wordcloud.css" rel="stylesheet" />
<script src="static/js/wordcloud2-all.js"></script>
<script src="static/js/hover.js"></script>
<script src="static/js/wordcloud2.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX","output/SVG"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
<script type="text/javascript"
   src="static/js/mathjax.js">
</script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html">R语言教程</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>前言</a></li>
<li class="part"><span><b>I 介绍</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> R语言介绍</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#intro-hist-char"><i class="fa fa-check"></i><b>1.1</b> R的历史和特点</a><ul>
<li class="chapter" data-level="1.1.1" data-path="intro.html"><a href="intro.html#intro-hc-hist"><i class="fa fa-check"></i><b>1.1.1</b> R的历史</a></li>
<li class="chapter" data-level="1.1.2" data-path="intro.html"><a href="intro.html#intro-hc-char"><i class="fa fa-check"></i><b>1.1.2</b> R的特点</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#intro-install"><i class="fa fa-check"></i><b>1.2</b> R的下载与安装</a><ul>
<li class="chapter" data-level="1.2.1" data-path="intro.html"><a href="intro.html#intro-ins-down"><i class="fa fa-check"></i><b>1.2.1</b> R的下载</a></li>
<li class="chapter" data-level="1.2.2" data-path="intro.html"><a href="intro.html#intro-ins-install"><i class="fa fa-check"></i><b>1.2.2</b> R软件安装</a></li>
<li class="chapter" data-level="1.2.3" data-path="intro.html"><a href="intro.html#intro-ins-other-soft"><i class="fa fa-check"></i><b>1.2.3</b> 辅助软件</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#intro-ins-packages"><i class="fa fa-check"></i><b>1.3</b> R扩展软件包的安装与管理</a><ul>
<li class="chapter" data-level="1.3.1" data-path="intro.html"><a href="intro.html#intro-ins-pack-ins"><i class="fa fa-check"></i><b>1.3.1</b> 安装</a></li>
<li class="chapter" data-level="1.3.2" data-path="intro.html"><a href="intro.html#intro-ins-pack-gitbioc"><i class="fa fa-check"></i><b>1.3.2</b> Github和BioConductor的扩展包</a></li>
<li class="chapter" data-level="1.3.3" data-path="intro.html"><a href="intro.html#intro-ins-pack-upd"><i class="fa fa-check"></i><b>1.3.3</b> 更新扩展包</a></li>
<li class="chapter" data-level="1.3.4" data-path="intro.html"><a href="intro.html#intro-ins-pack-verup"><i class="fa fa-check"></i><b>1.3.4</b> 迁移扩展包</a></li>
<li class="chapter" data-level="1.3.5" data-path="intro.html"><a href="intro.html#intro-ins-pack-renv"><i class="fa fa-check"></i><b>1.3.5</b> 项目私有扩展包目录</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#intro-ruse"><i class="fa fa-check"></i><b>1.4</b> 基本R软件的用法</a><ul>
<li class="chapter" data-level="1.4.1" data-path="intro.html"><a href="intro.html#intro-ruse-run"><i class="fa fa-check"></i><b>1.4.1</b> 基本运行</a></li>
<li class="chapter" data-level="1.4.2" data-path="intro.html"><a href="intro.html#intro-ruse-proj"><i class="fa fa-check"></i><b>1.4.2</b> 项目目录</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#intro-rstudio"><i class="fa fa-check"></i><b>1.5</b> RStudio软件</a><ul>
<li class="chapter" data-level="1.5.1" data-path="intro.html"><a href="intro.html#intro-rstudio-intro"><i class="fa fa-check"></i><b>1.5.1</b> 介绍</a></li>
<li class="chapter" data-level="1.5.2" data-path="intro.html"><a href="intro.html#intro-rstudio-proj"><i class="fa fa-check"></i><b>1.5.2</b> 项目</a></li>
<li class="chapter" data-level="1.5.3" data-path="intro.html"><a href="intro.html#intro-rstudio-help"><i class="fa fa-check"></i><b>1.5.3</b> 帮助</a></li>
<li class="chapter" data-level="1.5.4" data-path="intro.html"><a href="intro.html#intro-rstudio-shortcuts"><i class="fa fa-check"></i><b>1.5.4</b> 使用技巧</a></li>
<li class="chapter" data-level="1.5.5" data-path="intro.html"><a href="intro.html#intro-rstudio-rmd"><i class="fa fa-check"></i><b>1.5.5</b> Rmd文件</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#intro-ins-ex"><i class="fa fa-check"></i><b>1.6</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro-example.html"><a href="intro-example.html"><i class="fa fa-check"></i><b>2</b> R语言入门运行样例</a><ul>
<li class="chapter" data-level="2.1" data-path="intro-example.html"><a href="intro-example.html#i-e-command-line"><i class="fa fa-check"></i><b>2.1</b> 命令行界面</a></li>
<li class="chapter" data-level="2.2" data-path="intro-example.html"><a href="intro-example.html#i-e-arith-op"><i class="fa fa-check"></i><b>2.2</b> 四则运算</a><ul>
<li class="chapter" data-level="2.2.1" data-path="intro-example.html"><a href="intro-example.html#i-e-arith-op-poker"><i class="fa fa-check"></i><b>2.2.1</b> 计算例子</a></li>
<li class="chapter" data-level="2.2.2" data-path="intro-example.html"><a href="intro-example.html#i-e-a-o-ex"><i class="fa fa-check"></i><b>2.2.2</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="intro-example.html"><a href="intro-example.html#i-e-math-func"><i class="fa fa-check"></i><b>2.3</b> 数学函数</a><ul>
<li class="chapter" data-level="2.3.1" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-sqrt"><i class="fa fa-check"></i><b>2.3.1</b> 数学函数——平方根、指数、对数</a></li>
<li class="chapter" data-level="2.3.2" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-round"><i class="fa fa-check"></i><b>2.3.2</b> 数学函数——取整</a></li>
<li class="chapter" data-level="2.3.3" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-sin"><i class="fa fa-check"></i><b>2.3.3</b> 数学函数——三角函数</a></li>
<li class="chapter" data-level="2.3.4" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-asin"><i class="fa fa-check"></i><b>2.3.4</b> 数学函数——反三角函数</a></li>
<li class="chapter" data-level="2.3.5" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-dist"><i class="fa fa-check"></i><b>2.3.5</b> 分布函数和分位数函数</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="intro-example.html"><a href="intro-example.html#i-e-output"><i class="fa fa-check"></i><b>2.4</b> 输出</a><ul>
<li class="chapter" data-level="2.4.1" data-path="intro-example.html"><a href="intro-example.html#i-e-o-simple"><i class="fa fa-check"></i><b>2.4.1</b> 简单输出</a></li>
<li class="chapter" data-level="2.4.2" data-path="intro-example.html"><a href="intro-example.html#i-e-o-sink"><i class="fa fa-check"></i><b>2.4.2</b> 用<code>sink()</code>函数作运行记录</a></li>
<li class="chapter" data-level="2.4.3" data-path="intro-example.html"><a href="intro-example.html#i-e-o-ex"><i class="fa fa-check"></i><b>2.4.3</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="intro-example.html"><a href="intro-example.html#i-e-vector"><i class="fa fa-check"></i><b>2.5</b> 向量计算与变量赋值</a></li>
<li class="chapter" data-level="2.6" data-path="intro-example.html"><a href="intro-example.html#i-e-workspace"><i class="fa fa-check"></i><b>2.6</b> 工作空间介绍</a><ul>
<li class="chapter" data-level="2.6.1" data-path="intro-example.html"><a href="intro-example.html#i-e-w-ex"><i class="fa fa-check"></i><b>2.6.1</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="intro-example.html"><a href="intro-example.html#i-e-graph"><i class="fa fa-check"></i><b>2.7</b> 绘图示例</a><ul>
<li class="chapter" data-level="2.7.1" data-path="intro-example.html"><a href="intro-example.html#i-e-g-curve"><i class="fa fa-check"></i><b>2.7.1</b> 函数曲线示例</a></li>
<li class="chapter" data-level="2.7.2" data-path="intro-example.html"><a href="intro-example.html#i-e-g-barplot"><i class="fa fa-check"></i><b>2.7.2</b> 条形图示例</a></li>
<li class="chapter" data-level="2.7.3" data-path="intro-example.html"><a href="intro-example.html#i-e-g-scatter"><i class="fa fa-check"></i><b>2.7.3</b> 散点图示例</a></li>
<li class="chapter" data-level="2.7.4" data-path="intro-example.html"><a href="intro-example.html#i-e-g-demo"><i class="fa fa-check"></i><b>2.7.4</b> R软件自带的图形示例</a></li>
<li class="chapter" data-level="2.7.5" data-path="intro-example.html"><a href="intro-example.html#i-e-g-ex"><i class="fa fa-check"></i><b>2.7.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="intro-example.html"><a href="intro-example.html#i-e-summary"><i class="fa fa-check"></i><b>2.8</b> 汇总统计示例</a><ul>
<li class="chapter" data-level="2.8.1" data-path="intro-example.html"><a href="intro-example.html#i-e-s-table"><i class="fa fa-check"></i><b>2.8.1</b> 表格数据</a></li>
<li class="chapter" data-level="2.8.2" data-path="intro-example.html"><a href="intro-example.html#i-e-s-t-read-table"><i class="fa fa-check"></i><b>2.8.2</b> 读入表格数据</a></li>
<li class="chapter" data-level="2.8.3" data-path="intro-example.html"><a href="intro-example.html#i-e-s-ex"><i class="fa fa-check"></i><b>2.8.3</b> 练习</a></li>
<li class="chapter" data-level="2.8.4" data-path="intro-example.html"><a href="intro-example.html#i-e-s-qual-freq"><i class="fa fa-check"></i><b>2.8.4</b> 分类变量频数统计</a></li>
<li class="chapter" data-level="2.8.5" data-path="intro-example.html"><a href="intro-example.html#i-e-s-num-summ"><i class="fa fa-check"></i><b>2.8.5</b> 数值型变量的统计</a></li>
<li class="chapter" data-level="2.8.6" data-path="intro-example.html"><a href="intro-example.html#i-e-s-ex2"><i class="fa fa-check"></i><b>2.8.6</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.9" data-path="intro-example.html"><a href="intro-example.html#i-e-source"><i class="fa fa-check"></i><b>2.9</b> 运行源程序文件</a><ul>
<li class="chapter" data-level="2.9.1" data-path="intro-example.html"><a href="intro-example.html#i-e-source-enc"><i class="fa fa-check"></i><b>2.9.1</b> 源文件编码</a></li>
<li class="chapter" data-level="2.9.2" data-path="intro-example.html"><a href="intro-example.html#i-e-cwd"><i class="fa fa-check"></i><b>2.9.2</b> 当前工作目录</a></li>
<li class="chapter" data-level="2.9.3" data-path="intro-example.html"><a href="intro-example.html#i-e-source-ex"><i class="fa fa-check"></i><b>2.9.3</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.10" data-path="intro-example.html"><a href="intro-example.html#i-e-appendix-data"><i class="fa fa-check"></i><b>2.10</b> 附录：数据</a><ul>
<li class="chapter" data-level="2.10.1" data-path="intro-example.html"><a href="intro-example.html#i-e-appendix-data-tax"><i class="fa fa-check"></i><b>2.10.1</b> 公司纳税数据样例</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>II 数据类型与相应的运算</b></span></li>
<li class="chapter" data-level="3" data-path="prog-type-intro.html"><a href="prog-type-intro.html"><i class="fa fa-check"></i><b>3</b> 常量与变量</a><ul>
<li class="chapter" data-level="3.1" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-const"><i class="fa fa-check"></i><b>3.1</b> 常量</a></li>
<li class="chapter" data-level="3.2" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-cv-var"><i class="fa fa-check"></i><b>3.2</b> 变量</a></li>
<li class="chapter" data-level="3.3" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-type"><i class="fa fa-check"></i><b>3.3</b> R数据类型</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="prog-type-num.html"><a href="prog-type-num.html"><i class="fa fa-check"></i><b>4</b> 数值型向量及其运算</a><ul>
<li class="chapter" data-level="4.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-num"><i class="fa fa-check"></i><b>4.1</b> 数值型向量</a></li>
<li class="chapter" data-level="4.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith"><i class="fa fa-check"></i><b>4.2</b> 向量运算</a><ul>
<li class="chapter" data-level="4.2.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-scalar"><i class="fa fa-check"></i><b>4.2.1</b> 标量和标量运算</a></li>
<li class="chapter" data-level="4.2.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-with-scalar"><i class="fa fa-check"></i><b>4.2.2</b> 向量与标量运算</a></li>
<li class="chapter" data-level="4.2.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-eq-len"><i class="fa fa-check"></i><b>4.2.3</b> 等长向量运算</a></li>
<li class="chapter" data-level="4.2.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-uneq-len"><i class="fa fa-check"></i><b>4.2.4</b> 不等长向量的运算</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc"><i class="fa fa-check"></i><b>4.3</b> 向量函数</a><ul>
<li class="chapter" data-level="4.3.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-vector-func"><i class="fa fa-check"></i><b>4.3.1</b> 向量化的函数</a></li>
<li class="chapter" data-level="4.3.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-sort"><i class="fa fa-check"></i><b>4.3.2</b> 排序函数</a></li>
<li class="chapter" data-level="4.3.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-stat"><i class="fa fa-check"></i><b>4.3.3</b> 统计函数</a></li>
<li class="chapter" data-level="4.3.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-seq"><i class="fa fa-check"></i><b>4.3.4</b> 生成规则序列的函数</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-complex"><i class="fa fa-check"></i><b>4.4</b> 复数向量</a></li>
<li class="chapter" data-level="4.5" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-ex"><i class="fa fa-check"></i><b>4.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="prog-type-logi.html"><a href="prog-type-logi.html"><i class="fa fa-check"></i><b>5</b> 逻辑型向量及其运算</a><ul>
<li class="chapter" data-level="5.1" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-logical-vec"><i class="fa fa-check"></i><b>5.1</b> 逻辑型向量与比较运算</a></li>
<li class="chapter" data-level="5.2" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-lvec-logic-op"><i class="fa fa-check"></i><b>5.2</b> 逻辑运算</a></li>
<li class="chapter" data-level="5.3" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-lvec-logic-op-vec"><i class="fa fa-check"></i><b>5.3</b> 逻辑运算函数</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="prog-type-char.html"><a href="prog-type-char.html"><i class="fa fa-check"></i><b>6</b> 字符型数据及其处理</a><ul>
<li class="chapter" data-level="6.1" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char"><i class="fa fa-check"></i><b>6.1</b> 字符型向量</a></li>
<li class="chapter" data-level="6.2" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-paste"><i class="fa fa-check"></i><b>6.2</b> <code>paste()</code>函数</a></li>
<li class="chapter" data-level="6.3" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-toupper"><i class="fa fa-check"></i><b>6.3</b> 转换大小写</a></li>
<li class="chapter" data-level="6.4" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-nchar"><i class="fa fa-check"></i><b>6.4</b> 字符串长度</a></li>
<li class="chapter" data-level="6.5" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-substr"><i class="fa fa-check"></i><b>6.5</b> 取子串</a></li>
<li class="chapter" data-level="6.6" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-asnum"><i class="fa fa-check"></i><b>6.6</b> 类型转换</a></li>
<li class="chapter" data-level="6.7" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-strsplit"><i class="fa fa-check"></i><b>6.7</b> 字符串拆分</a></li>
<li class="chapter" data-level="6.8" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-gsub"><i class="fa fa-check"></i><b>6.8</b> 字符串替换功能</a></li>
<li class="chapter" data-level="6.9" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-regexp"><i class="fa fa-check"></i><b>6.9</b> 正则表达式</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="prog-type-index.html"><a href="prog-type-index.html"><i class="fa fa-check"></i><b>7</b> R向量下标和子集</a><ul>
<li class="chapter" data-level="7.1" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-int"><i class="fa fa-check"></i><b>7.1</b> 正整数下标</a></li>
<li class="chapter" data-level="7.2" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-negint"><i class="fa fa-check"></i><b>7.2</b> 负整数下标</a></li>
<li class="chapter" data-level="7.3" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-all"><i class="fa fa-check"></i><b>7.3</b> 空下标与零下标</a></li>
<li class="chapter" data-level="7.4" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-over"><i class="fa fa-check"></i><b>7.4</b> 下标超界</a></li>
<li class="chapter" data-level="7.5" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-logic"><i class="fa fa-check"></i><b>7.5</b> 逻辑下标</a></li>
<li class="chapter" data-level="7.6" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-which"><i class="fa fa-check"></i><b>7.6</b> <code>which()</code>、<code>which.min()</code>、<code>which.max()</code>函数</a></li>
<li class="chapter" data-level="7.7" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-names"><i class="fa fa-check"></i><b>7.7</b> 元素名</a></li>
<li class="chapter" data-level="7.8" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-mapping"><i class="fa fa-check"></i><b>7.8</b> 用R向量下标作映射</a></li>
<li class="chapter" data-level="7.9" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-set"><i class="fa fa-check"></i><b>7.9</b> 集合运算</a></li>
<li class="chapter" data-level="7.10" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-set-ex"><i class="fa fa-check"></i><b>7.10</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="prog-type-attr.html"><a href="prog-type-attr.html"><i class="fa fa-check"></i><b>8</b> R数据类型的性质</a><ul>
<li class="chapter" data-level="8.1" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-typeof"><i class="fa fa-check"></i><b>8.1</b> 存储模式与基本类型</a></li>
<li class="chapter" data-level="8.2" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-as"><i class="fa fa-check"></i><b>8.2</b> 类型转换与类型升档</a></li>
<li class="chapter" data-level="8.3" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr"><i class="fa fa-check"></i><b>8.3</b> 属性</a><ul>
<li class="chapter" data-level="8.3.1" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-asfun"><i class="fa fa-check"></i><b>8.3.1</b> <code>attributes</code>函数</a></li>
<li class="chapter" data-level="8.3.2" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-attrfun"><i class="fa fa-check"></i><b>8.3.2</b> <code>attr</code>函数</a></li>
<li class="chapter" data-level="8.3.3" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-names"><i class="fa fa-check"></i><b>8.3.3</b> <code>names</code>属性</a></li>
<li class="chapter" data-level="8.3.4" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-dim"><i class="fa fa-check"></i><b>8.3.4</b> <code>dim</code>属性</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-class"><i class="fa fa-check"></i><b>8.4</b> 类属</a></li>
<li class="chapter" data-level="8.5" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-str"><i class="fa fa-check"></i><b>8.5</b> <code>str()</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="prog-type-date.html"><a href="prog-type-date.html"><i class="fa fa-check"></i><b>9</b> R日期时间</a><ul>
<li class="chapter" data-level="9.1" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-intro"><i class="fa fa-check"></i><b>9.1</b> R日期和日期时间类型</a></li>
<li class="chapter" data-level="9.2" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-fromchr"><i class="fa fa-check"></i><b>9.2</b> 从字符串生成日期数据</a></li>
<li class="chapter" data-level="9.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-format"><i class="fa fa-check"></i><b>9.3</b> 日期显示格式</a></li>
<li class="chapter" data-level="9.4" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-comp"><i class="fa fa-check"></i><b>9.4</b> 访问日期时间的组成值</a></li>
<li class="chapter" data-level="9.5" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-round"><i class="fa fa-check"></i><b>9.5</b> 日期舍入计算</a></li>
<li class="chapter" data-level="9.6" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc"><i class="fa fa-check"></i><b>9.6</b> 日期计算</a><ul>
<li class="chapter" data-level="9.6.1" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-dur"><i class="fa fa-check"></i><b>9.6.1</b> 时间长度</a></li>
<li class="chapter" data-level="9.6.2" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-per"><i class="fa fa-check"></i><b>9.6.2</b> 时间周期</a></li>
<li class="chapter" data-level="9.6.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-int"><i class="fa fa-check"></i><b>9.6.3</b> 时间区间</a></li>
</ul></li>
<li class="chapter" data-level="9.7" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-baser"><i class="fa fa-check"></i><b>9.7</b> 基本R软件的日期功能</a><ul>
<li class="chapter" data-level="9.7.1" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-gen"><i class="fa fa-check"></i><b>9.7.1</b> 生成日期和日期时间型数据</a></li>
<li class="chapter" data-level="9.7.2" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-comp"><i class="fa fa-check"></i><b>9.7.2</b> 取出日期时间的组成值</a></li>
<li class="chapter" data-level="9.7.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-calc"><i class="fa fa-check"></i><b>9.7.3</b> 日期计算</a></li>
</ul></li>
<li class="chapter" data-level="9.8" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-ex"><i class="fa fa-check"></i><b>9.8</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="prog-type-fact.html"><a href="prog-type-fact.html"><i class="fa fa-check"></i><b>10</b> R因子类型</a><ul>
<li class="chapter" data-level="10.1" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-fact"><i class="fa fa-check"></i><b>10.1</b> 因子</a></li>
<li class="chapter" data-level="10.2" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-table"><i class="fa fa-check"></i><b>10.2</b> <code>table()</code>函数</a></li>
<li class="chapter" data-level="10.3" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-tapply"><i class="fa fa-check"></i><b>10.3</b> <code>tapply()</code>函数</a></li>
<li class="chapter" data-level="10.4" data-path="prog-type-fact.html"><a href="prog-type-fact.html#summ-by-forcats"><i class="fa fa-check"></i><b>10.4</b> forcats包的因子函数</a></li>
<li class="chapter" data-level="10.5" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-ex"><i class="fa fa-check"></i><b>10.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="prog-type-list.html"><a href="prog-type-list.html"><i class="fa fa-check"></i><b>11</b> 列表类型</a><ul>
<li class="chapter" data-level="11.1" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list"><i class="fa fa-check"></i><b>11.1</b> 列表</a></li>
<li class="chapter" data-level="11.2" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-access"><i class="fa fa-check"></i><b>11.2</b> 列表元素访问</a></li>
<li class="chapter" data-level="11.3" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-as"><i class="fa fa-check"></i><b>11.3</b> 列表类型转换</a></li>
<li class="chapter" data-level="11.4" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-ex-strsplit"><i class="fa fa-check"></i><b>11.4</b> 返回列表的函数示例–<code>strsplit()</code></a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html"><i class="fa fa-check"></i><b>12</b> R矩阵和数组</a><ul>
<li class="chapter" data-level="12.1" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matrix"><i class="fa fa-check"></i><b>12.1</b> R矩阵</a></li>
<li class="chapter" data-level="12.2" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-subset"><i class="fa fa-check"></i><b>12.2</b> 矩阵子集</a></li>
<li class="chapter" data-level="12.3" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-cbind"><i class="fa fa-check"></i><b>12.3</b> <code>cbind()</code>和<code>rbind()</code>函数</a></li>
<li class="chapter" data-level="12.4" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop"><i class="fa fa-check"></i><b>12.4</b> 矩阵运算</a><ul>
<li class="chapter" data-level="12.4.1" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-arith"><i class="fa fa-check"></i><b>12.4.1</b> 四则运算</a></li>
<li class="chapter" data-level="12.4.2" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-mult"><i class="fa fa-check"></i><b>12.4.2</b> 矩阵乘法</a></li>
<li class="chapter" data-level="12.4.3" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-vecmat"><i class="fa fa-check"></i><b>12.4.3</b> 向量与矩阵相乘</a></li>
<li class="chapter" data-level="12.4.4" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-inprod"><i class="fa fa-check"></i><b>12.4.4</b> 内积</a></li>
<li class="chapter" data-level="12.4.5" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-outer"><i class="fa fa-check"></i><b>12.4.5</b> 外积</a></li>
</ul></li>
<li class="chapter" data-level="12.5" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-solve"><i class="fa fa-check"></i><b>12.5</b> 逆矩阵与线性方程组求解</a></li>
<li class="chapter" data-level="12.6" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-apply"><i class="fa fa-check"></i><b>12.6</b> <code>apply()</code>函数</a></li>
<li class="chapter" data-level="12.7" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-array"><i class="fa fa-check"></i><b>12.7</b> 多维数组</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="prog-type-df.html"><a href="prog-type-df.html"><i class="fa fa-check"></i><b>13</b> 数据框</a><ul>
<li class="chapter" data-level="13.1" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-dataframe"><i class="fa fa-check"></i><b>13.1</b> 数据框</a></li>
<li class="chapter" data-level="13.2" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-access"><i class="fa fa-check"></i><b>13.2</b> 数据框内容访问</a></li>
<li class="chapter" data-level="13.3" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-rownames"><i class="fa fa-check"></i><b>13.3</b> 数据框的行名</a></li>
<li class="chapter" data-level="13.4" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-notmatrix"><i class="fa fa-check"></i><b>13.4</b> 数据框与矩阵的区别</a></li>
<li class="chapter" data-level="13.5" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-gl-func"><i class="fa fa-check"></i><b>13.5</b> <code>tidyr::expand_grid()</code>函数</a></li>
<li class="chapter" data-level="13.6" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-tibble"><i class="fa fa-check"></i><b>13.6</b> <code>tibble</code>类型</a></li>
<li class="chapter" data-level="13.7" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-ex"><i class="fa fa-check"></i><b>13.7</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="prog-type-ws.html"><a href="prog-type-ws.html"><i class="fa fa-check"></i><b>14</b> 工作空间和变量赋值</a><ul>
<li class="chapter" data-level="14.1" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws"><i class="fa fa-check"></i><b>14.1</b> 工作空间</a></li>
<li class="chapter" data-level="14.2" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-nlvname"><i class="fa fa-check"></i><b>14.2</b> 非法变量名</a></li>
<li class="chapter" data-level="14.3" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws-asign"><i class="fa fa-check"></i><b>14.3</b> 变量赋值与绑定</a></li>
<li class="chapter" data-level="14.4" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws-env"><i class="fa fa-check"></i><b>14.4</b> 环境</a></li>
</ul></li>
<li class="part"><span><b>III 编程</b></span></li>
<li class="chapter" data-level="15" data-path="prog-io.html"><a href="prog-io.html"><i class="fa fa-check"></i><b>15</b> R输入输出</a><ul>
<li class="chapter" data-level="15.1" data-path="prog-io.html"><a href="prog-io.html#p-io-simple"><i class="fa fa-check"></i><b>15.1</b> 输入输出的简单方法</a><ul>
<li class="chapter" data-level="15.1.1" data-path="prog-io.html"><a href="prog-io.html#p-io-simple-out"><i class="fa fa-check"></i><b>15.1.1</b> 简单的输出</a></li>
<li class="chapter" data-level="15.1.2" data-path="prog-io.html"><a href="prog-io.html#p-io-simple-input"><i class="fa fa-check"></i><b>15.1.2</b> 简单的输入</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv"><i class="fa fa-check"></i><b>15.2</b> 读取CSV文件</a><ul>
<li class="chapter" data-level="15.2.1" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-format"><i class="fa fa-check"></i><b>15.2.1</b> CSV格式</a></li>
<li class="chapter" data-level="15.2.2" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-fromstr"><i class="fa fa-check"></i><b>15.2.2</b> 从字符串读入</a></li>
<li class="chapter" data-level="15.2.3" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-opt"><i class="fa fa-check"></i><b>15.2.3</b> <code>read_csv</code>选项</a></li>
<li class="chapter" data-level="15.2.4" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-enc"><i class="fa fa-check"></i><b>15.2.4</b> 编码设置</a></li>
<li class="chapter" data-level="15.2.5" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-na"><i class="fa fa-check"></i><b>15.2.5</b> 缺失值设置</a></li>
<li class="chapter" data-level="15.2.6" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-colt"><i class="fa fa-check"></i><b>15.2.6</b> 各列类型设置</a></li>
<li class="chapter" data-level="15.2.7" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-fact"><i class="fa fa-check"></i><b>15.2.7</b> 因子类型设置</a></li>
<li class="chapter" data-level="15.2.8" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-date"><i class="fa fa-check"></i><b>15.2.8</b> 读入日期</a></li>
<li class="chapter" data-level="15.2.9" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-funcs"><i class="fa fa-check"></i><b>15.2.9</b> 其它函数</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="prog-io.html"><a href="prog-io.html#p-io-excel"><i class="fa fa-check"></i><b>15.3</b> Excel表访问</a><ul>
<li class="chapter" data-level="15.3.1" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-csv"><i class="fa fa-check"></i><b>15.3.1</b> 借助于文本格式</a></li>
<li class="chapter" data-level="15.3.2" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-clip"><i class="fa fa-check"></i><b>15.3.2</b> 使用剪贴板</a></li>
<li class="chapter" data-level="15.3.3" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-readxl"><i class="fa fa-check"></i><b>15.3.3</b> 利用readxl扩展包</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="prog-io.html"><a href="prog-io.html#p-io-file"><i class="fa fa-check"></i><b>15.4</b> 文件访问</a><ul>
<li class="chapter" data-level="15.4.1" data-path="prog-io.html"><a href="prog-io.html#p-io-file-conn"><i class="fa fa-check"></i><b>15.4.1</b> 连接</a></li>
<li class="chapter" data-level="15.4.2" data-path="prog-io.html"><a href="prog-io.html#p-io-file-text"><i class="fa fa-check"></i><b>15.4.2</b> 文本文件访问</a></li>
<li class="chapter" data-level="15.4.3" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-batch"><i class="fa fa-check"></i><b>15.4.3</b> 文本文件分批读写</a></li>
<li class="chapter" data-level="15.4.4" data-path="prog-io.html"><a href="prog-io.html#p-io-file-bin"><i class="fa fa-check"></i><b>15.4.4</b> 二进制文件访问</a></li>
<li class="chapter" data-level="15.4.5" data-path="prog-io.html"><a href="prog-io.html#p-io-file-textcon"><i class="fa fa-check"></i><b>15.4.5</b> 字符型连接</a></li>
</ul></li>
<li class="chapter" data-level="15.5" data-path="prog-io.html"><a href="prog-io.html#p-io-enc"><i class="fa fa-check"></i><b>15.5</b> 中文编码问题</a><ul>
<li class="chapter" data-level="15.5.1" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-base"><i class="fa fa-check"></i><b>15.5.1</b> 用基本R的读取函数读取</a></li>
<li class="chapter" data-level="15.5.2" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-readr"><i class="fa fa-check"></i><b>15.5.2</b> 用readr包读取</a></li>
<li class="chapter" data-level="15.5.3" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-write"><i class="fa fa-check"></i><b>15.5.3</b> 输出文件的编码</a></li>
</ul></li>
<li class="chapter" data-level="15.6" data-path="prog-io.html"><a href="prog-io.html#p-io-dir"><i class="fa fa-check"></i><b>15.6</b> 目录和文件管理</a></li>
<li class="chapter" data-level="15.7" data-path="prog-io.html"><a href="prog-io.html#p-io-db"><i class="fa fa-check"></i><b>15.7</b> SQL数据库访问</a><ul>
<li class="chapter" data-level="15.7.1" data-path="prog-io.html"><a href="prog-io.html#p-io-db-intro"><i class="fa fa-check"></i><b>15.7.1</b> 介绍</a></li>
<li class="chapter" data-level="15.7.2" data-path="prog-io.html"><a href="prog-io.html#p-io-db-sqlite"><i class="fa fa-check"></i><b>15.7.2</b> SQLite数据库访问</a></li>
<li class="chapter" data-level="15.7.3" data-path="prog-io.html"><a href="prog-io.html#p-io-db-sql"><i class="fa fa-check"></i><b>15.7.3</b> SQL命令简介</a></li>
<li class="chapter" data-level="15.7.4" data-path="prog-io.html"><a href="prog-io.html#p-io-db-oracle"><i class="fa fa-check"></i><b>15.7.4</b> 访问Oracle数据库</a></li>
<li class="chapter" data-level="15.7.5" data-path="prog-io.html"><a href="prog-io.html#p-io-db-mysql"><i class="fa fa-check"></i><b>15.7.5</b> MySQL数据库访问</a></li>
<li class="chapter" data-level="15.7.6" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-rodbc"><i class="fa fa-check"></i><b>15.7.6</b> 利用RODBC访问Access数据库</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="prog-control.html"><a href="prog-control.html"><i class="fa fa-check"></i><b>16</b> 程序控制结构</a><ul>
<li class="chapter" data-level="16.1" data-path="prog-control.html"><a href="prog-control.html#p-con-exp"><i class="fa fa-check"></i><b>16.1</b> 表达式</a></li>
<li class="chapter" data-level="16.2" data-path="prog-control.html"><a href="prog-control.html#p-con-if"><i class="fa fa-check"></i><b>16.2</b> 分支结构</a><ul>
<li class="chapter" data-level="16.2.1" data-path="prog-control.html"><a href="prog-control.html#p-con-logic-index"><i class="fa fa-check"></i><b>16.2.1</b> 用逻辑下标代替分支结构</a></li>
<li class="chapter" data-level="16.2.2" data-path="prog-control.html"><a href="prog-control.html#p-con-ifelsef"><i class="fa fa-check"></i><b>16.2.2</b> <code>ifelse</code>函数</a></li>
<li class="chapter" data-level="16.2.3" data-path="prog-control.html"><a href="prog-control.html#p-con-switch"><i class="fa fa-check"></i><b>16.2.3</b> <code>switch</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="16.3" data-path="prog-control.html"><a href="prog-control.html#p-con-loop"><i class="fa fa-check"></i><b>16.3</b> 循环结构</a><ul>
<li class="chapter" data-level="16.3.1" data-path="prog-control.html"><a href="prog-control.html#p-con-for"><i class="fa fa-check"></i><b>16.3.1</b> 计数循环</a></li>
<li class="chapter" data-level="16.3.2" data-path="prog-control.html"><a href="prog-control.html#p-con-while"><i class="fa fa-check"></i><b>16.3.2</b> <code>while</code>循环和<code>repeat</code>循环</a></li>
</ul></li>
<li class="chapter" data-level="16.4" data-path="prog-control.html"><a href="prog-control.html#p-con-cond"><i class="fa fa-check"></i><b>16.4</b> R中判断条件</a></li>
<li class="chapter" data-level="16.5" data-path="prog-control.html"><a href="prog-control.html#p-pipe"><i class="fa fa-check"></i><b>16.5</b> 管道控制</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="prog-func.html"><a href="prog-func.html"><i class="fa fa-check"></i><b>17</b> 函数</a><ul>
<li class="chapter" data-level="17.1" data-path="prog-func.html"><a href="prog-func.html#p-func"><i class="fa fa-check"></i><b>17.1</b> 函数基础</a><ul>
<li class="chapter" data-level="17.1.1" data-path="prog-func.html"><a href="prog-func.html#p-func-intro"><i class="fa fa-check"></i><b>17.1.1</b> 介绍</a></li>
<li class="chapter" data-level="17.1.2" data-path="prog-func.html"><a href="prog-func.html#p-func-def"><i class="fa fa-check"></i><b>17.1.2</b> 函数定义</a></li>
<li class="chapter" data-level="17.1.3" data-path="prog-func.html"><a href="prog-func.html#p-func-call"><i class="fa fa-check"></i><b>17.1.3</b> 函数调用</a></li>
<li class="chapter" data-level="17.1.4" data-path="prog-func.html"><a href="prog-func.html#p-func-recursive"><i class="fa fa-check"></i><b>17.1.4</b> 递归调用</a></li>
<li class="chapter" data-level="17.1.5" data-path="prog-func.html"><a href="prog-func.html#p-func-vr"><i class="fa fa-check"></i><b>17.1.5</b> 向量化</a></li>
<li class="chapter" data-level="17.1.6" data-path="prog-func.html"><a href="prog-func.html#p-func-anonymf"><i class="fa fa-check"></i><b>17.1.6</b> 无名函数</a></li>
</ul></li>
<li class="chapter" data-level="17.2" data-path="prog-func.html"><a href="prog-func.html#p-func-space"><i class="fa fa-check"></i><b>17.2</b> 变量作用域</a><ul>
<li class="chapter" data-level="17.2.1" data-path="prog-func.html"><a href="prog-func.html#p-func-global"><i class="fa fa-check"></i><b>17.2.1</b> 全局变量和工作空间</a></li>
<li class="chapter" data-level="17.2.2" data-path="prog-func.html"><a href="prog-func.html#p-func-local"><i class="fa fa-check"></i><b>17.2.2</b> 局部变量</a></li>
<li class="chapter" data-level="17.2.3" data-path="prog-func.html"><a href="prog-func.html#p-func-global-access"><i class="fa fa-check"></i><b>17.2.3</b> 在函数内访问全局变量</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="prog-prof.html"><a href="prog-prof.html"><i class="fa fa-check"></i><b>18</b> R程序效率</a><ul>
<li class="chapter" data-level="18.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-effic"><i class="fa fa-check"></i><b>18.1</b> R的运行效率</a></li>
<li class="chapter" data-level="18.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect"><i class="fa fa-check"></i><b>18.2</b> 向量化编程</a><ul>
<li class="chapter" data-level="18.2.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex1"><i class="fa fa-check"></i><b>18.2.1</b> 示例1</a></li>
<li class="chapter" data-level="18.2.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex2"><i class="fa fa-check"></i><b>18.2.2</b> 示例2</a></li>
<li class="chapter" data-level="18.2.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex3"><i class="fa fa-check"></i><b>18.2.3</b> 示例3</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-loop"><i class="fa fa-check"></i><b>18.3</b> 减少显式循环</a><ul>
<li class="chapter" data-level="18.3.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-replicate"><i class="fa fa-check"></i><b>18.3.1</b> <code>replicate()</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="18.4" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-copy"><i class="fa fa-check"></i><b>18.4</b> 避免制作副本</a></li>
<li class="chapter" data-level="18.5" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun"><i class="fa fa-check"></i><b>18.5</b> R的计算函数</a><ul>
<li class="chapter" data-level="18.5.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-math"><i class="fa fa-check"></i><b>18.5.1</b> 数学函数</a></li>
<li class="chapter" data-level="18.5.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-sum"><i class="fa fa-check"></i><b>18.5.2</b> 概括函数</a></li>
<li class="chapter" data-level="18.5.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-max"><i class="fa fa-check"></i><b>18.5.3</b> 最值</a></li>
<li class="chapter" data-level="18.5.4" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-sort"><i class="fa fa-check"></i><b>18.5.4</b> 排序</a></li>
<li class="chapter" data-level="18.5.5" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-integrate"><i class="fa fa-check"></i><b>18.5.5</b> 一元定积分<code>integrate</code></a></li>
<li class="chapter" data-level="18.5.6" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-uniroot"><i class="fa fa-check"></i><b>18.5.6</b> 一元函数求根<code>uniroot</code></a></li>
<li class="chapter" data-level="18.5.7" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-fft"><i class="fa fa-check"></i><b>18.5.7</b> 离散傅立叶变换<code>fft</code></a></li>
<li class="chapter" data-level="18.5.8" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-filter"><i class="fa fa-check"></i><b>18.5.8</b> 用<code>filter</code>函数作迭代</a></li>
</ul></li>
<li class="chapter" data-level="18.6" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu"><i class="fa fa-check"></i><b>18.6</b> 并行计算</a><ul>
<li class="chapter" data-level="18.6.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex1"><i class="fa fa-check"></i><b>18.6.1</b> 例1：完全不互相依赖的并行运算</a></li>
<li class="chapter" data-level="18.6.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex2"><i class="fa fa-check"></i><b>18.6.2</b> 例2：使用相同随机数序列的并行计算</a></li>
<li class="chapter" data-level="18.6.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex3"><i class="fa fa-check"></i><b>18.6.3</b> 例3：使用独立随机数序列的并行计算</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="19" data-path="p-advfunc.html"><a href="p-advfunc.html"><i class="fa fa-check"></i><b>19</b> 函数进阶</a><ul>
<li class="chapter" data-level="19.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-callspe"><i class="fa fa-check"></i><b>19.1</b> 函数调用的各种形式</a></li>
<li class="chapter" data-level="19.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-lex"><i class="fa fa-check"></i><b>19.2</b> 嵌套定义与句法作用域(lexical scoping)</a></li>
<li class="chapter" data-level="19.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-inner"><i class="fa fa-check"></i><b>19.3</b> 辅助嵌套函数</a></li>
<li class="chapter" data-level="19.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-lazy"><i class="fa fa-check"></i><b>19.4</b> 懒惰求值</a></li>
<li class="chapter" data-level="19.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug"><i class="fa fa-check"></i><b>19.5</b> 程序调试</a><ul>
<li class="chapter" data-level="19.5.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-intro"><i class="fa fa-check"></i><b>19.5.1</b> 基本调试策略</a></li>
<li class="chapter" data-level="19.5.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-findfunc"><i class="fa fa-check"></i><b>19.5.2</b> 找到出错的函数</a></li>
<li class="chapter" data-level="19.5.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-browser"><i class="fa fa-check"></i><b>19.5.3</b> 跟踪调试</a></li>
<li class="chapter" data-level="19.5.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-cond"><i class="fa fa-check"></i><b>19.5.4</b> 条件断点</a></li>
<li class="chapter" data-level="19.5.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-debugf"><i class="fa fa-check"></i><b>19.5.5</b> 开启对一个函数的调试</a></li>
<li class="chapter" data-level="19.5.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-opt"><i class="fa fa-check"></i><b>19.5.6</b> 出错调试选项</a></li>
<li class="chapter" data-level="19.5.7" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-stop"><i class="fa fa-check"></i><b>19.5.7</b> <code>stop()</code>、<code>warning()</code>、<code>message()</code></a></li>
<li class="chapter" data-level="19.5.8" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-preventive"><i class="fa fa-check"></i><b>19.5.8</b> 预防性设计</a></li>
<li class="chapter" data-level="19.5.9" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-try"><i class="fa fa-check"></i><b>19.5.9</b> 出错处理机制</a></li>
</ul></li>
<li class="chapter" data-level="19.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-funcprog"><i class="fa fa-check"></i><b>19.6</b> 函数式编程介绍</a><ul>
<li class="chapter" data-level="19.6.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-pure"><i class="fa fa-check"></i><b>19.6.1</b> 纯函数</a></li>
<li class="chapter" data-level="19.6.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-rec"><i class="fa fa-check"></i><b>19.6.2</b> 副作用和运行环境恢复</a></li>
<li class="chapter" data-level="19.6.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-rsupp"><i class="fa fa-check"></i><b>19.6.3</b> R的函数式编程功能</a></li>
</ul></li>
<li class="chapter" data-level="19.7" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-functional"><i class="fa fa-check"></i><b>19.7</b> 泛函</a><ul>
<li class="chapter" data-level="19.7.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-map"><i class="fa fa-check"></i><b>19.7.1</b> <code>purrr::map</code>函数</a></li>
<li class="chapter" data-level="19.7.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-mapv"><i class="fa fa-check"></i><b>19.7.2</b> purrr包中<code>map</code>函数的变种</a></li>
<li class="chapter" data-level="19.7.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-reduce"><i class="fa fa-check"></i><b>19.7.3</b> purrr包中<code>reduce</code>类函数</a></li>
<li class="chapter" data-level="19.7.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-pred"><i class="fa fa-check"></i><b>19.7.4</b> purrr包中使用示性函数的泛函</a></li>
<li class="chapter" data-level="19.7.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-lapp"><i class="fa fa-check"></i><b>19.7.5</b> 基本R的函数式编程支持</a></li>
<li class="chapter" data-level="19.7.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-udef"><i class="fa fa-check"></i><b>19.7.6</b> 自定义泛函</a></li>
</ul></li>
<li class="chapter" data-level="19.8" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory"><i class="fa fa-check"></i><b>19.8</b> 函数工厂</a><ul>
<li class="chapter" data-level="19.8.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-clex"><i class="fa fa-check"></i><b>19.8.1</b> 闭包例子</a></li>
<li class="chapter" data-level="19.8.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-lazy"><i class="fa fa-check"></i><b>19.8.2</b> 动态查找和懒惰求值引起的问题</a></li>
<li class="chapter" data-level="19.8.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-mem"><i class="fa fa-check"></i><b>19.8.3</b> 函数工厂的内存负担</a></li>
<li class="chapter" data-level="19.8.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-operator"><i class="fa fa-check"></i><b>19.8.4</b> 函数算子</a></li>
</ul></li>
<li class="chapter" data-level="19.9" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env"><i class="fa fa-check"></i><b>19.9</b> 环境</a><ul>
<li class="chapter" data-level="19.9.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-def"><i class="fa fa-check"></i><b>19.9.1</b> 基本概念</a></li>
<li class="chapter" data-level="19.9.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-recurs"><i class="fa fa-check"></i><b>19.9.2</b> 逐层向上访问环境</a></li>
<li class="chapter" data-level="19.9.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-spec"><i class="fa fa-check"></i><b>19.9.3</b> 特殊环境</a></li>
<li class="chapter" data-level="19.9.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-callst"><i class="fa fa-check"></i><b>19.9.4</b> 调用栈</a></li>
<li class="chapter" data-level="19.9.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-usedt"><i class="fa fa-check"></i><b>19.9.5</b> 将环境用作一般数据结构</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV 制作研究报告和图书</b></span></li>
<li class="chapter" data-level="20" data-path="knitr.html"><a href="knitr.html"><i class="fa fa-check"></i><b>20</b> 用R制作研究报告</a></li>
<li class="chapter" data-level="21" data-path="markdown.html"><a href="markdown.html"><i class="fa fa-check"></i><b>21</b> Markdown格式</a><ul>
<li class="chapter" data-level="21.1" data-path="markdown.html"><a href="markdown.html#markdown-intro"><i class="fa fa-check"></i><b>21.1</b> 介绍</a></li>
<li class="chapter" data-level="21.2" data-path="markdown.html"><a href="markdown.html#markdown-app"><i class="fa fa-check"></i><b>21.2</b> Markdown格式文件的应用</a></li>
<li class="chapter" data-level="21.3" data-path="markdown.html"><a href="markdown.html#markdown-format"><i class="fa fa-check"></i><b>21.3</b> markdown格式说明</a><ul>
<li class="chapter" data-level="21.3.1" data-path="markdown.html"><a href="markdown.html#markdown-format-intro"><i class="fa fa-check"></i><b>21.3.1</b> 概述</a></li>
<li class="chapter" data-level="21.3.2" data-path="markdown.html"><a href="markdown.html#markdown-format-paragraph"><i class="fa fa-check"></i><b>21.3.2</b> 段落</a></li>
<li class="chapter" data-level="21.3.3" data-path="markdown.html"><a href="markdown.html#markdown-format-inline"><i class="fa fa-check"></i><b>21.3.3</b> 段内文字格式</a></li>
<li class="chapter" data-level="21.3.4" data-path="markdown.html"><a href="markdown.html#markdown-format-header"><i class="fa fa-check"></i><b>21.3.4</b> 标题和分隔线</a></li>
<li class="chapter" data-level="21.3.5" data-path="markdown.html"><a href="markdown.html#markdown-format-cite"><i class="fa fa-check"></i><b>21.3.5</b> 引用段落</a></li>
<li class="chapter" data-level="21.3.6" data-path="markdown.html"><a href="markdown.html#markdown-format-list"><i class="fa fa-check"></i><b>21.3.6</b> 列表</a></li>
<li class="chapter" data-level="21.3.7" data-path="markdown.html"><a href="markdown.html#markdown-format-code"><i class="fa fa-check"></i><b>21.3.7</b> 源程序</a></li>
<li class="chapter" data-level="21.3.8" data-path="markdown.html"><a href="markdown.html#markdown-format-link"><i class="fa fa-check"></i><b>21.3.8</b> 链接</a></li>
<li class="chapter" data-level="21.3.9" data-path="markdown.html"><a href="markdown.html#markdown-format-fig"><i class="fa fa-check"></i><b>21.3.9</b> 插入图形</a></li>
<li class="chapter" data-level="21.3.10" data-path="markdown.html"><a href="markdown.html#markdown-format-table"><i class="fa fa-check"></i><b>21.3.10</b> 表格</a></li>
</ul></li>
<li class="chapter" data-level="21.4" data-path="markdown.html"><a href="markdown.html#markdown-pandoc"><i class="fa fa-check"></i><b>21.4</b> 附录：pandoc软件介绍</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="rmarkdown.html"><a href="rmarkdown.html"><i class="fa fa-check"></i><b>22</b> R Markdown文件格式</a><ul>
<li class="chapter" data-level="22.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-intro"><i class="fa fa-check"></i><b>22.1</b> R Markdown文件</a></li>
<li class="chapter" data-level="22.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-compile"><i class="fa fa-check"></i><b>22.2</b> R Markdown文件的编译</a><ul>
<li class="chapter" data-level="22.2.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-compile-proc"><i class="fa fa-check"></i><b>22.2.1</b> 编译的实际过程</a></li>
</ul></li>
<li class="chapter" data-level="22.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode"><i class="fa fa-check"></i><b>22.3</b> 在R Markdown文件中插入R代码</a></li>
<li class="chapter" data-level="22.4" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-kable"><i class="fa fa-check"></i><b>22.4</b> 输出表格</a></li>
<li class="chapter" data-level="22.5" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-graph"><i class="fa fa-check"></i><b>22.5</b> 利用R程序插图</a></li>
<li class="chapter" data-level="22.6" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-opt"><i class="fa fa-check"></i><b>22.6</b> 代码段选项</a><ul>
<li class="chapter" data-level="22.6.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-outformat"><i class="fa fa-check"></i><b>22.6.1</b> 代码和文本输出结果格式</a></li>
<li class="chapter" data-level="22.6.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-figopt"><i class="fa fa-check"></i><b>22.6.2</b> 图形选项</a></li>
<li class="chapter" data-level="22.6.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-cache"><i class="fa fa-check"></i><b>22.6.3</b> 缓存(cache)选项</a></li>
</ul></li>
<li class="chapter" data-level="22.7" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd--sectionlink"><i class="fa fa-check"></i><b>22.7</b> 章节目录链接问题</a></li>
<li class="chapter" data-level="22.8" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula"><i class="fa fa-check"></i><b>22.8</b> 数学公式</a><ul>
<li class="chapter" data-level="22.8.1" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-intro"><i class="fa fa-check"></i><b>22.8.1</b> 在Markdown中输入数学公式</a></li>
<li class="chapter" data-level="22.8.2" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-type"><i class="fa fa-check"></i><b>22.8.2</b> 数学公式类别</a></li>
<li class="chapter" data-level="22.8.3" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-basic"><i class="fa fa-check"></i><b>22.8.3</b> 基本功能</a></li>
<li class="chapter" data-level="22.8.4" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-accent"><i class="fa fa-check"></i><b>22.8.4</b> 修饰符</a></li>
<li class="chapter" data-level="22.8.5" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-align"><i class="fa fa-check"></i><b>22.8.5</b> 对齐与矩阵</a></li>
<li class="chapter" data-level="22.8.6" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-fonts"><i class="fa fa-check"></i><b>22.8.6</b> 特殊字体</a></li>
</ul></li>
<li class="chapter" data-level="22.9" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-engines"><i class="fa fa-check"></i><b>22.9</b> 其它编程语言引擎</a></li>
<li class="chapter" data-level="22.10" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-interact"><i class="fa fa-check"></i><b>22.10</b> 交互内容</a></li>
<li class="chapter" data-level="22.11" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-attryaml"><i class="fa fa-check"></i><b>22.11</b> 属性设置</a><ul>
<li class="chapter" data-level="22.11.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-yaml"><i class="fa fa-check"></i><b>22.11.1</b> YAML元数据</a></li>
<li class="chapter" data-level="22.11.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-types"><i class="fa fa-check"></i><b>22.11.2</b> 输出格式</a></li>
<li class="chapter" data-level="22.11.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr"><i class="fa fa-check"></i><b>22.11.3</b> 输出格式设置</a></li>
<li class="chapter" data-level="22.11.4" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-toc"><i class="fa fa-check"></i><b>22.11.4</b> 目录设置</a></li>
<li class="chapter" data-level="22.11.5" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-numsec"><i class="fa fa-check"></i><b>22.11.5</b> 章节自动编号</a></li>
<li class="chapter" data-level="22.11.6" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-wordnumsec"><i class="fa fa-check"></i><b>22.11.6</b> Word输出章节自动编号及模板功能</a></li>
<li class="chapter" data-level="22.11.7" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-htmlspecific"><i class="fa fa-check"></i><b>22.11.7</b> HTML特有输出格式设置</a></li>
<li class="chapter" data-level="22.11.8" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-mathjax"><i class="fa fa-check"></i><b>22.11.8</b> 关于数学公式支持的设置</a></li>
<li class="chapter" data-level="22.11.9" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-yml"><i class="fa fa-check"></i><b>22.11.9</b> 输出设置文件</a></li>
</ul></li>
<li class="chapter" data-level="22.12" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex"><i class="fa fa-check"></i><b>22.12</b> LaTeX和PDF输出</a><ul>
<li class="chapter" data-level="22.12.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex-tinytex"><i class="fa fa-check"></i><b>22.12.1</b> TinyTex的安装使用</a></li>
<li class="chapter" data-level="22.12.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex-yaml"><i class="fa fa-check"></i><b>22.12.2</b> Rmd中Latex设置</a></li>
</ul></li>
<li class="chapter" data-level="22.13" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-rticles"><i class="fa fa-check"></i><b>22.13</b> 生成期刊文章</a></li>
<li class="chapter" data-level="22.14" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1"><i class="fa fa-check"></i><b>22.14</b> 附录：经验与问题</a><ul>
<li class="chapter" data-level="22.14.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1-wordtemplate"><i class="fa fa-check"></i><b>22.14.1</b> Word模板制作</a></li>
<li class="chapter" data-level="22.14.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1-math"><i class="fa fa-check"></i><b>22.14.2</b> 数学公式设置补充</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="23" data-path="bookdown.html"><a href="bookdown.html"><i class="fa fa-check"></i><b>23</b> 用bookdown制作图书</a><ul>
<li class="chapter" data-level="23.1" data-path="bookdown.html"><a href="bookdown.html#bookdown-intro"><i class="fa fa-check"></i><b>23.1</b> 介绍</a></li>
<li class="chapter" data-level="23.2" data-path="bookdown.html"><a href="bookdown.html#bookdown-settings"><i class="fa fa-check"></i><b>23.2</b> 一本书的设置</a></li>
<li class="chapter" data-level="23.3" data-path="bookdown.html"><a href="bookdown.html#bookdown-sectioning"><i class="fa fa-check"></i><b>23.3</b> 章节结构</a></li>
<li class="chapter" data-level="23.4" data-path="bookdown.html"><a href="bookdown.html#bookdown-compile"><i class="fa fa-check"></i><b>23.4</b> 书的编译</a></li>
<li class="chapter" data-level="23.5" data-path="bookdown.html"><a href="bookdown.html#bookdown-cref"><i class="fa fa-check"></i><b>23.5</b> 交叉引用</a></li>
<li class="chapter" data-level="23.6" data-path="bookdown.html"><a href="bookdown.html#bookdown-formula"><i class="fa fa-check"></i><b>23.6</b> 数学公式和公式编号</a></li>
<li class="chapter" data-level="23.7" data-path="bookdown.html"><a href="bookdown.html#bookdown-theorem"><i class="fa fa-check"></i><b>23.7</b> 定理类编号</a></li>
<li class="chapter" data-level="23.8" data-path="bookdown.html"><a href="bookdown.html#bookdown-bib"><i class="fa fa-check"></i><b>23.8</b> 文献引用</a></li>
<li class="chapter" data-level="23.9" data-path="bookdown.html"><a href="bookdown.html#bookdown-graph"><i class="fa fa-check"></i><b>23.9</b> 插图</a></li>
<li class="chapter" data-level="23.10" data-path="bookdown.html"><a href="bookdown.html#bookdown-table"><i class="fa fa-check"></i><b>23.10</b> 表格</a><ul>
<li class="chapter" data-level="23.10.1" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-md"><i class="fa fa-check"></i><b>23.10.1</b> Markdown表格</a></li>
<li class="chapter" data-level="23.10.2" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-kable"><i class="fa fa-check"></i><b>23.10.2</b> 用<code>kable()</code>函数制作表格</a></li>
<li class="chapter" data-level="23.10.3" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-kable"><i class="fa fa-check"></i><b>23.10.3</b> R中其它制作表格的包</a></li>
</ul></li>
<li class="chapter" data-level="23.11" data-path="bookdown.html"><a href="bookdown.html#bookdown-mathjax"><i class="fa fa-check"></i><b>23.11</b> 数学公式的设置</a></li>
<li class="chapter" data-level="23.12" data-path="bookdown.html"><a href="bookdown.html#bookdown-exp"><i class="fa fa-check"></i><b>23.12</b> 使用经验</a></li>
<li class="chapter" data-level="23.13" data-path="bookdown.html"><a href="bookdown.html#bookdown-bugs"><i class="fa fa-check"></i><b>23.13</b> bookdown的一些使用问题</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="rmdsite.html"><a href="rmdsite.html"><i class="fa fa-check"></i><b>24</b> 用R Markdown制作简易网站</a><ul>
<li class="chapter" data-level="24.1" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-intro"><i class="fa fa-check"></i><b>24.1</b> 介绍</a></li>
<li class="chapter" data-level="24.2" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown"><i class="fa fa-check"></i><b>24.2</b> 简易网站制作</a><ul>
<li class="chapter" data-level="24.2.1" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-struct"><i class="fa fa-check"></i><b>24.2.1</b> 网站结构</a></li>
<li class="chapter" data-level="24.2.2" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-build"><i class="fa fa-check"></i><b>24.2.2</b> 编译</a></li>
<li class="chapter" data-level="24.2.3" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-pages"><i class="fa fa-check"></i><b>24.2.3</b> 内容文件</a></li>
<li class="chapter" data-level="24.2.4" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-config"><i class="fa fa-check"></i><b>24.2.4</b> 网站设置</a></li>
</ul></li>
<li class="chapter" data-level="24.3" data-path="rmdsite.html"><a href="rmdsite.html#blogdown"><i class="fa fa-check"></i><b>24.3</b> 用blogdown制作网站</a><ul>
<li class="chapter" data-level="24.3.1" data-path="rmdsite.html"><a href="rmdsite.html#blogd-new"><i class="fa fa-check"></i><b>24.3.1</b> 生成新网站的框架</a></li>
<li class="chapter" data-level="24.3.2" data-path="rmdsite.html"><a href="rmdsite.html#blogd-page"><i class="fa fa-check"></i><b>24.3.2</b> 网页内容文件及其设置</a></li>
<li class="chapter" data-level="24.3.3" data-path="rmdsite.html"><a href="rmdsite.html#blogd-workflow"><i class="fa fa-check"></i><b>24.3.3</b> 初学者的工作流程</a></li>
<li class="chapter" data-level="24.3.4" data-path="rmdsite.html"><a href="rmdsite.html#blogd-config"><i class="fa fa-check"></i><b>24.3.4</b> 网站设置文件</a></li>
<li class="chapter" data-level="24.3.5" data-path="rmdsite.html"><a href="rmdsite.html#blogd-static"><i class="fa fa-check"></i><b>24.3.5</b> 静态文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="25" data-path="slides.html"><a href="slides.html"><i class="fa fa-check"></i><b>25</b> 制作幻灯片</a><ul>
<li class="chapter" data-level="25.1" data-path="slides.html"><a href="slides.html#rmd-slides-intro"><i class="fa fa-check"></i><b>25.1</b> 介绍</a></li>
<li class="chapter" data-level="25.2" data-path="slides.html"><a href="slides.html#rmd-slidy"><i class="fa fa-check"></i><b>25.2</b> Slidy幻灯片</a><ul>
<li class="chapter" data-level="25.2.1" data-path="slides.html"><a href="slides.html#rmd-slidy-format"><i class="fa fa-check"></i><b>25.2.1</b> 文件格式</a></li>
<li class="chapter" data-level="25.2.2" data-path="slides.html"><a href="slides.html#rmd-slidy-compile"><i class="fa fa-check"></i><b>25.2.2</b> 幻灯片编译</a></li>
<li class="chapter" data-level="25.2.3" data-path="slides.html"><a href="slides.html#rmd-slidy-play"><i class="fa fa-check"></i><b>25.2.3</b> 播放控制</a></li>
<li class="chapter" data-level="25.2.4" data-path="slides.html"><a href="slides.html#rmd-slidy-handout"><i class="fa fa-check"></i><b>25.2.4</b> 生成单页HTML</a></li>
<li class="chapter" data-level="25.2.5" data-path="slides.html"><a href="slides.html#rmd-slidy-mathjax"><i class="fa fa-check"></i><b>25.2.5</b> 数学公式处理与输出设置文件</a></li>
<li class="chapter" data-level="25.2.6" data-path="slides.html"><a href="slides.html#rmd-slidy-options"><i class="fa fa-check"></i><b>25.2.6</b> 其它选项</a></li>
<li class="chapter" data-level="25.2.7" data-path="slides.html"><a href="slides.html#rmd-slidy-laser"><i class="fa fa-check"></i><b>25.2.7</b> slidy幻灯片激光笔失效问题的修改</a></li>
</ul></li>
<li class="chapter" data-level="25.3" data-path="slides.html"><a href="slides.html#rmdslides-pp"><i class="fa fa-check"></i><b>25.3</b> MS PowerPoint幻灯片</a></li>
<li class="chapter" data-level="25.4" data-path="slides.html"><a href="slides.html#rmdslides-beamer"><i class="fa fa-check"></i><b>25.4</b> Bearmer幻灯片格式</a></li>
<li class="chapter" data-level="25.5" data-path="slides.html"><a href="slides.html#rmdslides-rpres"><i class="fa fa-check"></i><b>25.5</b> R Presentation格式</a></li>
</ul></li>
<li class="part"><span><b>V 数据整理与汇总</b></span></li>
<li class="chapter" data-level="26" data-path="summary-manip.html"><a href="summary-manip.html"><i class="fa fa-check"></i><b>26</b> 数据整理</a><ul>
<li class="chapter" data-level="26.1" data-path="summary-manip.html"><a href="summary-manip.html#summm-tidyv"><i class="fa fa-check"></i><b>26.1</b> tidyverse系统</a></li>
<li class="chapter" data-level="26.2" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-filter"><i class="fa fa-check"></i><b>26.2</b> 用<code>filter()</code>选择行子集</a></li>
<li class="chapter" data-level="26.3" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-head"><i class="fa fa-check"></i><b>26.3</b> 按行序号选择行子集</a></li>
<li class="chapter" data-level="26.4" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-samplen"><i class="fa fa-check"></i><b>26.4</b> 用<code>sample_n()</code>对观测随机抽样</a></li>
<li class="chapter" data-level="26.5" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-distinct"><i class="fa fa-check"></i><b>26.5</b> 用<code>distinct()</code>去除重复行</a></li>
<li class="chapter" data-level="26.6" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-dropna"><i class="fa fa-check"></i><b>26.6</b> 用<code>drop_na()</code>去除指定的变量有缺失值的行</a></li>
<li class="chapter" data-level="26.7" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-select"><i class="fa fa-check"></i><b>26.7</b> 用<code>select()</code>选择列子集</a></li>
<li class="chapter" data-level="26.8" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-pull"><i class="fa fa-check"></i><b>26.8</b> 取出单个变量为向量</a></li>
<li class="chapter" data-level="26.9" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-arrange"><i class="fa fa-check"></i><b>26.9</b> 用<code>arrange()</code>排序</a></li>
<li class="chapter" data-level="26.10" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-rename"><i class="fa fa-check"></i><b>26.10</b> 用<code>rename()</code>修改变量名</a></li>
<li class="chapter" data-level="26.11" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-mutate"><i class="fa fa-check"></i><b>26.11</b> 用<code>mutate()</code>计算新变量</a></li>
<li class="chapter" data-level="26.12" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-transmute"><i class="fa fa-check"></i><b>26.12</b> 用<code>tranmute()</code>生成新变量的数据框</a></li>
<li class="chapter" data-level="26.13" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-pipe"><i class="fa fa-check"></i><b>26.13</b> 用管道连接多次操作</a></li>
<li class="chapter" data-level="26.14" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer"><i class="fa fa-check"></i><b>26.14</b> 宽表转换为长表</a><ul>
<li class="chapter" data-level="26.14.1" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-pl"><i class="fa fa-check"></i><b>26.14.1</b> <code>pivot_longer</code>函数</a></li>
<li class="chapter" data-level="26.14.2" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-prefixvalue"><i class="fa fa-check"></i><b>26.14.2</b> 从列名中提取数值</a></li>
<li class="chapter" data-level="26.14.3" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-colnamemultclassv"><i class="fa fa-check"></i><b>26.14.3</b> 从列名中提取多个分类变量值</a></li>
<li class="chapter" data-level="26.14.4" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-multvarsmultclassv"><i class="fa fa-check"></i><b>26.14.4</b> 一行中有多个属性的多次观测的情形</a></li>
</ul></li>
<li class="chapter" data-level="26.15" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider"><i class="fa fa-check"></i><b>26.15</b> 长表转换为宽表</a><ul>
<li class="chapter" data-level="26.15.1" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-sepvars"><i class="fa fa-check"></i><b>26.15.1</b> 将多个混在一起的变量拆开</a></li>
<li class="chapter" data-level="26.15.2" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-combtimes"><i class="fa fa-check"></i><b>26.15.2</b> 将多个类别合并到一个观测</a></li>
<li class="chapter" data-level="26.15.3" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-combcross"><i class="fa fa-check"></i><b>26.15.3</b> 将交叉类别合并到一个观测</a></li>
<li class="chapter" data-level="26.15.4" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-mvmest"><i class="fa fa-check"></i><b>26.15.4</b> 多个变量的多种值</a></li>
<li class="chapter" data-level="26.15.5" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-mixed"><i class="fa fa-check"></i><b>26.15.5</b> 长宽转换混合使用</a></li>
</ul></li>
<li class="chapter" data-level="26.16" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-spearate"><i class="fa fa-check"></i><b>26.16</b> 拆分数据列</a></li>
<li class="chapter" data-level="26.17" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-unite"><i class="fa fa-check"></i><b>26.17</b> 合并数据列</a></li>
<li class="chapter" data-level="26.18" data-path="summary-manip.html"><a href="summary-manip.html#summ-trans-combv"><i class="fa fa-check"></i><b>26.18</b> 数据框纵向合并</a></li>
<li class="chapter" data-level="26.19" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-join"><i class="fa fa-check"></i><b>26.19</b> 横向合并</a></li>
<li class="chapter" data-level="26.20" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-semi"><i class="fa fa-check"></i><b>26.20</b> 利用第二个数据集筛选</a></li>
<li class="chapter" data-level="26.21" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-set"><i class="fa fa-check"></i><b>26.21</b> 数据集的集合操作</a></li>
<li class="chapter" data-level="26.22" data-path="summary-manip.html"><a href="summary-manip.html#summ-trans-standard"><i class="fa fa-check"></i><b>26.22</b> 标准化</a></li>
</ul></li>
<li class="chapter" data-level="27" data-path="summary-summ.html"><a href="summary-summ.html"><i class="fa fa-check"></i><b>27</b> 数据汇总</a><ul>
<li class="chapter" data-level="27.1" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-summ"><i class="fa fa-check"></i><b>27.1</b> 用dplyr作数据汇总</a></li>
<li class="chapter" data-level="27.2" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-summat"><i class="fa fa-check"></i><b>27.2</b> 多个变量的汇总</a></li>
<li class="chapter" data-level="27.3" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-groupby"><i class="fa fa-check"></i><b>27.3</b> 用dplyr作数据分组汇总</a></li>
<li class="chapter" data-level="27.4" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-crossgroup"><i class="fa fa-check"></i><b>27.4</b> 交叉分类的汇总</a></li>
<li class="chapter" data-level="27.5" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest"><i class="fa fa-check"></i><b>27.5</b> tibble中的列表列</a><ul>
<li class="chapter" data-level="27.5.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-intro"><i class="fa fa-check"></i><b>27.5.1</b> <code>nest</code>和<code>unnest</code></a></li>
<li class="chapter" data-level="27.5.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-groupby"><i class="fa fa-check"></i><b>27.5.2</b> <code>group_by</code>与<code>nest</code>配合</a></li>
<li class="chapter" data-level="27.5.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-summarise"><i class="fa fa-check"></i><b>27.5.3</b> <code>summarise</code>统计量用列表表示</a></li>
<li class="chapter" data-level="27.5.4" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-unnest-grammar"><i class="fa fa-check"></i><b>27.5.4</b> <code>unnest</code>的语法格式</a></li>
<li class="chapter" data-level="27.5.5" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-direct"><i class="fa fa-check"></i><b>27.5.5</b> 直接生成列表类型的列</a></li>
</ul></li>
<li class="chapter" data-level="27.6" data-path="summary-summ.html"><a href="summary-summ.html#summ-base"><i class="fa fa-check"></i><b>27.6</b> 基本R的汇总功能</a><ul>
<li class="chapter" data-level="27.6.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-base-summary"><i class="fa fa-check"></i><b>27.6.1</b> <code>summary()</code>函数</a></li>
<li class="chapter" data-level="27.6.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-cont"><i class="fa fa-check"></i><b>27.6.2</b> 连续型变量概括函数</a></li>
<li class="chapter" data-level="27.6.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-fact"><i class="fa fa-check"></i><b>27.6.3</b> 分类变量概括</a></li>
<li class="chapter" data-level="27.6.4" data-path="summary-summ.html"><a href="summary-summ.html#summ-df"><i class="fa fa-check"></i><b>27.6.4</b> 数据框概括</a></li>
</ul></li>
<li class="chapter" data-level="27.7" data-path="summary-summ.html"><a href="summary-summ.html#summ-by"><i class="fa fa-check"></i><b>27.7</b> 用基本R作分类概括</a><ul>
<li class="chapter" data-level="27.7.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-tapply"><i class="fa fa-check"></i><b>27.7.1</b> 用<code>tapply()</code>分组概括向量</a></li>
<li class="chapter" data-level="27.7.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-aggregate"><i class="fa fa-check"></i><b>27.7.2</b> 用<code>aggregate()</code>分组概括数据框</a></li>
<li class="chapter" data-level="27.7.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-split"><i class="fa fa-check"></i><b>27.7.3</b> 用<code>split()</code>函数分组后概括</a></li>
</ul></li>
<li class="chapter" data-level="27.8" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-plyr"><i class="fa fa-check"></i><b>27.8</b> 用plyr包进行分类概括</a></li>
<li class="chapter" data-level="27.9" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-exer"><i class="fa fa-check"></i><b>27.9</b> 练习</a></li>
</ul></li>
<li class="part"><span><b>VI 绘图</b></span></li>
<li class="chapter" data-level="28" data-path="graph.html"><a href="graph.html"><i class="fa fa-check"></i><b>28</b> 基本R绘图</a><ul>
<li class="chapter" data-level="28.1" data-path="graph.html"><a href="graph.html#graph-ph"><i class="fa fa-check"></i><b>28.1</b> 常用高级图形</a><ul>
<li class="chapter" data-level="28.1.1" data-path="graph.html"><a href="graph.html#graph-ph-barplot"><i class="fa fa-check"></i><b>28.1.1</b> 条形图</a></li>
<li class="chapter" data-level="28.1.2" data-path="graph.html"><a href="graph.html#graph-ph-hist"><i class="fa fa-check"></i><b>28.1.2</b> 直方图和密度估计图</a></li>
<li class="chapter" data-level="28.1.3" data-path="graph.html"><a href="graph.html#graph-ph-boxplot"><i class="fa fa-check"></i><b>28.1.3</b> 盒形图</a></li>
<li class="chapter" data-level="28.1.4" data-path="graph.html"><a href="graph.html#graph-pr-qq"><i class="fa fa-check"></i><b>28.1.4</b> 正态QQ图</a></li>
<li class="chapter" data-level="28.1.5" data-path="graph.html"><a href="graph.html#graph-ph-plot"><i class="fa fa-check"></i><b>28.1.5</b> 散点图</a></li>
<li class="chapter" data-level="28.1.6" data-path="graph.html"><a href="graph.html#graph-ph-curve"><i class="fa fa-check"></i><b>28.1.6</b> 曲线图</a></li>
<li class="chapter" data-level="28.1.7" data-path="graph.html"><a href="graph.html#graph-ph-3d"><i class="fa fa-check"></i><b>28.1.7</b> 三维图</a></li>
<li class="chapter" data-level="28.1.8" data-path="graph.html"><a href="graph.html#graph-ph-rgl"><i class="fa fa-check"></i><b>28.1.8</b> 动态三维图</a></li>
</ul></li>
<li class="chapter" data-level="28.2" data-path="graph.html"><a href="graph.html#graph-pl"><i class="fa fa-check"></i><b>28.2</b> 低级图形函数</a><ul>
<li class="chapter" data-level="28.2.1" data-path="graph.html"><a href="graph.html#graph-pl-abline"><i class="fa fa-check"></i><b>28.2.1</b> <code>abline()</code></a></li>
<li class="chapter" data-level="28.2.2" data-path="graph.html"><a href="graph.html#graph-pl-points"><i class="fa fa-check"></i><b>28.2.2</b> <code>points()</code></a></li>
<li class="chapter" data-level="28.2.3" data-path="graph.html"><a href="graph.html#graph-pl-lines"><i class="fa fa-check"></i><b>28.2.3</b> <code>lines()</code></a></li>
<li class="chapter" data-level="28.2.4" data-path="graph.html"><a href="graph.html#graph-pl-legend"><i class="fa fa-check"></i><b>28.2.4</b> 图例</a></li>
<li class="chapter" data-level="28.2.5" data-path="graph.html"><a href="graph.html#graph-pl-axis"><i class="fa fa-check"></i><b>28.2.5</b> <code>axis()</code></a></li>
<li class="chapter" data-level="28.2.6" data-path="graph.html"><a href="graph.html#graph-pl-text"><i class="fa fa-check"></i><b>28.2.6</b> <code>text()</code></a></li>
<li class="chapter" data-level="28.2.7" data-path="graph.html"><a href="graph.html#graph-pl-locator"><i class="fa fa-check"></i><b>28.2.7</b> <code>locator()</code>和<code>identify()</code></a></li>
</ul></li>
<li class="chapter" data-level="28.3" data-path="graph.html"><a href="graph.html#graph-par"><i class="fa fa-check"></i><b>28.3</b> 图形参数</a><ul>
<li class="chapter" data-level="28.3.1" data-path="graph.html"><a href="graph.html#graph-par-ex1"><i class="fa fa-check"></i><b>28.3.1</b> 例子：用图形参数解决barplot图形横坐标值过宽</a></li>
<li class="chapter" data-level="28.3.2" data-path="graph.html"><a href="graph.html#graph-par-elem"><i class="fa fa-check"></i><b>28.3.2</b> 图形元素控制</a></li>
<li class="chapter" data-level="28.3.3" data-path="graph.html"><a href="graph.html#graph-par-axis"><i class="fa fa-check"></i><b>28.3.3</b> 坐标轴与坐标刻度</a></li>
<li class="chapter" data-level="28.3.4" data-path="graph.html"><a href="graph.html#graph-par-mar"><i class="fa fa-check"></i><b>28.3.4</b> 图形边空</a></li>
<li class="chapter" data-level="28.3.5" data-path="graph.html"><a href="graph.html#graph-par-mfrow"><i class="fa fa-check"></i><b>28.3.5</b> 一页多图</a></li>
</ul></li>
<li class="chapter" data-level="28.4" data-path="graph.html"><a href="graph.html#graph-pout"><i class="fa fa-check"></i><b>28.4</b> 图形输出</a><ul>
<li class="chapter" data-level="28.4.1" data-path="graph.html"><a href="graph.html#graph-pout-pdf"><i class="fa fa-check"></i><b>28.4.1</b> PDF 输出</a></li>
<li class="chapter" data-level="28.4.2" data-path="graph.html"><a href="graph.html#graph-pout-png"><i class="fa fa-check"></i><b>28.4.2</b> PNG输出</a></li>
</ul></li>
<li class="chapter" data-level="28.5" data-path="graph.html"><a href="graph.html#graph-pzhn"><i class="fa fa-check"></i><b>28.5</b> 包含多种中文字体的图形</a></li>
<li class="chapter" data-level="28.6" data-path="graph.html"><a href="graph.html#graph-other"><i class="fa fa-check"></i><b>28.6</b> 其它图形</a><ul>
<li class="chapter" data-level="28.6.1" data-path="graph.html"><a href="graph.html#graph-other-corr"><i class="fa fa-check"></i><b>28.6.1</b> 相关系数图</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="29" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>29</b> ggplot作图入门</a><ul>
<li class="chapter" data-level="29.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-intro"><i class="fa fa-check"></i><b>29.1</b> 介绍</a></li>
<li class="chapter" data-level="29.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-principles"><i class="fa fa-check"></i><b>29.2</b> 作图的一般原则</a></li>
<li class="chapter" data-level="29.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point"><i class="fa fa-check"></i><b>29.3</b> 散点图：ggplot入门</a><ul>
<li class="chapter" data-level="29.3.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-base"><i class="fa fa-check"></i><b>29.3.1</b> 基本的散点图</a></li>
<li class="chapter" data-level="29.3.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-layers"><i class="fa fa-check"></i><b>29.3.2</b> 逐步改善</a></li>
<li class="chapter" data-level="29.3.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-otheraes"><i class="fa fa-check"></i><b>29.3.3</b> 颜色、符号、线型等映射</a></li>
<li class="chapter" data-level="29.3.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-geomaes"><i class="fa fa-check"></i><b>29.3.4</b> 在geom函数中映射变量</a></li>
<li class="chapter" data-level="29.3.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-contcolor"><i class="fa fa-check"></i><b>29.3.5</b> 连续变量的颜色映射</a></li>
<li class="chapter" data-level="29.3.6" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-save"><i class="fa fa-check"></i><b>29.3.6</b> 保存图像</a></li>
</ul></li>
<li class="chapter" data-level="29.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right"><i class="fa fa-check"></i><b>29.4</b> 折线图、分组、小图</a><ul>
<li class="chapter" data-level="29.4.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-group"><i class="fa fa-check"></i><b>29.4.1</b> 图形中的分组和折线图</a></li>
<li class="chapter" data-level="29.4.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-facet"><i class="fa fa-check"></i><b>29.4.2</b> 小图(facet)</a></li>
</ul></li>
<li class="chapter" data-level="29.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-bar-trans"><i class="fa fa-check"></i><b>29.5</b> 数据变换与条形图</a><ul>
<li class="chapter" data-level="29.5.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-morebar"><i class="fa fa-check"></i><b>29.5.1</b> 分段与并列条形图</a></li>
<li class="chapter" data-level="29.5.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-bar-morebar"><i class="fa fa-check"></i><b>29.5.2</b> 条形图的其它应用</a></li>
</ul></li>
<li class="chapter" data-level="29.6" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-hist"><i class="fa fa-check"></i><b>29.6</b> 直方图与密度估计</a></li>
<li class="chapter" data-level="29.7" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm"><i class="fa fa-check"></i><b>29.7</b> 绘图语法介绍</a><ul>
<li class="chapter" data-level="29.7.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm-gramm"><i class="fa fa-check"></i><b>29.7.1</b> 绘图语法</a></li>
<li class="chapter" data-level="29.7.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm-geoms"><i class="fa fa-check"></i><b>29.7.2</b> 图形种类</a></li>
</ul></li>
<li class="chapter" data-level="29.8" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom"><i class="fa fa-check"></i><b>29.8</b> 更多图形种类</a><ul>
<li class="chapter" data-level="29.8.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-continuousvar"><i class="fa fa-check"></i><b>29.8.1</b> 连续变量的分组图形</a></li>
<li class="chapter" data-level="29.8.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-text"><i class="fa fa-check"></i><b>29.8.2</b> 坐标系中的文字</a></li>
<li class="chapter" data-level="29.8.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-textops"><i class="fa fa-check"></i><b>29.8.3</b> 文字选项</a></li>
<li class="chapter" data-level="29.8.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-outliers"><i class="fa fa-check"></i><b>29.8.4</b> 标出特殊点</a></li>
</ul></li>
<li class="chapter" data-level="29.9" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-scale"><i class="fa fa-check"></i><b>29.9</b> 刻度(scale)</a></li>
<li class="chapter" data-level="29.10" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-color"><i class="fa fa-check"></i><b>29.10</b> 如何使用颜色</a><ul>
<li class="chapter" data-level="29.10.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-qual"><i class="fa fa-check"></i><b>29.10.1</b> 名义型变量的颜色</a></li>
<li class="chapter" data-level="29.10.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-tile"><i class="fa fa-check"></i><b>29.10.2</b> 色块图</a></li>
<li class="chapter" data-level="29.10.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-seq"><i class="fa fa-check"></i><b>29.10.3</b> 有序型变量的颜色</a></li>
<li class="chapter" data-level="29.10.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-div"><i class="fa fa-check"></i><b>29.10.4</b> 相异型变量的颜色</a></li>
<li class="chapter" data-level="29.10.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-num"><i class="fa fa-check"></i><b>29.10.5</b> 连续数值变量的颜色</a></li>
</ul></li>
<li class="chapter" data-level="29.11" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs"><i class="fa fa-check"></i><b>29.11</b> 标题、标注、指南、拼接</a><ul>
<li class="chapter" data-level="29.11.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-labs"><i class="fa fa-check"></i><b>29.11.1</b> 标题</a></li>
<li class="chapter" data-level="29.11.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-anno"><i class="fa fa-check"></i><b>29.11.2</b> 标注功能</a></li>
<li class="chapter" data-level="29.11.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-guides"><i class="fa fa-check"></i><b>29.11.3</b> 指南(guides)</a></li>
<li class="chapter" data-level="29.11.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-compfig"><i class="fa fa-check"></i><b>29.11.4</b> 拼接图形</a></li>
</ul></li>
<li class="chapter" data-level="29.12" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine"><i class="fa fa-check"></i><b>29.12</b> 图形定制调整</a><ul>
<li class="chapter" data-level="29.12.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-asasec"><i class="fa fa-check"></i><b>29.12.1</b> 图形逐步调整例子</a></li>
</ul></li>
<li class="chapter" data-level="29.13" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-theme"><i class="fa fa-check"></i><b>29.13</b> 主题</a></li>
<li class="chapter" data-level="29.14" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-ref"><i class="fa fa-check"></i><b>29.14</b> 参考文献</a></li>
</ul></li>
<li class="chapter" data-level="30" data-path="ggplotvis.html"><a href="ggplotvis.html"><i class="fa fa-check"></i><b>30</b> ggplot的各种图形</a><ul>
<li class="chapter" data-level="30.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-intro"><i class="fa fa-check"></i><b>30.1</b> 介绍</a></li>
<li class="chapter" data-level="30.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount"><i class="fa fa-check"></i><b>30.2</b> 表现数量</a><ul>
<li class="chapter" data-level="30.2.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-bar"><i class="fa fa-check"></i><b>30.2.1</b> 条形图</a></li>
<li class="chapter" data-level="30.2.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-point"><i class="fa fa-check"></i><b>30.2.2</b> 点图</a></li>
<li class="chapter" data-level="30.2.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-heatmap"><i class="fa fa-check"></i><b>30.2.3</b> 热力图</a></li>
</ul></li>
<li class="chapter" data-level="30.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist"><i class="fa fa-check"></i><b>30.3</b> 表现分布</a><ul>
<li class="chapter" data-level="30.3.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-suni-hist"><i class="fa fa-check"></i><b>30.3.1</b> 单个一元分布的直方图与密度估计图</a></li>
<li class="chapter" data-level="30.3.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-muni"><i class="fa fa-check"></i><b>30.3.2</b> 多个一元分布的直方图和密度图形</a></li>
<li class="chapter" data-level="30.3.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-cdf"><i class="fa fa-check"></i><b>30.3.3</b> 经验分布函数图</a></li>
<li class="chapter" data-level="30.3.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-qqplot"><i class="fa fa-check"></i><b>30.3.4</b> QQ图</a></li>
<li class="chapter" data-level="30.3.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-boxplot"><i class="fa fa-check"></i><b>30.3.5</b> 盒形图</a></li>
<li class="chapter" data-level="30.3.6" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-violin"><i class="fa fa-check"></i><b>30.3.6</b> 小提琴图</a></li>
<li class="chapter" data-level="30.3.7" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-mdens"><i class="fa fa-check"></i><b>30.3.7</b> 多个密度的其它画法</a></li>
<li class="chapter" data-level="30.3.8" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-2d"><i class="fa fa-check"></i><b>30.3.8</b> 二元分布直方图和等值线图</a></li>
</ul></li>
<li class="chapter" data-level="30.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop"><i class="fa fa-check"></i><b>30.4</b> 表现比例</a><ul>
<li class="chapter" data-level="30.4.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-uni"><i class="fa fa-check"></i><b>30.4.1</b> 单个分布</a></li>
<li class="chapter" data-level="30.4.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-mult"><i class="fa fa-check"></i><b>30.4.2</b> 组间的比例分布的比较</a></li>
<li class="chapter" data-level="30.4.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-nest"><i class="fa fa-check"></i><b>30.4.3</b> 嵌套比例分布的比较</a></li>
</ul></li>
<li class="chapter" data-level="30.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar"><i class="fa fa-check"></i><b>30.5</b> 表现多个变量间的关系</a><ul>
<li class="chapter" data-level="30.5.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-scatter"><i class="fa fa-check"></i><b>30.5.1</b> 散点图</a></li>
<li class="chapter" data-level="30.5.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-scatmat"><i class="fa fa-check"></i><b>30.5.2</b> 散点图矩阵</a></li>
<li class="chapter" data-level="30.5.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-corrgram"><i class="fa fa-check"></i><b>30.5.3</b> 相关系数矩阵图</a></li>
<li class="chapter" data-level="30.5.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-dimreduct"><i class="fa fa-check"></i><b>30.5.4</b> 数据降维</a></li>
<li class="chapter" data-level="30.5.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-paird"><i class="fa fa-check"></i><b>30.5.5</b> 成对数据</a></li>
</ul></li>
<li class="chapter" data-level="30.6" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts"><i class="fa fa-check"></i><b>30.6</b> 时间序列图</a><ul>
<li class="chapter" data-level="30.6.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-uni"><i class="fa fa-check"></i><b>30.6.1</b> 一元时间序列</a></li>
<li class="chapter" data-level="30.6.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-mul"><i class="fa fa-check"></i><b>30.6.2</b> 多元时间序列</a></li>
<li class="chapter" data-level="30.6.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-het"><i class="fa fa-check"></i><b>30.6.3</b> 多个不同类型指标的时间序列</a></li>
</ul></li>
<li class="chapter" data-level="30.7" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit"><i class="fa fa-check"></i><b>30.7</b> 拟合曲线图</a><ul>
<li class="chapter" data-level="30.7.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit-smooth"><i class="fa fa-check"></i><b>30.7.1</b> 平滑方法</a></li>
<li class="chapter" data-level="30.7.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit-param"><i class="fa fa-check"></i><b>30.7.2</b> 参数模型方法</a></li>
</ul></li>
<li class="chapter" data-level="30.8" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert"><i class="fa fa-check"></i><b>30.8</b> 表现不确定性</a><ul>
<li class="chapter" data-level="30.8.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-prob"><i class="fa fa-check"></i><b>30.8.1</b> 表现概率</a></li>
<li class="chapter" data-level="30.8.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-se"><i class="fa fa-check"></i><b>30.8.2</b> 表现点估计精度</a></li>
<li class="chapter" data-level="30.8.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-cband"><i class="fa fa-check"></i><b>30.8.3</b> 拟合曲线的置信带</a></li>
<li class="chapter" data-level="30.8.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-dyn"><i class="fa fa-check"></i><b>30.8.4</b> 随机结果动态演示</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>VII 统计模型</b></span></li>
<li class="chapter" data-level="31" data-path="stat-basics.html"><a href="stat-basics.html"><i class="fa fa-check"></i><b>31</b> R初等统计分析</a><ul>
<li class="chapter" data-level="31.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-distr"><i class="fa fa-check"></i><b>31.1</b> 概率分布</a></li>
<li class="chapter" data-level="31.2" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-mle"><i class="fa fa-check"></i><b>31.2</b> 最大似然估计</a><ul>
<li class="chapter" data-level="31.2.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-mle-norm1"><i class="fa fa-check"></i><b>31.2.1</b> 一元正态分布参数最大似然估计</a></li>
</ul></li>
<li class="chapter" data-level="31.3" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest"><i class="fa fa-check"></i><b>31.3</b> 假设检验和置信区间</a><ul>
<li class="chapter" data-level="31.3.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-mu"><i class="fa fa-check"></i><b>31.3.1</b> 均值的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.2" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-prop"><i class="fa fa-check"></i><b>31.3.2</b> 比例的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.3" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-sigma"><i class="fa fa-check"></i><b>31.3.3</b> 方差的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.4" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-gof"><i class="fa fa-check"></i><b>31.3.4</b> 拟合优度检验</a></li>
<li class="chapter" data-level="31.3.5" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-gof-vcd"><i class="fa fa-check"></i><b>31.3.5</b> 检验分布类型</a></li>
<li class="chapter" data-level="31.3.6" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-indepcont"><i class="fa fa-check"></i><b>31.3.6</b> 列联表独立性卡方检验</a></li>
<li class="chapter" data-level="31.3.7" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-npar"><i class="fa fa-check"></i><b>31.3.7</b> 非参数检验</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="32" data-path="stat-reg.html"><a href="stat-reg.html"><i class="fa fa-check"></i><b>32</b> R相关与回归</a><ul>
<li class="chapter" data-level="32.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor"><i class="fa fa-check"></i><b>32.1</b> 相关分析</a><ul>
<li class="chapter" data-level="32.1.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-prop"><i class="fa fa-check"></i><b>32.1.1</b> 相关系数的性质</a></li>
<li class="chapter" data-level="32.1.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-caus"><i class="fa fa-check"></i><b>32.1.2</b> 相关与因果</a></li>
<li class="chapter" data-level="32.1.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-magn"><i class="fa fa-check"></i><b>32.1.3</b> 相关系数大小</a></li>
<li class="chapter" data-level="32.1.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-test"><i class="fa fa-check"></i><b>32.1.4</b> 相关系数的检验</a></li>
<li class="chapter" data-level="32.1.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-vcorr"><i class="fa fa-check"></i><b>32.1.5</b> 相关阵</a></li>
</ul></li>
<li class="chapter" data-level="32.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp"><i class="fa fa-check"></i><b>32.2</b> 一元回归分析</a><ul>
<li class="chapter" data-level="32.2.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-model"><i class="fa fa-check"></i><b>32.2.1</b> 模型</a></li>
<li class="chapter" data-level="32.2.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-ls"><i class="fa fa-check"></i><b>32.2.2</b> 最小二乘法</a></li>
<li class="chapter" data-level="32.2.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-test"><i class="fa fa-check"></i><b>32.2.3</b> 回归有效性</a></li>
<li class="chapter" data-level="32.2.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-prog"><i class="fa fa-check"></i><b>32.2.4</b> R程序</a></li>
<li class="chapter" data-level="32.2.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-diag"><i class="fa fa-check"></i><b>32.2.5</b> 回归诊断</a></li>
<li class="chapter" data-level="32.2.6" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-ci"><i class="fa fa-check"></i><b>32.2.6</b> 预测区间</a></li>
<li class="chapter" data-level="32.2.7" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-control"><i class="fa fa-check"></i><b>32.2.7</b> 控制</a></li>
</ul></li>
<li class="chapter" data-level="32.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu"><i class="fa fa-check"></i><b>32.3</b> 多元线性回归</a><ul>
<li class="chapter" data-level="32.3.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-mod"><i class="fa fa-check"></i><b>32.3.1</b> 模型</a></li>
<li class="chapter" data-level="32.3.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-est"><i class="fa fa-check"></i><b>32.3.2</b> 参数估计</a></li>
<li class="chapter" data-level="32.3.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-rcode"><i class="fa fa-check"></i><b>32.3.3</b> R的多元回归程序</a></li>
<li class="chapter" data-level="32.3.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-test"><i class="fa fa-check"></i><b>32.3.4</b> 模型的检验</a></li>
<li class="chapter" data-level="32.3.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-subset"><i class="fa fa-check"></i><b>32.3.5</b> 回归自变量筛选</a></li>
<li class="chapter" data-level="32.3.6" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-dum"><i class="fa fa-check"></i><b>32.3.6</b> 哑变量与变截距项的模型</a></li>
<li class="chapter" data-level="32.3.7" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-resid"><i class="fa fa-check"></i><b>32.3.7</b> 残差诊断</a></li>
<li class="chapter" data-level="32.3.8" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-colin"><i class="fa fa-check"></i><b>32.3.8</b> 多重共线性</a></li>
<li class="chapter" data-level="32.3.9" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-lev"><i class="fa fa-check"></i><b>32.3.9</b> 强影响点分析</a></li>
<li class="chapter" data-level="32.3.10" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-overfit"><i class="fa fa-check"></i><b>32.3.10</b> 过度拟合示例</a></li>
<li class="chapter" data-level="32.3.11" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-comp-inset"><i class="fa fa-check"></i><b>32.3.11</b> 嵌套模型的比较</a></li>
<li class="chapter" data-level="32.3.12" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-pred"><i class="fa fa-check"></i><b>32.3.12</b> 拟合与预测</a></li>
<li class="chapter" data-level="32.3.13" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-curve"><i class="fa fa-check"></i><b>32.3.13</b> 利用线性回归模型做曲线拟合</a></li>
<li class="chapter" data-level="32.3.14" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-group"><i class="fa fa-check"></i><b>32.3.14</b> 分组建立多个模型</a></li>
</ul></li>
<li class="chapter" data-level="32.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-npar"><i class="fa fa-check"></i><b>32.4</b> 非参数回归</a><ul>
<li class="chapter" data-level="32.4.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-npar-mod"><i class="fa fa-check"></i><b>32.4.1</b> 模型</a></li>
<li class="chapter" data-level="32.4.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-spl1d"><i class="fa fa-check"></i><b>32.4.2</b> 样条平滑</a></li>
<li class="chapter" data-level="32.4.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-loess"><i class="fa fa-check"></i><b>32.4.3</b> 局部多项式曲线平滑</a></li>
<li class="chapter" data-level="32.4.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-bs"><i class="fa fa-check"></i><b>32.4.4</b> 样条函数变换</a></li>
<li class="chapter" data-level="32.4.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-gam"><i class="fa fa-check"></i><b>32.4.5</b> 线性可加模型</a></li>
</ul></li>
<li class="chapter" data-level="32.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog"><i class="fa fa-check"></i><b>32.5</b> Logistic回归</a><ul>
<li class="chapter" data-level="32.5.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog-mod"><i class="fa fa-check"></i><b>32.5.1</b> 模型</a></li>
<li class="chapter" data-level="32.5.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog-rcode"><i class="fa fa-check"></i><b>32.5.2</b> R程序</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="33" data-path="stat-tsa.html"><a href="stat-tsa.html"><i class="fa fa-check"></i><b>33</b> R时间序列分析</a><ul>
<li class="chapter" data-level="33.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-defs"><i class="fa fa-check"></i><b>33.1</b> 基本概念</a></li>
<li class="chapter" data-level="33.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype"><i class="fa fa-check"></i><b>33.2</b> 时间序列数据类型</a><ul>
<li class="chapter" data-level="33.2.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype-ts"><i class="fa fa-check"></i><b>33.2.1</b> ts类型</a></li>
<li class="chapter" data-level="33.2.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype-xts"><i class="fa fa-check"></i><b>33.2.2</b> xts类型与常用函数</a></li>
</ul></li>
<li class="chapter" data-level="33.3" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-basicstat"><i class="fa fa-check"></i><b>33.3</b> 基本分析与作图</a></li>
<li class="chapter" data-level="33.4" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima"><i class="fa fa-check"></i><b>33.4</b> ARIMA建模和模拟</a><ul>
<li class="chapter" data-level="33.4.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-def"><i class="fa fa-check"></i><b>33.4.1</b> 模型公式</a></li>
<li class="chapter" data-level="33.4.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-sim"><i class="fa fa-check"></i><b>33.4.2</b> 模拟</a></li>
<li class="chapter" data-level="33.4.3" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-armod"><i class="fa fa-check"></i><b>33.4.3</b> AR建模</a></li>
<li class="chapter" data-level="33.4.4" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-armamod"><i class="fa fa-check"></i><b>33.4.4</b> ARMA建模</a></li>
<li class="chapter" data-level="33.4.5" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-diag"><i class="fa fa-check"></i><b>33.4.5</b> 模型诊断</a></li>
<li class="chapter" data-level="33.4.6" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-lbtest"><i class="fa fa-check"></i><b>33.4.6</b> 白噪声检验</a></li>
<li class="chapter" data-level="33.4.7" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-sparse"><i class="fa fa-check"></i><b>33.4.7</b> 稀疏系数估计</a></li>
<li class="chapter" data-level="33.4.8" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-adftest"><i class="fa fa-check"></i><b>33.4.8</b> 单位根检验</a></li>
<li class="chapter" data-level="33.4.9" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-cfuncs"><i class="fa fa-check"></i><b>33.4.9</b> ARMA模型的一些自定义函数</a></li>
</ul></li>
<li class="chapter" data-level="33.5" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-spectra"><i class="fa fa-check"></i><b>33.5</b> 谱密度估计</a></li>
<li class="chapter" data-level="33.6" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-garch"><i class="fa fa-check"></i><b>33.6</b> GARCH类模型</a></li>
<li class="chapter" data-level="33.7" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-mtsa"><i class="fa fa-check"></i><b>33.7</b> 多元时间序列基础统计</a></li>
<li class="chapter" data-level="33.8" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-var"><i class="fa fa-check"></i><b>33.8</b> VAR模型</a></li>
<li class="chapter" data-level="33.9" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-coint"><i class="fa fa-check"></i><b>33.9</b> 协整分析</a></li>
<li class="chapter" data-level="33.10" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-causal"><i class="fa fa-check"></i><b>33.10</b> 因果性检验</a></li>
</ul></li>
<li class="chapter" data-level="34" data-path="stat-learning.html"><a href="stat-learning.html"><i class="fa fa-check"></i><b>34</b> 统计学习介绍</a><ul>
<li class="chapter" data-level="34.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro"><i class="fa fa-check"></i><b>34.1</b> 统计学习的基本概念和一般步骤</a><ul>
<li class="chapter" data-level="34.1.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro-basic"><i class="fa fa-check"></i><b>34.1.1</b> 统计学习的基本概念和方法</a></li>
<li class="chapter" data-level="34.1.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro-biasvar"><i class="fa fa-check"></i><b>34.1.2</b> 偏差与方差折衷</a></li>
<li class="chapter" data-level="34.1.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-cv"><i class="fa fa-check"></i><b>34.1.3</b> 交叉验证</a></li>
<li class="chapter" data-level="34.1.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-steps"><i class="fa fa-check"></i><b>34.1.4</b> 一般步骤</a></li>
</ul></li>
<li class="chapter" data-level="34.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters"><i class="fa fa-check"></i><b>34.2</b> Hitters数据分析</a><ul>
<li class="chapter" data-level="34.2.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-subset"><i class="fa fa-check"></i><b>34.2.1</b> 回归自变量选择</a></li>
<li class="chapter" data-level="34.2.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-ridge"><i class="fa fa-check"></i><b>34.2.2</b> 岭回归</a></li>
<li class="chapter" data-level="34.2.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-lasso"><i class="fa fa-check"></i><b>34.2.3</b> Lasso回归</a></li>
<li class="chapter" data-level="34.2.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-simpt"><i class="fa fa-check"></i><b>34.2.4</b> 树回归的简单演示</a></li>
<li class="chapter" data-level="34.2.5" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-tree"><i class="fa fa-check"></i><b>34.2.5</b> 树回归</a></li>
<li class="chapter" data-level="34.2.6" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-bag"><i class="fa fa-check"></i><b>34.2.6</b> 装袋法</a></li>
<li class="chapter" data-level="34.2.7" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-rf"><i class="fa fa-check"></i><b>34.2.7</b> 随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart"><i class="fa fa-check"></i><b>34.3</b> Heart数据分析</a><ul>
<li class="chapter" data-level="34.3.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-tree"><i class="fa fa-check"></i><b>34.3.1</b> 树回归</a></li>
<li class="chapter" data-level="34.3.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-bag"><i class="fa fa-check"></i><b>34.3.2</b> 用装袋法</a></li>
<li class="chapter" data-level="34.3.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-rf"><i class="fa fa-check"></i><b>34.3.3</b> 用随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-car"><i class="fa fa-check"></i><b>34.4</b> 汽车销量数据分析</a><ul>
<li class="chapter" data-level="34.4.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-car-tree"><i class="fa fa-check"></i><b>34.4.1</b> 判别树</a></li>
<li class="chapter" data-level="34.4.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-car-rf"><i class="fa fa-check"></i><b>34.4.2</b> 随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.5" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston"><i class="fa fa-check"></i><b>34.5</b> 波士顿郊区房价数据</a><ul>
<li class="chapter" data-level="34.5.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-tree"><i class="fa fa-check"></i><b>34.5.1</b> 回归树</a></li>
<li class="chapter" data-level="34.5.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-bag"><i class="fa fa-check"></i><b>34.5.2</b> 装袋法</a></li>
<li class="chapter" data-level="34.5.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-rf"><i class="fa fa-check"></i><b>34.5.3</b> 随机森林</a></li>
<li class="chapter" data-level="34.5.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-boost"><i class="fa fa-check"></i><b>34.5.4</b> 提升法</a></li>
</ul></li>
<li class="chapter" data-level="34.6" data-path="stat-learning.html"><a href="stat-learning.html#statl-svm"><i class="fa fa-check"></i><b>34.6</b> 支持向量机方法</a><ul>
<li class="chapter" data-level="34.6.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-svm-heart"><i class="fa fa-check"></i><b>34.6.1</b> 支持向量机用于Heart数据</a></li>
</ul></li>
<li class="chapter" data-level="34.7" data-path="stat-learning.html"><a href="stat-learning.html#statl-app"><i class="fa fa-check"></i><b>34.7</b> 附录</a><ul>
<li class="chapter" data-level="34.7.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-hitters"><i class="fa fa-check"></i><b>34.7.1</b> Hitters数据</a></li>
<li class="chapter" data-level="34.7.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-heart"><i class="fa fa-check"></i><b>34.7.2</b> Heart数据</a></li>
<li class="chapter" data-level="34.7.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-car"><i class="fa fa-check"></i><b>34.7.3</b> CarSeats数据</a></li>
<li class="chapter" data-level="34.7.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-boston"><i class="fa fa-check"></i><b>34.7.4</b> Boston数据</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="35" data-path="simulation.html"><a href="simulation.html"><i class="fa fa-check"></i><b>35</b> 随机模拟</a><ul>
<li class="chapter" data-level="35.1" data-path="simulation.html"><a href="simulation.html#simint"><i class="fa fa-check"></i><b>35.1</b> 随机数</a></li>
<li class="chapter" data-level="35.2" data-path="simulation.html"><a href="simulation.html#simsamp"><i class="fa fa-check"></i><b>35.2</b> <code>sample()</code>函数</a></li>
<li class="chapter" data-level="35.3" data-path="simulation.html"><a href="simulation.html#simexamp"><i class="fa fa-check"></i><b>35.3</b> 随机模拟示例</a><ul>
<li class="chapter" data-level="35.3.1" data-path="simulation.html"><a href="simulation.html#simexamp-expect"><i class="fa fa-check"></i><b>35.3.1</b> 估计期望值</a></li>
<li class="chapter" data-level="35.3.2" data-path="simulation.html"><a href="simulation.html#simexamp-lm"><i class="fa fa-check"></i><b>35.3.2</b> 线性回归模拟</a></li>
<li class="chapter" data-level="35.3.3" data-path="simulation.html"><a href="simulation.html#simexamp-kde"><i class="fa fa-check"></i><b>35.3.3</b> 核密度的bootstrap置信区间</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>VIII 特殊应用</b></span></li>
<li class="chapter" data-level="36" data-path="text.html"><a href="text.html"><i class="fa fa-check"></i><b>36</b> R语言的文本处理</a><ul>
<li class="chapter" data-level="36.1" data-path="text.html"><a href="text.html#text-simple"><i class="fa fa-check"></i><b>36.1</b> 简单的文本处理</a><ul>
<li class="chapter" data-level="36.1.1" data-path="text.html"><a href="text.html#text-simple-const"><i class="fa fa-check"></i><b>36.1.1</b> 字符型常量与字符型向量</a></li>
<li class="chapter" data-level="36.1.2" data-path="text.html"><a href="text.html#text-paste"><i class="fa fa-check"></i><b>36.1.2</b> 字符串连接、重复</a></li>
<li class="chapter" data-level="36.1.3" data-path="text.html"><a href="text.html#text-formatout"><i class="fa fa-check"></i><b>36.1.3</b> 格式化输出</a></li>
<li class="chapter" data-level="36.1.4" data-path="text.html"><a href="text.html#text-length"><i class="fa fa-check"></i><b>36.1.4</b> 字符串长度</a></li>
<li class="chapter" data-level="36.1.5" data-path="text.html"><a href="text.html#text-substring"><i class="fa fa-check"></i><b>36.1.5</b> 取子串</a></li>
<li class="chapter" data-level="36.1.6" data-path="text.html"><a href="text.html#text-convert"><i class="fa fa-check"></i><b>36.1.6</b> 字符串变换</a></li>
<li class="chapter" data-level="36.1.7" data-path="text.html"><a href="text.html#text-simp-find"><i class="fa fa-check"></i><b>36.1.7</b> 简单匹配与查找</a></li>
<li class="chapter" data-level="36.1.8" data-path="text.html"><a href="text.html#text-simple-gsub"><i class="fa fa-check"></i><b>36.1.8</b> 字符串替换</a></li>
<li class="chapter" data-level="36.1.9" data-path="text.html"><a href="text.html#text-simple-strsplit"><i class="fa fa-check"></i><b>36.1.9</b> 字符串拆分</a></li>
</ul></li>
<li class="chapter" data-level="36.2" data-path="text.html"><a href="text.html#text-file"><i class="fa fa-check"></i><b>36.2</b> 文本文件读写</a></li>
<li class="chapter" data-level="36.3" data-path="text.html"><a href="text.html#text-regex"><i class="fa fa-check"></i><b>36.3</b> 正则表达式</a><ul>
<li class="chapter" data-level="36.3.1" data-path="text.html"><a href="text.html#text-regex-strview"><i class="fa fa-check"></i><b>36.3.1</b> 字面匹配与匹配显示</a></li>
<li class="chapter" data-level="36.3.2" data-path="text.html"><a href="text.html#text-regex-ignore"><i class="fa fa-check"></i><b>36.3.2</b> 不区分大小写匹配和<code>regex</code>函数</a></li>
<li class="chapter" data-level="36.3.3" data-path="text.html"><a href="text.html#text-regex-dot"><i class="fa fa-check"></i><b>36.3.3</b> 用句点匹配单个字符</a></li>
<li class="chapter" data-level="36.3.4" data-path="text.html"><a href="text.html#text-regex-set"><i class="fa fa-check"></i><b>36.3.4</b> 匹配一组字符中的某一个</a></li>
<li class="chapter" data-level="36.3.5" data-path="text.html"><a href="text.html#text-regex-metalit"><i class="fa fa-check"></i><b>36.3.5</b> 原样匹配元字符</a></li>
<li class="chapter" data-level="36.3.6" data-path="text.html"><a href="text.html#text-regex-space"><i class="fa fa-check"></i><b>36.3.6</b> 匹配空白</a></li>
<li class="chapter" data-level="36.3.7" data-path="text.html"><a href="text.html#text-regex-digit"><i class="fa fa-check"></i><b>36.3.7</b> 匹配数字</a></li>
<li class="chapter" data-level="36.3.8" data-path="text.html"><a href="text.html#text-regex-alnum"><i class="fa fa-check"></i><b>36.3.8</b> 匹配字母、数字、下划线</a></li>
<li class="chapter" data-level="36.3.9" data-path="text.html"><a href="text.html#text-regex-hex"><i class="fa fa-check"></i><b>36.3.9</b> 十六进制和八进制数</a></li>
<li class="chapter" data-level="36.3.10" data-path="text.html"><a href="text.html#text-regex-posix"><i class="fa fa-check"></i><b>36.3.10</b> POSIX字符类</a></li>
<li class="chapter" data-level="36.3.11" data-path="text.html"><a href="text.html#text-regex-start"><i class="fa fa-check"></i><b>36.3.11</b> 匹配开头和末尾</a></li>
<li class="chapter" data-level="36.3.12" data-path="text.html"><a href="text.html#text-regex-wordb"><i class="fa fa-check"></i><b>36.3.12</b> 单词边界</a></li>
<li class="chapter" data-level="36.3.13" data-path="text.html"><a href="text.html#text-regex-repeat"><i class="fa fa-check"></i><b>36.3.13</b> 重复匹配</a></li>
<li class="chapter" data-level="36.3.14" data-path="text.html"><a href="text.html#text-regex-lazy"><i class="fa fa-check"></i><b>36.3.14</b> 贪婪匹配和懒惰匹配</a></li>
<li class="chapter" data-level="36.3.15" data-path="text.html"><a href="text.html#text-regex-smlines"><i class="fa fa-check"></i><b>36.3.15</b> 句点全匹配与多行模式</a></li>
<li class="chapter" data-level="36.3.16" data-path="text.html"><a href="text.html#text-regex-alt"><i class="fa fa-check"></i><b>36.3.16</b> 备择模式</a></li>
<li class="chapter" data-level="36.3.17" data-path="text.html"><a href="text.html#text-regex-group"><i class="fa fa-check"></i><b>36.3.17</b> 分组与捕获</a></li>
</ul></li>
<li class="chapter" data-level="36.4" data-path="text.html"><a href="text.html#text-stringr-funcs"><i class="fa fa-check"></i><b>36.4</b> stringr包的正则表达式函数</a><ul>
<li class="chapter" data-level="36.4.1" data-path="text.html"><a href="text.html#text-stringr-funcs-strview"><i class="fa fa-check"></i><b>36.4.1</b> <code>str_view()</code>函数</a></li>
<li class="chapter" data-level="36.4.2" data-path="text.html"><a href="text.html#text-stringr-funcs-regex"><i class="fa fa-check"></i><b>36.4.2</b> <code>regex()</code>函数</a></li>
<li class="chapter" data-level="36.4.3" data-path="text.html"><a href="text.html#text-stringr-funcs-detect"><i class="fa fa-check"></i><b>36.4.3</b> 检查那些元素能够匹配</a></li>
<li class="chapter" data-level="36.4.4" data-path="text.html"><a href="text.html#text-stringr-funcs-replace"><i class="fa fa-check"></i><b>36.4.4</b> 替换</a></li>
<li class="chapter" data-level="36.4.5" data-path="text.html"><a href="text.html#text-stringr-funcs-subset"><i class="fa fa-check"></i><b>36.4.5</b> 返回匹配的元素</a></li>
<li class="chapter" data-level="36.4.6" data-path="text.html"><a href="text.html#text-stringr-funcs-extract"><i class="fa fa-check"></i><b>36.4.6</b> 提取匹配内容</a></li>
<li class="chapter" data-level="36.4.7" data-path="text.html"><a href="text.html#text-stringr-funcs-match"><i class="fa fa-check"></i><b>36.4.7</b> 提取分组捕获内容</a></li>
<li class="chapter" data-level="36.4.8" data-path="text.html"><a href="text.html#text-stringr-funcs-locate"><i class="fa fa-check"></i><b>36.4.8</b> 定位匹配位置</a></li>
</ul></li>
<li class="chapter" data-level="36.5" data-path="text.html"><a href="text.html#text-regex-bfuncs"><i class="fa fa-check"></i><b>36.5</b> 利用基本R函数进行正则表达式处理</a><ul>
<li class="chapter" data-level="36.5.1" data-path="text.html"><a href="text.html#text-regex-bfuncs-igcase"><i class="fa fa-check"></i><b>36.5.1</b> 不区分大小写匹配</a></li>
<li class="chapter" data-level="36.5.2" data-path="text.html"><a href="text.html#text-regex-bfuncs-dotp"><i class="fa fa-check"></i><b>36.5.2</b> 匹配单个字符</a></li>
<li class="chapter" data-level="36.5.3" data-path="text.html"><a href="text.html#text-regex-bfuncs-setp"><i class="fa fa-check"></i><b>36.5.3</b> 匹配一组字符中的某一个</a></li>
<li class="chapter" data-level="36.5.4" data-path="text.html"><a href="text.html#text-regex-bfuncs-metalit"><i class="fa fa-check"></i><b>36.5.4</b> 原样匹配元字符</a></li>
<li class="chapter" data-level="36.5.5" data-path="text.html"><a href="text.html#text-regex-bfuncs-digit"><i class="fa fa-check"></i><b>36.5.5</b> 匹配数字</a></li>
<li class="chapter" data-level="36.5.6" data-path="text.html"><a href="text.html#text-regex-bfuncs-start"><i class="fa fa-check"></i><b>36.5.6</b> 匹配开头和末尾</a></li>
<li class="chapter" data-level="36.5.7" data-path="text.html"><a href="text.html#text-regex-bfuncs-alnum"><i class="fa fa-check"></i><b>36.5.7</b> 匹配字母、数字、下划线</a></li>
<li class="chapter" data-level="36.5.8" data-path="text.html"><a href="text.html#text-regex-bfuncs-hex"><i class="fa fa-check"></i><b>36.5.8</b> 十六进制和八进制数</a></li>
<li class="chapter" data-level="36.5.9" data-path="text.html"><a href="text.html#text-regex-bfuncs-posix"><i class="fa fa-check"></i><b>36.5.9</b> POSIX字符类</a></li>
<li class="chapter" data-level="36.5.10" data-path="text.html"><a href="text.html#text-regex-bfuncs-plus"><i class="fa fa-check"></i><b>36.5.10</b> 加号重复匹配</a></li>
<li class="chapter" data-level="36.5.11" data-path="text.html"><a href="text.html#text-regex-bfuncs-ast"><i class="fa fa-check"></i><b>36.5.11</b> 星号和问号重复匹配</a></li>
<li class="chapter" data-level="36.5.12" data-path="text.html"><a href="text.html#text-regex-bfuncs-repnum"><i class="fa fa-check"></i><b>36.5.12</b> 计数重复</a></li>
<li class="chapter" data-level="36.5.13" data-path="text.html"><a href="text.html#text-regex-bfuncs-lazy"><i class="fa fa-check"></i><b>36.5.13</b> 贪婪匹配和懒惰匹配</a></li>
<li class="chapter" data-level="36.5.14" data-path="text.html"><a href="text.html#text-regex-bfuncs-wordb"><i class="fa fa-check"></i><b>36.5.14</b> 单词边界</a></li>
<li class="chapter" data-level="36.5.15" data-path="text.html"><a href="text.html#text-regex-bfuncs-sm"><i class="fa fa-check"></i><b>36.5.15</b> 句点全匹配与多行模式</a></li>
<li class="chapter" data-level="36.5.16" data-path="text.html"><a href="text.html#text-regex-bfuncs-alt"><i class="fa fa-check"></i><b>36.5.16</b> 备择模式</a></li>
<li class="chapter" data-level="36.5.17" data-path="text.html"><a href="text.html#text-regex-bfuncs-group"><i class="fa fa-check"></i><b>36.5.17</b> 分组与捕获</a></li>
</ul></li>
<li class="chapter" data-level="36.6" data-path="text.html"><a href="text.html#text-regexex"><i class="fa fa-check"></i><b>36.6</b> 正则表达式应用例子</a><ul>
<li class="chapter" data-level="36.6.1" data-path="text.html"><a href="text.html#text-regexex-pre"><i class="fa fa-check"></i><b>36.6.1</b> 数据预处理</a></li>
<li class="chapter" data-level="36.6.2" data-path="text.html"><a href="text.html#text-regexex-excelmore"><i class="fa fa-check"></i><b>36.6.2</b> 不规则Excel文件处理</a></li>
<li class="chapter" data-level="36.6.3" data-path="text.html"><a href="text.html#text-regexex-wordfreq"><i class="fa fa-check"></i><b>36.6.3</b> 字频统计</a></li>
<li class="chapter" data-level="36.6.4" data-path="text.html"><a href="text.html#text-regexex-digits"><i class="fa fa-check"></i><b>36.6.4</b> 数字验证</a></li>
<li class="chapter" data-level="36.6.5" data-path="text.html"><a href="text.html#text-regexex-digfn"><i class="fa fa-check"></i><b>36.6.5</b> 文件名中的数字提取</a></li>
</ul></li>
<li class="chapter" data-level="36.7" data-path="text.html"><a href="text.html#text-webscape"><i class="fa fa-check"></i><b>36.7</b> 网站数据获取</a></li>
<li class="chapter" data-level="36.8" data-path="text.html"><a href="text.html#text-jiebaR"><i class="fa fa-check"></i><b>36.8</b> 中文分词与词频</a></li>
</ul></li>
<li class="part"><span><b>IX 用Rcpp访问C++代码</b></span></li>
<li class="chapter" data-level="37" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>37</b> Rcpp介绍</a><ul>
<li class="chapter" data-level="37.1" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-use"><i class="fa fa-check"></i><b>37.1</b> Rcpp的用途</a></li>
<li class="chapter" data-level="37.2" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp"><i class="fa fa-check"></i><b>37.2</b> Rcpp入门样例</a><ul>
<li class="chapter" data-level="37.2.1" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex1"><i class="fa fa-check"></i><b>37.2.1</b> 用<code>cppFunction()</code>转换简单的C++函数—Fibnacci例子</a></li>
<li class="chapter" data-level="37.2.2" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex2"><i class="fa fa-check"></i><b>37.2.2</b> 用<code>sourceCpp()</code>转换C++程序—正负交替迭代例子</a></li>
<li class="chapter" data-level="37.2.3" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex3"><i class="fa fa-check"></i><b>37.2.3</b> 用<code>sourceCpp()</code>转换C++源文件中的程序—正负交替迭代例子</a></li>
<li class="chapter" data-level="37.2.4" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex4"><i class="fa fa-check"></i><b>37.2.4</b> 用<code>sourceCpp()</code>转换C++源程序文件—卷积例子</a></li>
<li class="chapter" data-level="37.2.5" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-rmdconv"><i class="fa fa-check"></i><b>37.2.5</b> 在Rmd文件中使用C++源程序文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="38" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html"><i class="fa fa-check"></i><b>38</b> R与C++的类型转换</a><ul>
<li class="chapter" data-level="38.1" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-wrap"><i class="fa fa-check"></i><b>38.1</b> 用<code>wrap()</code>把C++变量返回到R中</a></li>
<li class="chapter" data-level="38.2" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-as"><i class="fa fa-check"></i><b>38.2</b> 用<code>as()</code>函数把R变量转换为C++类型</a></li>
<li class="chapter" data-level="38.3" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-implicit"><i class="fa fa-check"></i><b>38.3</b> <code>as()</code>和<code>wrap()</code>的隐含调用</a></li>
</ul></li>
<li class="chapter" data-level="39" data-path="rcpp-attr.html"><a href="rcpp-attr.html"><i class="fa fa-check"></i><b>39</b> Rcpp 属性</a><ul>
<li class="chapter" data-level="39.1" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-intro"><i class="fa fa-check"></i><b>39.1</b> Rcpp属性介绍</a></li>
<li class="chapter" data-level="39.2" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-export"><i class="fa fa-check"></i><b>39.2</b> 在C++源程序中指定要导出的C++函数</a></li>
<li class="chapter" data-level="39.3" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-sourcecpp"><i class="fa fa-check"></i><b>39.3</b> 在R中编译链接C++代码</a></li>
<li class="chapter" data-level="39.4" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc"><i class="fa fa-check"></i><b>39.4</b> Rcpp属性的其它功能</a><ul>
<li class="chapter" data-level="39.4.1" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-default"><i class="fa fa-check"></i><b>39.4.1</b> 自变量有缺省值的函数</a></li>
<li class="chapter" data-level="39.4.2" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-interrupt"><i class="fa fa-check"></i><b>39.4.2</b> 允许用户中断</a></li>
<li class="chapter" data-level="39.4.3" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-rinclude"><i class="fa fa-check"></i><b>39.4.3</b> 把R代码写在C++源文件中</a></li>
<li class="chapter" data-level="39.4.4" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-rand"><i class="fa fa-check"></i><b>39.4.4</b> 在C++中调用R的随机数发生器</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="40" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html"><i class="fa fa-check"></i><b>40</b> Rcpp提供的C++数据类型</a><ul>
<li class="chapter" data-level="40.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-robject"><i class="fa fa-check"></i><b>40.1</b> RObject类</a></li>
<li class="chapter" data-level="40.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec"><i class="fa fa-check"></i><b>40.2</b> IntegerVector类</a><ul>
<li class="chapter" data-level="40.2.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec-ex1"><i class="fa fa-check"></i><b>40.2.1</b> IntegerVector示例1：返回完全数</a></li>
<li class="chapter" data-level="40.2.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec-ex2"><i class="fa fa-check"></i><b>40.2.2</b> IntegerVector示例2：输入整数向量</a></li>
</ul></li>
<li class="chapter" data-level="40.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num"><i class="fa fa-check"></i><b>40.3</b> NumericVector类</a><ul>
<li class="chapter" data-level="40.3.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex1"><i class="fa fa-check"></i><b>40.3.1</b> 示例1：计算元素<span class="math inline">\(p\)</span>次方的和</a></li>
<li class="chapter" data-level="40.3.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex2"><i class="fa fa-check"></i><b>40.3.2</b> 示例2：<code>clone</code>函数</a></li>
<li class="chapter" data-level="40.3.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex3"><i class="fa fa-check"></i><b>40.3.3</b> 示例3：向量子集</a></li>
</ul></li>
<li class="chapter" data-level="40.4" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat"><i class="fa fa-check"></i><b>40.4</b> NumericMatrix类</a><ul>
<li class="chapter" data-level="40.4.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex1"><i class="fa fa-check"></i><b>40.4.1</b> 示例1：计算矩阵各列模的最大值</a></li>
<li class="chapter" data-level="40.4.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex2"><i class="fa fa-check"></i><b>40.4.2</b> 示例2：把输入矩阵制作副本计算元素平方根</a></li>
<li class="chapter" data-level="40.4.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex3"><i class="fa fa-check"></i><b>40.4.3</b> 示例3：访问列子集</a></li>
</ul></li>
<li class="chapter" data-level="40.5" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-other"><i class="fa fa-check"></i><b>40.5</b> Rcpp的其它向量类</a><ul>
<li class="chapter" data-level="40.5.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-logic"><i class="fa fa-check"></i><b>40.5.1</b> Rcpp的LogicalVector类</a></li>
<li class="chapter" data-level="40.5.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-char"><i class="fa fa-check"></i><b>40.5.2</b> Rcpp的CharacterVector类型</a></li>
</ul></li>
<li class="chapter" data-level="40.6" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types"><i class="fa fa-check"></i><b>40.6</b> Rcpp提供的其它数据类型</a><ul>
<li class="chapter" data-level="40.6.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-named"><i class="fa fa-check"></i><b>40.6.1</b> Named类型</a></li>
<li class="chapter" data-level="40.6.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-list"><i class="fa fa-check"></i><b>40.6.2</b> List类型</a></li>
<li class="chapter" data-level="40.6.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-df"><i class="fa fa-check"></i><b>40.6.3</b> Rcpp的DataFrame类</a></li>
<li class="chapter" data-level="40.6.4" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-func"><i class="fa fa-check"></i><b>40.6.4</b> Rcpp的Function类</a></li>
<li class="chapter" data-level="40.6.5" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-environ"><i class="fa fa-check"></i><b>40.6.5</b> Rcpp的Environment类</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="41" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html"><i class="fa fa-check"></i><b>41</b> Rcpp糖</a><ul>
<li class="chapter" data-level="41.1" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-examp"><i class="fa fa-check"></i><b>41.1</b> 简单示例</a></li>
<li class="chapter" data-level="41.2" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop"><i class="fa fa-check"></i><b>41.2</b> 向量化的运算符</a><ul>
<li class="chapter" data-level="41.2.1" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-arith"><i class="fa fa-check"></i><b>41.2.1</b> 向量化的四则运算</a></li>
<li class="chapter" data-level="41.2.2" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-binop"><i class="fa fa-check"></i><b>41.2.2</b> 向量化的二元逻辑运算</a></li>
<li class="chapter" data-level="41.2.3" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-uop"><i class="fa fa-check"></i><b>41.2.3</b> 向量化的一元运算符</a></li>
</ul></li>
<li class="chapter" data-level="41.3" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-mathfunc"><i class="fa fa-check"></i><b>41.3</b> 用Rcpp访问数学函数</a></li>
<li class="chapter" data-level="41.4" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-any"><i class="fa fa-check"></i><b>41.4</b> 返回单一逻辑值的函数</a></li>
<li class="chapter" data-level="41.5" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-expfunc"><i class="fa fa-check"></i><b>41.5</b> 返回糖表达式的函数</a></li>
<li class="chapter" data-level="41.6" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-diff"><i class="fa fa-check"></i><b>41.6</b> R与Rcpp不同语法示例</a></li>
</ul></li>
<li class="chapter" data-level="42" data-path="rcpp-package.html"><a href="rcpp-package.html"><i class="fa fa-check"></i><b>42</b> 用Rcpp帮助制作R扩展包</a><ul>
<li class="chapter" data-level="42.1" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-wo"><i class="fa fa-check"></i><b>42.1</b> 不用扩展包共享C++代码的方法</a></li>
<li class="chapter" data-level="42.2" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen"><i class="fa fa-check"></i><b>42.2</b> 生成扩展包</a><ul>
<li class="chapter" data-level="42.2.1" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-exist"><i class="fa fa-check"></i><b>42.2.1</b> 利用已有基于Rcpp属性的源程序制作扩展包</a></li>
<li class="chapter" data-level="42.2.2" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-desc"><i class="fa fa-check"></i><b>42.2.2</b> DESCRIPTION文件</a></li>
<li class="chapter" data-level="42.2.3" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-namespace"><i class="fa fa-check"></i><b>42.2.3</b> NAMESPACE文件</a></li>
</ul></li>
<li class="chapter" data-level="42.3" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-recomp"><i class="fa fa-check"></i><b>42.3</b> 重新编译</a></li>
<li class="chapter" data-level="42.4" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-interface"><i class="fa fa-check"></i><b>42.4</b> 建立C++用的接口界面</a></li>
</ul></li>
<li class="part"><span><b>X 编程例子</b></span></li>
<li class="chapter" data-level="43" data-path="examples.html"><a href="examples.html"><i class="fa fa-check"></i><b>43</b> R编程例子</a><ul>
<li class="chapter" data-level="43.1" data-path="examples.html"><a href="examples.html#examples-rlang"><i class="fa fa-check"></i><b>43.1</b> R语言</a><ul>
<li class="chapter" data-level="43.1.1" data-path="examples.html"><a href="examples.html#examples-rlang-inverse"><i class="fa fa-check"></i><b>43.1.1</b> 用向量作逆变换</a></li>
<li class="chapter" data-level="43.1.2" data-path="examples.html"><a href="examples.html#examples-rlang-fibonacci"><i class="fa fa-check"></i><b>43.1.2</b> 斐波那契数列计算</a></li>
<li class="chapter" data-level="43.1.3" data-path="examples.html"><a href="examples.html#examples-rlang-permutation"><i class="fa fa-check"></i><b>43.1.3</b> 穷举所有排列</a></li>
<li class="chapter" data-level="43.1.4" data-path="examples.html"><a href="examples.html#examples-rlang-repgroup"><i class="fa fa-check"></i><b>43.1.4</b> 可重复分组方式穷举</a></li>
<li class="chapter" data-level="43.1.5" data-path="examples.html"><a href="examples.html#examples-rlang-runs"><i class="fa fa-check"></i><b>43.1.5</b> 升降连计数</a></li>
</ul></li>
<li class="chapter" data-level="43.2" data-path="examples.html"><a href="examples.html#examples-prob"><i class="fa fa-check"></i><b>43.2</b> 概率</a><ul>
<li class="chapter" data-level="43.2.1" data-path="examples.html"><a href="examples.html#examples-prob-thsage"><i class="fa fa-check"></i><b>43.2.1</b> 智者千虑必有一失</a></li>
<li class="chapter" data-level="43.2.2" data-path="examples.html"><a href="examples.html#examples-prob-coupleseats"><i class="fa fa-check"></i><b>43.2.2</b> 圆桌夫妇座位问题</a></li>
</ul></li>
<li class="chapter" data-level="43.3" data-path="examples.html"><a href="examples.html#examples-scicomp"><i class="fa fa-check"></i><b>43.3</b> 科学计算</a><ul>
<li class="chapter" data-level="43.3.1" data-path="examples.html"><a href="examples.html#examples-scicomp-citylink"><i class="fa fa-check"></i><b>43.3.1</b> 城市间最短路径</a></li>
<li class="chapter" data-level="43.3.2" data-path="examples.html"><a href="examples.html#examples-scicomp-daub"><i class="fa fa-check"></i><b>43.3.2</b> Daubechies小波函数计算</a></li>
<li class="chapter" data-level="43.3.3" data-path="examples.html"><a href="examples.html#examples-scicomp-heating"><i class="fa fa-check"></i><b>43.3.3</b> 房间加热温度变化</a></li>
</ul></li>
<li class="chapter" data-level="43.4" data-path="examples.html"><a href="examples.html#examples-statcomp"><i class="fa fa-check"></i><b>43.4</b> 统计计算</a><ul>
<li class="chapter" data-level="43.4.1" data-path="examples.html"><a href="examples.html#examples-statcomp-kernden"><i class="fa fa-check"></i><b>43.4.1</b> 核回归与核密度估计</a></li>
<li class="chapter" data-level="43.4.2" data-path="examples.html"><a href="examples.html#examples-statcomp-mcquad2d"><i class="fa fa-check"></i><b>43.4.2</b> 二维随机模拟积分</a></li>
<li class="chapter" data-level="43.4.3" data-path="examples.html"><a href="examples.html#examples-statcomp-hidfreq"><i class="fa fa-check"></i><b>43.4.3</b> 潜周期估计</a></li>
<li class="chapter" data-level="43.4.4" data-path="examples.html"><a href="examples.html#examples-statcomp-armaest"><i class="fa fa-check"></i><b>43.4.4</b> ARMA(1,1)模型估计</a></li>
<li class="chapter" data-level="43.4.5" data-path="examples.html"><a href="examples.html#examples-statcomp-varprop"><i class="fa fa-check"></i><b>43.4.5</b> VAR模型平稳性</a></li>
<li class="chapter" data-level="43.4.6" data-path="examples.html"><a href="examples.html#examples-statcomp-storereliab"><i class="fa fa-check"></i><b>43.4.6</b> 贮存可靠性评估</a></li>
</ul></li>
<li class="chapter" data-level="43.5" data-path="examples.html"><a href="examples.html#examples-datatreat"><i class="fa fa-check"></i><b>43.5</b> 数据处理</a><ul>
<li class="chapter" data-level="43.5.1" data-path="examples.html"><a href="examples.html#examples-datatreat-subscore"><i class="fa fa-check"></i><b>43.5.1</b> 小题分题型分数汇总</a></li>
<li class="chapter" data-level="43.5.2" data-path="examples.html"><a href="examples.html#examples-datatreat-cluslab"><i class="fa fa-check"></i><b>43.5.2</b> 类别编号重排</a></li>
</ul></li>
<li class="chapter" data-level="43.6" data-path="examples.html"><a href="examples.html#examples-texttr"><i class="fa fa-check"></i><b>43.6</b> 文本处理</a><ul>
<li class="chapter" data-level="43.6.1" data-path="examples.html"><a href="examples.html#examples-texttr-hongloument"><i class="fa fa-check"></i><b>43.6.1</b> 用R语言下载处理《红楼梦》htm文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="http://www.math.pku.edu.cn/teachers/lidf/" target="blank">编著：李东风</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R语言教程</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="p-advfunc" class="section level1">
<h1><span class="header-section-number">19</span> 函数进阶</h1>
<div id="p-advfunc-callspe" class="section level2">
<h2><span class="header-section-number">19.1</span> 函数调用的各种形式</h2>
<p>在R语言中，有两条简明的理解R程序的原则：</p>
<ul>
<li>任何成分都是R的对象（变量、函数等等）；</li>
<li>任何活动都是调用函数（求子集、四则运算、比较、函数调用等）。</li>
</ul>
<p>函数调用有四种方式：</p>
<p>一、<strong>前缀形式</strong>。
这也是一般的格式，如<code>fsub(5, 2)</code>。</p>
<p>二、<strong>中缀形式</strong>。
二元运算符实际上都是函数，<code>5 - 2</code>的写法是中缀形式，
等同于<code>`-`(5, 2)</code>。因为<code>-</code>不是合法的R变量名（函数名），
所以在写成前缀形式时要用反向单撇号<code>`</code>保护。
这样，在<code>lapply</code>等泛函中可以使用<code>`+`</code>这样的四则运算作为输入的操作。
如</p>
<div class="sourceCode" id="cb1044"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1044-1"><a href="p-advfunc.html#cb1044-1"></a><span class="dv">5</span> <span class="op">-</span><span class="st"> </span><span class="dv">2</span></span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb1046"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1046-1"><a href="p-advfunc.html#cb1046-1"></a><span class="st">`</span><span class="dt">-</span><span class="st">`</span>(<span class="dv">5</span>, <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## [1] 3</code></pre>
<p>为了给<code>1:5</code>每个元素减去2，可以写成</p>
<div class="sourceCode" id="cb1048"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1048-1"><a href="p-advfunc.html#cb1048-1"></a><span class="kw">sapply</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="st">`</span><span class="dt">-</span><span class="st">`</span>, <span class="dv">2</span>)</span></code></pre></div>
<pre><code>## [1] -1  0  1  2  3</code></pre>
<p>用户也可以自己定义函数名如<code>%x%</code>这样的中缀函数，
可以用中缀格式调用。
如：</p>
<div class="sourceCode" id="cb1050"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1050-1"><a href="p-advfunc.html#cb1050-1"></a><span class="st">`</span><span class="dt">%+%</span><span class="st">`</span> &lt;-<span class="st"> </span><span class="cf">function</span>(x, y) <span class="kw">paste0</span>(x, y)</span>
<span id="cb1050-2"><a href="p-advfunc.html#cb1050-2"></a><span class="st">&quot;xyz&quot;</span> <span class="op">%+%</span><span class="st"> &quot;123&quot;</span></span></code></pre></div>
<pre><code>## [1] &quot;xyz123&quot;</code></pre>
<p>三、<strong>替换形式</strong>。
对属性的修改经常这样写，
如</p>
<div class="sourceCode" id="cb1052"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1052-1"><a href="p-advfunc.html#cb1052-1"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">2</span></span>
<span id="cb1052-2"><a href="p-advfunc.html#cb1052-2"></a><span class="kw">names</span>(x) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>)</span>
<span id="cb1052-3"><a href="p-advfunc.html#cb1052-3"></a>x</span></code></pre></div>
<pre><code>## a b 
## 1 2</code></pre>
<p>看起来是在对一个函数的输出结果赋值，
这很不合理，
但实际相当于前缀形式的</p>
<div class="sourceCode" id="cb1054"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1054-1"><a href="p-advfunc.html#cb1054-1"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">2</span></span>
<span id="cb1054-2"><a href="p-advfunc.html#cb1054-2"></a><span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span> &lt;-<span class="st"> </span>x</span>
<span id="cb1054-3"><a href="p-advfunc.html#cb1054-3"></a>x &lt;-<span class="st"> `</span><span class="dt">names&lt;-</span><span class="st">`</span>(x, <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))</span>
<span id="cb1054-4"><a href="p-advfunc.html#cb1054-4"></a><span class="kw">rm</span>(<span class="st">`</span><span class="dt">*tmp*</span><span class="st">`</span>)</span>
<span id="cb1054-5"><a href="p-advfunc.html#cb1054-5"></a>x</span></code></pre></div>
<p>即制作了<code>x</code>的副本，调用<code>names&lt;-</code>函数，
将<code>x</code>重新绑定到<code>names&lt;-</code>函数的返回值。</p>
<p>四、<strong>特殊形式</strong>。
<code>x[1]</code>, <code>x[[1]]</code>这些取子集或元素以及修改，
<code>()</code>, <code>{}</code>，<code>if</code>结构、<code>for</code>循环等本质上也是函数调用，
只不过用了特殊的语法。
这些函数在R中都是<strong>初等函数</strong>(primitive functions)。
初等函数仅在基本R中定义，
是由C代码实现的，
用户无法访问其三个部分。</p>
<p>取子集的特殊函数例如：</p>
<div class="sourceCode" id="cb1055"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1055-1"><a href="p-advfunc.html#cb1055-1"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb1055-2"><a href="p-advfunc.html#cb1055-2"></a>x[<span class="dv">1</span>]</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb1057"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1057-1"><a href="p-advfunc.html#cb1057-1"></a><span class="st">`</span><span class="dt">[</span><span class="st">`</span>(x, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb1059"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1059-1"><a href="p-advfunc.html#cb1059-1"></a>x[<span class="dv">1</span>] &lt;-<span class="st"> </span><span class="dv">999</span></span>
<span id="cb1059-2"><a href="p-advfunc.html#cb1059-2"></a>x</span></code></pre></div>
<pre><code>## [1] 999   2   3   4   5</code></pre>
<div class="sourceCode" id="cb1061"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1061-1"><a href="p-advfunc.html#cb1061-1"></a>x &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">5</span></span>
<span id="cb1061-2"><a href="p-advfunc.html#cb1061-2"></a>x &lt;-<span class="st"> `</span><span class="dt">[&lt;-</span><span class="st">`</span>(x, <span class="dv">1</span>, <span class="dv">999</span>)</span>
<span id="cb1061-3"><a href="p-advfunc.html#cb1061-3"></a>x</span></code></pre></div>
<pre><code>## [1] 999   2   3   4   5</code></pre>
<p>注意上面的<code>x[1] &lt;- 999</code>的替代写法中，
调用<code>`[&lt;-`(x, 1, 999)</code>是将其返回值（一个向量对象）重新绑定给变量<code>x</code>，
才达到了修改<code>x</code>的目的。</p>
<p><code>for</code>循环也是函数调用，
如<code>for(i in 1:3) print(i)</code>可以等价地写成<code>`for`(i, 1:3, print(i))</code>。</p>
</div>
<div id="p-advfunc-lex" class="section level2">
<h2><span class="header-section-number">19.2</span> 嵌套定义与句法作用域(lexical scoping)</h2>
<p>R语言允许在函数体内定义函数。
比如，</p>
<div class="sourceCode" id="cb1063"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1063-1"><a href="p-advfunc.html#cb1063-1"></a>x &lt;-<span class="st"> </span><span class="dv">-1</span></span>
<span id="cb1063-2"><a href="p-advfunc.html#cb1063-2"></a>f0 &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1063-3"><a href="p-advfunc.html#cb1063-3"></a>  f1 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1063-4"><a href="p-advfunc.html#cb1063-4"></a>    x <span class="op">+</span><span class="st"> </span><span class="dv">100</span></span>
<span id="cb1063-5"><a href="p-advfunc.html#cb1063-5"></a>  }</span>
<span id="cb1063-6"><a href="p-advfunc.html#cb1063-6"></a>  <span class="kw">f1</span>()</span>
<span id="cb1063-7"><a href="p-advfunc.html#cb1063-7"></a>}</span></code></pre></div>
<p>其中内嵌的函数<code>f1()</code>称为一个closure(闭包)。</p>
<p>内嵌的函数体内在读取某个变量值时，
如果此变量在函数体内还没有被赋值，
它就不是局部的，
会向定义的外面一层查找，
外层一层找不到，就继续向外查找。
上面例子<code>f1()</code>定义中的变量<code>x</code>不是局部变量，
就向外一层查找，
找到的会是<code>f0</code>的自变量<code>x</code>，而不是全局空间中<code>x</code>。
如</p>
<div class="sourceCode" id="cb1064"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1064-1"><a href="p-advfunc.html#cb1064-1"></a><span class="kw">f0</span>(<span class="dv">1</span>)</span></code></pre></div>
<pre><code>## [1] 101</code></pre>
<p>最后<code>x+100</code>中<code>x</code>取的是<code>f0</code>的实参值<code>x=1</code>，
而不是全局变量<code>x=-1</code>。</p>
<p>这样的变量查找规则叫做<strong>句法作用域</strong>(lexical scoping)，
即函数运行中需要使用某个变量时，
从其<strong>定义时</strong>的环境向外层逐层查找，
而<strong>不是</strong>在调用时的环境中查找。</p>
<p>例如，</p>
<div class="sourceCode" id="cb1066"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1066-1"><a href="p-advfunc.html#cb1066-1"></a>f0 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1066-2"><a href="p-advfunc.html#cb1066-2"></a>  f1 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1066-3"><a href="p-advfunc.html#cb1066-3"></a>    x &lt;-<span class="st"> </span><span class="dv">-1</span></span>
<span id="cb1066-4"><a href="p-advfunc.html#cb1066-4"></a>    f2 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1066-5"><a href="p-advfunc.html#cb1066-5"></a>      x <span class="op">+</span><span class="st"> </span><span class="dv">100</span></span>
<span id="cb1066-6"><a href="p-advfunc.html#cb1066-6"></a>    }</span>
<span id="cb1066-7"><a href="p-advfunc.html#cb1066-7"></a>    <span class="kw">f2</span>()</span>
<span id="cb1066-8"><a href="p-advfunc.html#cb1066-8"></a>  }</span>
<span id="cb1066-9"><a href="p-advfunc.html#cb1066-9"></a>  x &lt;-<span class="st"> </span><span class="dv">1000</span></span>
<span id="cb1066-10"><a href="p-advfunc.html#cb1066-10"></a>  <span class="kw">f1</span>()</span>
<span id="cb1066-11"><a href="p-advfunc.html#cb1066-11"></a>}</span>
<span id="cb1066-12"><a href="p-advfunc.html#cb1066-12"></a><span class="kw">f0</span>()</span></code></pre></div>
<pre><code>## [1] 99</code></pre>
<p>其中<code>f2()</code>运行时，
用到的<code>x</code>是<code>f1()</code>函数体内的局部变量<code>x=-1</code>，
而不是被调用时<code>f0()</code>函数体内的局部变量<code>x=1000</code>，
所以结果是<code>-1 + 100 = 99</code>。</p>
<p>“句法作用域”指的是函数调用时查找变量是查找其定义时的变量对应的<strong>存储空间</strong>，
而<strong>不是</strong>定义时变量所取的历史值。
函数运行时在找到某个变量对应的存储空间后，
会使用该变量的<strong>当前值</strong>，而不是函数定义的时候该变量的历史值。
这种规则称为动态查找(dynamic lookup)。
例如</p>
<div class="sourceCode" id="cb1068"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1068-1"><a href="p-advfunc.html#cb1068-1"></a>f0 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1068-2"><a href="p-advfunc.html#cb1068-2"></a>  x &lt;-<span class="st"> </span><span class="dv">-1</span></span>
<span id="cb1068-3"><a href="p-advfunc.html#cb1068-3"></a>  f1 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1068-4"><a href="p-advfunc.html#cb1068-4"></a>    x <span class="op">+</span><span class="st"> </span><span class="dv">100</span></span>
<span id="cb1068-5"><a href="p-advfunc.html#cb1068-5"></a>  }</span>
<span id="cb1068-6"><a href="p-advfunc.html#cb1068-6"></a>  x &lt;-<span class="st"> </span><span class="dv">1000</span></span>
<span id="cb1068-7"><a href="p-advfunc.html#cb1068-7"></a>  <span class="kw">f1</span>()</span>
<span id="cb1068-8"><a href="p-advfunc.html#cb1068-8"></a>}</span>
<span id="cb1068-9"><a href="p-advfunc.html#cb1068-9"></a><span class="kw">f0</span>()</span></code></pre></div>
<pre><code>## [1] 1100</code></pre>
<p>结果为什么不是<code>-1 + 100 = 99</code>而是<code>1000 + 100 = 1100</code>?
这是因为，
<code>f1()</code>在调用时，
使用的<code>x</code>是<code>f0</code>函数体内局部变量<code>x</code>的值，
但是要注意的是程序运行时会访问该变量的<strong>当前值</strong>，即1000，
而不是函数定义的时候<code>x</code>的历史值-1。
句法作用域与动态查找一个说的是如何查找某个变量对应的存储空间，
一个说的是使用该存储空间何时的存储值，
程序运行时两个规则需要联合使用。</p>
<p>句法作用域不仅适用于查找变量，
也适用于函数体内调用别的函数时查找函数。
查找函数的规则与查找变量规则相同。</p>
</div>
<div id="p-advfunc-inner" class="section level2">
<h2><span class="header-section-number">19.3</span> 辅助嵌套函数</h2>
<p>有时内嵌函数仅仅是函数内用来实现模块化的一种工具，
和正常的函数作用相同，没有任何特殊作用。
例如，如下的程序在自变量<code>x</code>中输入一元二次方程<span class="math inline">\(a x^2 + b x + c = 0\)</span>的三个系数,
输出解：</p>
<div class="sourceCode" id="cb1070"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1070-1"><a href="p-advfunc.html#cb1070-1"></a>solve.sqe &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1070-2"><a href="p-advfunc.html#cb1070-2"></a>  fd &lt;-<span class="st"> </span><span class="cf">function</span>(a, b, c) b<span class="op">^</span><span class="dv">2</span> <span class="op">-</span><span class="st"> </span><span class="dv">4</span><span class="op">*</span>a<span class="op">*</span>c</span>
<span id="cb1070-3"><a href="p-advfunc.html#cb1070-3"></a>  d &lt;-<span class="st"> </span><span class="kw">fd</span>(x[<span class="dv">1</span>], x[<span class="dv">2</span>], x[<span class="dv">3</span>])</span>
<span id="cb1070-4"><a href="p-advfunc.html#cb1070-4"></a>  <span class="cf">if</span>(d <span class="op">&gt;=</span><span class="st"> </span><span class="dv">0</span>){</span>
<span id="cb1070-5"><a href="p-advfunc.html#cb1070-5"></a>    <span class="kw">return</span>( (<span class="op">-</span>x[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">sqrt</span>(d))<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]) )</span>
<span id="cb1070-6"><a href="p-advfunc.html#cb1070-6"></a>  } <span class="cf">else</span> {</span>
<span id="cb1070-7"><a href="p-advfunc.html#cb1070-7"></a>    <span class="kw">return</span>( <span class="kw">complex</span>(<span class="dt">real=</span><span class="op">-</span>x[<span class="dv">2</span>], <span class="dt">imag=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">sqrt</span>(<span class="op">-</span>d))<span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]) )</span>
<span id="cb1070-8"><a href="p-advfunc.html#cb1070-8"></a>  }</span>
<span id="cb1070-9"><a href="p-advfunc.html#cb1070-9"></a>}</span></code></pre></div>
<p>在这个函数中内嵌的函数<code>fd</code>仅起到一个计算二次判别式的作用，
没有用到任何的闭包特性，
其中的形参变量<code>a, b, c</code>都是局部变量。
运行如</p>
<div class="sourceCode" id="cb1071"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1071-1"><a href="p-advfunc.html#cb1071-1"></a><span class="kw">solve.sqe</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-2</span>, <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] 1 1</code></pre>
<div class="sourceCode" id="cb1073"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1073-1"><a href="p-advfunc.html#cb1073-1"></a><span class="kw">solve.sqe</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-2</span>, <span class="dv">0</span>))</span></code></pre></div>
<pre><code>## [1] 2 0</code></pre>
<div class="sourceCode" id="cb1075"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1075-1"><a href="p-advfunc.html#cb1075-1"></a><span class="kw">solve.sqe</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">-2</span>, <span class="dv">2</span>))</span></code></pre></div>
<pre><code>## [1] 1+1i 1-1i</code></pre>
<p>这样的内嵌函数与直接在全局空间中定义的函数区别不大，
只有一条区别：
只能在定义它的函数内运行，
不能被直接调用，
可以看成是函数内的私有函数，
可以避免名字冲突。</p>
</div>
<div id="p-advfunc-lazy" class="section level2">
<h2><span class="header-section-number">19.4</span> 懒惰求值</h2>
<p>R函数在调用执行时，
除非用到某个形式变量的值才求出其对应实参的值。
这一点在实参是常数时无所谓，
但是如果实参是表达式就不一样了。
形参缺省值也是只有在函数运行时用到该形参的值时才求值。</p>
<p>例如，</p>
<div class="sourceCode" id="cb1077"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1077-1"><a href="p-advfunc.html#cb1077-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">y=</span><span class="kw">ifelse</span>(x<span class="op">&gt;</span><span class="dv">0</span>, <span class="ot">TRUE</span>, <span class="ot">FALSE</span>)){</span>
<span id="cb1077-2"><a href="p-advfunc.html#cb1077-2"></a>  x &lt;-<span class="st"> </span><span class="dv">-111</span></span>
<span id="cb1077-3"><a href="p-advfunc.html#cb1077-3"></a>  <span class="cf">if</span>(y) x<span class="op">*</span><span class="dv">2</span> <span class="cf">else</span> x<span class="op">*</span><span class="dv">10</span></span>
<span id="cb1077-4"><a href="p-advfunc.html#cb1077-4"></a>}</span>
<span id="cb1077-5"><a href="p-advfunc.html#cb1077-5"></a><span class="kw">f</span>(<span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] -1110</code></pre>
<p>可以看出，虽然形参<code>x</code>输入的实参值为5,
但是这时形参<code>y</code>并没按<code>x=5</code>被赋值为<code>TRUE</code>,
而是到函数体中第二个语句才被求值，
这时<code>x</code>的值已经变成了-111，
故<code>y</code>的值是<code>FALSE</code>。</p>
<p>另外要注意的是，
懒惰求值使得缺省值在初次访问时，
是在函数内的环境（局部变量作用域）内求值的，
不是在其调用处的环境内求值。</p>
<p>在函数内部，
用<code>missing(x)</code>对形参<code>x</code>判断用户是否没有提供对应的实参，
对位置形参和有缺省值的形参都适用。</p>
</div>
<div id="p-advfunc-debug" class="section level2">
<h2><span class="header-section-number">19.5</span> 程序调试</h2>
<div id="p-advfunc-debug-intro" class="section level3">
<h3><span class="header-section-number">19.5.1</span> 基本调试策略</h3>
<p>自己编写的某些涉及到复杂的算法的程序可能一开始并不能给出期望的结果。
这包括如下的情况：</p>
<ul>
<li>程序报错，
需要找到出错的地方加以纠正；</li>
<li>程序正常运行，
输出了结果，
但是结果明显有错；</li>
<li>最糟糕的是，
程序结果也看起来很正常，
但实际结果是错误的。</li>
</ul>
<p>以上这三种情况是依次越来越糟糕的。
直接运行出错的情况一般是比较容易处理的。</p>
<p>为了尽可能保证程序结果正确，
在自己编写新算法时，
要运用模块化思想，
将问题分解为若干个小问题，
使得每一个小问题都比较容易验证结果是否正确，
将每一个小问题编写成一个单独的函数，
这样也可以避免一段很长的程序中许多变量混杂在一起。</p>
<p>在划分模块并编写好程序后，
应该编写一系列的测试函数，
对每个函数进行测试，
保证其在各种情况下的结果是正确的。
最好采纳R的规则化的测试策略进行自动化测试，
在编写R扩展包时就推荐同时提供测试代码。</p>
<p>如果程序还是有错误，
首先可以求助于搜索引擎、用户社区等。
如果这个问题是常见问题，
往往这样就可以解决问题。</p>
<p>如果问题没有解决，
需要将问题最小化：
减少引起错误的程序的复杂程度，
将不必要的代码尽可能用固定的输入数据代替，
使得出错程序很短，
而且错误可重复。
有时会有不可重复的错误，
这样的错误往往很难解决，
超出了一般R用户的能力。</p>
<p>在将问题程序简化并且错误可重复以后，
就要试图定位错误。
一般编程语言都有如下的一些一般性查错(debugging)方法：</p>
<ul>
<li>在程序中适当位置加上输出命令（语句），
输出怀疑有错的变量值。</li>
<li>某些变成语言提供了跟踪以及条件跟踪命令，
可以在程序运行到某个语句或者触发了某个条件时程序中止，
但允许用户控制逐行运行程序并随时查看变量值，
称为跟踪调试(tracing)。
跟踪调试可以是命令行工具，
也可以是集成在RStudio这样的集成编程环境中的图形界面工具。</li>
</ul>
<p>在查错时，
科学研究思维照样起作用：
根据错误表现提出可能的原因假设，
制作测试输入数据验证假设，
记录相应输出并分析是否与假设的错误原因吻合。
如此反复直到找到出错原因并加以纠正。</p>
<p>查错并纠正就可能会破坏了成熟的代码，
造成新的错误，
所以最好能有自动化的测试策略，
在每次修改程序后都重新测试程序是否保持输出正确。</p>
</div>
<div id="p-advfunc-debug-findfunc" class="section level3">
<h3><span class="header-section-number">19.5.2</span> 找到出错的函数</h3>
<p>在较复杂的程序出错时，
需要首先将错误定位到某一函数调用。如：</p>
<div class="sourceCode" id="cb1079"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1079-1"><a href="p-advfunc.html#cb1079-1"></a>f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">f2</span>(x)</span>
<span id="cb1079-2"><a href="p-advfunc.html#cb1079-2"></a>f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="dv">1</span><span class="op">/</span>x</span>
<span id="cb1079-3"><a href="p-advfunc.html#cb1079-3"></a><span class="kw">f1</span>(<span class="st">&quot;abc&quot;</span>)</span>
<span id="cb1079-4"><a href="p-advfunc.html#cb1079-4"></a><span class="co">## Error in 1/x : 二进列运算符中有非数值参数</span></span></code></pre></div>
<p>为了在多层次函数调用中找到出错的函数，可以用如下命令：</p>
<div class="sourceCode" id="cb1080"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1080-1"><a href="p-advfunc.html#cb1080-1"></a><span class="kw">traceback</span>()</span>
<span id="cb1080-2"><a href="p-advfunc.html#cb1080-2"></a><span class="co">## 2: f2(x) at #1</span></span>
<span id="cb1080-3"><a href="p-advfunc.html#cb1080-3"></a><span class="co">## 1: f1(&quot;abc&quot;)</span></span></code></pre></div>
<p>结果是所谓的反向追踪(traceback)，
一般编程语言中称为调用栈(calling stack)。
这个输出是从下向上堆叠显示，
下层是调用方，
上层是被调用方。</p>
<p>在RStudio中运行时，
出错程序的右端可以显示“Show Traceback”以及“Rerun with Debug”快捷图标，
点击“Show Traceback”图标也可以显示反向追踪结果。
如果是一个源文件用source命名或图标运行时出错，
在显示反向追踪结果时还可以显示调用的各命令所在的程序行号。
点击“Rerun with Debug”可以进入跟踪调试状态，
显示出错时的运行环境中的变量值。</p>
</div>
<div id="p-advfunc-debug-browser" class="section level3">
<h3><span class="header-section-number">19.5.3</span> 跟踪调试</h3>
<p>R和RStudio提供了很好的跟踪运行程序的能力。
R的<code>browser()</code>命令可以用在程序中，
命令进入跟踪调试；
RStudio的源文件显示界面可以用鼠标点击定义跟踪调试位置。</p>
<p>函数定义一般都包含多行，所以一般不在命令行定义函数，
而是把函数定义以及较长的程序写在源程序文件中，
用<code>source</code>命令运行。
用<code>source</code>命令调入运行的程序与在命令行运行的效果基本相同，
这样定义的变量也是全局变量。</p>
<p>考虑如下函数定义:</p>
<div class="sourceCode" id="cb1081"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1081-1"><a href="p-advfunc.html#cb1081-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1081-2"><a href="p-advfunc.html#cb1081-2"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){</span>
<span id="cb1081-3"><a href="p-advfunc.html#cb1081-3"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1081-4"><a href="p-advfunc.html#cb1081-4"></a>  }</span>
<span id="cb1081-5"><a href="p-advfunc.html#cb1081-5"></a>}</span></code></pre></div>
<p>这个函数定义有许多问题。
用一个测试输入调用<code>f</code>，发现有错误:</p>
<div class="sourceCode" id="cb1082"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1082-1"><a href="p-advfunc.html#cb1082-1"></a><span class="kw">print</span>(<span class="kw">f</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>))</span>
<span id="cb1082-2"><a href="p-advfunc.html#cb1082-2"></a><span class="co">## Error in 1:n : NA/NaN参数</span></span></code></pre></div>
<p>简单的函数可以直接仔细检查发现错误，
用<code>cat</code>, <code>print</code>等输出中间结果查找错误。
R提供了一个<code>browser()</code>函数，
在程序中插入对<code>browser()</code>函数的调用，
可以进入跟踪调试状态，
可以实时地查看甚至修改运行时变量的值。</p>
<p>在RStudio的编辑窗口中打开.R源程序文件，
在某一程序行行号左端的空白处用鼠标单击，
就可以设定某一行为端点，
在用<code>source</code>命令运行到该处时就可以进入跟踪调试状态。</p>
<p>加入<code>browser()</code>命令后的程序如：</p>
<div class="sourceCode" id="cb1083"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1083-1"><a href="p-advfunc.html#cb1083-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1083-2"><a href="p-advfunc.html#cb1083-2"></a>  <span class="kw">browser</span>()</span>
<span id="cb1083-3"><a href="p-advfunc.html#cb1083-3"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){</span>
<span id="cb1083-4"><a href="p-advfunc.html#cb1083-4"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1083-5"><a href="p-advfunc.html#cb1083-5"></a>  }</span>
<span id="cb1083-6"><a href="p-advfunc.html#cb1083-6"></a>}</span></code></pre></div>
<p>程序运行遇到<code>browser()</code>函数或设定的断点时程序进入跟踪调试状态，
命令行的提示符变成“Browse[1]&gt;”。
这个命令行的环境一般不再是全局环境，
而是断点所在的函数的运行环境，
可以看到函数的局部变量。
可以在调试环境中用命令去查看当前定义的变量值、逐个命令地运行，
但是用RStudio则可以更方便地执行这些操作。</p>
<p>在调试命令行，可以使用如下命令：</p>
<ul>
<li>输入变量名查看变量值；</li>
<li>用<code>n</code>命令或者换行键逐句运行；</li>
<li>用<code>s</code>命令跟踪进调用的函数内部逐句运行；</li>
<li>用<code>f</code>命令快速执行到循环末尾或者函数末尾；</li>
<li>用<code>c</code>命令恢复正常运行，不再跟踪；</li>
<li>用<code>Q</code>命令强行终止程序运行。</li>
</ul>
<p>进入调试状态后，
RStudio界面提供了相应的支持。
这时RStudio的命令行窗格(Console)将会显示用于控制运行的图标，
包括执行下一语句（Next）、跟踪进入要调用的函数运行(Step into)、执行到函数末尾或者循环末尾(Finish)、不再跟踪继续正常运行（Continue）、终止运行（Stop）。
同时，
在RStudio的Environment窗格中会显示当前执行的命令所在的运行环境的内容，
包括函数内的局部变量；
如果点击其中的下拉菜单还可以显示函数的各层父环境。
在同一窗格中还会显示向后追踪(Traceback)，
即函数是如何被调用的。</p>
<p>为调试如上函数<code>f</code>的程序，
在定义中插入对<code>browser()</code>的调用如:</p>
<div class="sourceCode" id="cb1084"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1084-1"><a href="p-advfunc.html#cb1084-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1084-2"><a href="p-advfunc.html#cb1084-2"></a>  <span class="kw">browser</span>()</span>
<span id="cb1084-3"><a href="p-advfunc.html#cb1084-3"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){</span>
<span id="cb1084-4"><a href="p-advfunc.html#cb1084-4"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1084-5"><a href="p-advfunc.html#cb1084-5"></a>  }</span>
<span id="cb1084-6"><a href="p-advfunc.html#cb1084-6"></a>}</span></code></pre></div>
<p>当在RStudio中调试运行时，
程序编辑窗口将显示当前要运行的程序行，
用命令行窗口(Console)的Next快捷图标可以运行到下一行。
命令行的显示如：</p>
<pre><code>&gt; print(f(1:5))
Called from: eval(expr, p)
Browse[1]&gt; n
debug在D:/disk/projects/Rbookweb/tmp2.R#2: for (i in 1:n) {
    s &lt;- s + x[i]
}
Browse[2]&gt; </code></pre>
<p>继续用“Next”图标运行，命令行结果如：</p>
<pre><code>Browse[2]&gt; n
Error in 1:n : NA/NaN参数</code></pre>
<p>发现是在<code>for(i in 1:n)</code>行遇到未定义的变量<code>n</code>。</p>
<p>在源文件中把出错行改为<code>for(i in 1:length(x))</code>，
再次运行,
发现在运行<code>s &lt;- s + x[i]</code>行时，
遇到“错误: 找不到对象’s’”。
这是忘记初始化引起的。
在<code>for</code>语句前添加<code>s &lt;- 0</code>语句，函数定义变成：</p>
<div class="sourceCode" id="cb1087"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1087-1"><a href="p-advfunc.html#cb1087-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1087-2"><a href="p-advfunc.html#cb1087-2"></a>  <span class="kw">browser</span>()</span>
<span id="cb1087-3"><a href="p-advfunc.html#cb1087-3"></a>  s &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1087-4"><a href="p-advfunc.html#cb1087-4"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(x)){</span>
<span id="cb1087-5"><a href="p-advfunc.html#cb1087-5"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1087-6"><a href="p-advfunc.html#cb1087-6"></a>  }</span>
<span id="cb1087-7"><a href="p-advfunc.html#cb1087-7"></a>}</span></code></pre></div>
<p>再次运行，
在跟踪到循环时，
为了避免繁琐的跟踪过程，
可以用“执行到函数末尾或者循环末尾”快捷图标或命令行的<code>f</code>命令，
或者“Continue”快捷图标或命令行的<code>c</code>命令。
程序不显示错误但是也没有显示结果为<code>NULL</code>而不是我们期望得输入元素之和。
检查可以看出错误是忘记把函数返回值写在函数定义最后。</p>
<p>在函数定义最后添加<code>s</code>一行，
再次运行，程序结果与手工验算结果一致。
函数变成</p>
<div class="sourceCode" id="cb1088"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1088-1"><a href="p-advfunc.html#cb1088-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1088-2"><a href="p-advfunc.html#cb1088-2"></a>  <span class="kw">browser</span>()</span>
<span id="cb1088-3"><a href="p-advfunc.html#cb1088-3"></a>  n &lt;-<span class="st"> </span><span class="kw">length</span>(x)</span>
<span id="cb1088-4"><a href="p-advfunc.html#cb1088-4"></a>  s &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1088-5"><a href="p-advfunc.html#cb1088-5"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>n){</span>
<span id="cb1088-6"><a href="p-advfunc.html#cb1088-6"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1088-7"><a href="p-advfunc.html#cb1088-7"></a>  }</span>
<span id="cb1088-8"><a href="p-advfunc.html#cb1088-8"></a>  s</span>
<span id="cb1088-9"><a href="p-advfunc.html#cb1088-9"></a>}</span></code></pre></div>
<p>自定义函数应该用各种不同输入测试其正确性和稳定性。
比如，上面的函数当自变量x为零长度向量时应该返回0才合适，
但是上面的写法会返回一个<code>numeric(0)</code>结果，
这个结果表示长度为零的向量：</p>
<div class="sourceCode" id="cb1089"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1089-1"><a href="p-advfunc.html#cb1089-1"></a><span class="kw">f</span>(<span class="kw">numeric</span>(<span class="dv">0</span>))</span>
<span id="cb1089-2"><a href="p-advfunc.html#cb1089-2"></a><span class="co">## Called from: f(numeric(0))</span></span>
<span id="cb1089-3"><a href="p-advfunc.html#cb1089-3"></a><span class="co">## Browse[1]&gt; c</span></span>
<span id="cb1089-4"><a href="p-advfunc.html#cb1089-4"></a><span class="co">## numeric(0)</span></span></code></pre></div>
<p>程序输入了零长度自变量，
我们期望其输出为零而不是<code>numeric(0)</code>。
在自变量x为零长度时，
函数中<code>for(i in 1:length(x)</code>应该一次都不进入循环，
跟踪运行可以发现实际对i=1和i=0共运行了两轮循环。
把这里的<code>1:length(x)</code>改成<code>seq_along(x)</code>解决了问题，
<code>seq_along(x)</code>生成x的下标序列，
如果x是零长度的则下标序列为零长度向量。</p>
<p>函数不需要修改后，
可以把对<code>browser()</code>的调用删除或注释掉，
在RStudio中关闭断点。
函数最终修改为：</p>
<div class="sourceCode" id="cb1090"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1090-1"><a href="p-advfunc.html#cb1090-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb1090-2"><a href="p-advfunc.html#cb1090-2"></a>  s &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1090-3"><a href="p-advfunc.html#cb1090-3"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(x)){</span>
<span id="cb1090-4"><a href="p-advfunc.html#cb1090-4"></a>    s &lt;-<span class="st"> </span>s <span class="op">+</span><span class="st"> </span>x[i]</span>
<span id="cb1090-5"><a href="p-advfunc.html#cb1090-5"></a>  }</span>
<span id="cb1090-6"><a href="p-advfunc.html#cb1090-6"></a>  s</span>
<span id="cb1090-7"><a href="p-advfunc.html#cb1090-7"></a>}</span></code></pre></div>
<p>这里只是用这个简单函数演示如何调试程序，
求向量元素和这个问题本身是不需要我们去定义新函数的，
<code>sum</code>函数本来就是完成这样的功能。
实际上，许多我们认为需要自己编写程序做的事情，
在R网站都能找到别人已经完成的扩展包。</p>
</div>
<div id="p-advfunc-debug-cond" class="section level3">
<h3><span class="header-section-number">19.5.4</span> 条件断点</h3>
<p>用<code>browser()</code>函数与R的<code>if</code>结构配合可以制作条件断点。
比如，
在调试带有循环的程序时，
发现错误发生在循环内，
如果从循环开始就跟踪运行，
会浪费许多时间。
设已知错误发生在循环变量<code>i</code>等于501的时候，
就可以在循环内插入：</p>
<div class="sourceCode" id="cb1091"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1091-1"><a href="p-advfunc.html#cb1091-1"></a>  <span class="cf">if</span>(i <span class="op">==</span><span class="st"> </span><span class="dv">501</span>) <span class="kw">browser</span>()</span></code></pre></div>
<p>这样就可以在更接近出错的位置进入跟踪运行。</p>
</div>
<div id="p-advfunc-debug-debugf" class="section level3">
<h3><span class="header-section-number">19.5.5</span> 开启对一个函数的调试</h3>
<p>可以用<code>debug(f)</code>命令对函数<code>f</code>开启跟踪运行，
这时每次调用<code>f()</code>时都会自动进入跟踪运行状态。
用<code>undebug(f)</code>取消对<code>f</code>的这种操作。</p>
</div>
<div id="p-advfunc-debug-opt" class="section level3">
<h3><span class="header-section-number">19.5.6</span> 出错调试选项</h3>
<p>比较长的程序在调试时如果从开头就跟踪，
比较耗时。可以设置成出错后自动进入跟踪模式，
检查出错时的变量值。只要进行如下设置：</p>
<div class="sourceCode" id="cb1092"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1092-1"><a href="p-advfunc.html#cb1092-1"></a><span class="kw">options</span>(<span class="dt">error=</span>recover)</span></code></pre></div>
<p>则在出错后可以选择进入出错的某一层函数内部,
在browser环境中跟踪运行。</p>
<p>在RStudio中调试某一源程序文件时，
可以选择“Debug–On Error”菜单，
并选择“Break in Code”，
就可以在出错时自动在出错处进入跟踪状态。</p>
<p>例如，用<code>options()</code>函数进行设置后，
前面那个求向量元素和的例子程序按最初的定义，
运行时出现如下的选择：</p>
<pre><code>## Error in f(1:5) : object &#39;n&#39; not found
## 
## Enter a frame number, or 0 to exit   
## 
## 1: f(1:5)
## 
## Selection: f(1:5)
## 
## Selection: 1
## Called from: top level 
## Browse[1]&gt; </code></pre>
<p>在<code>Selection</code>后面输入了1，就进入了函数内部跟踪。
用Q终止运行并退出整个browser跟踪。
当函数调用函数时可以选择进入哪一个函数进行跟踪。
如果在RStudio中设置了“Break in Code”，
会自动在出错处进入跟踪运行状态。</p>
</div>
<div id="p-advfunc-debug-stop" class="section level3">
<h3><span class="header-section-number">19.5.7</span> <code>stop()</code>、<code>warning()</code>、<code>message()</code></h3>
<p>编写程序时应尽可能提前发现不合法的输入和错误的状态。
发现错误时，
可以用<code>stop(s)</code>使程序运行出错停止，
其中<code>s</code>是一个字符型对象，
用来作为显示的出错信息。</p>
<p>发现某些问题后如果不严重，
可以不停止程序运行，
但用<code>warning(s)</code>提交一个警告信息，
其中<code>s</code>是字符型的警告信息。
警告信息的显示可能比实际运行要延迟一些。</p>
<p>有些警告信息实际是错误，
用<code>options()</code>的<code>warn</code>参数可以设置警告级别，
如设置<code>warn=2</code>则所有警告当作错误处理。
设置如</p>
<div class="sourceCode" id="cb1094"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1094-1"><a href="p-advfunc.html#cb1094-1"></a><span class="kw">options</span>(<span class="dt">warn=</span><span class="dv">2</span>)</span></code></pre></div>
<p>其中<code>warn=0</code>是默认做法，
<code>warn=1</code>表示不延迟显示。</p>
<p>函数<code>message()</code>与<code>stop()</code>、<code>warning()</code>类似，
不算是错误或者警告，
是提示性的信息输出。
<code>message()</code>不会像<code>warning()</code>那样延迟显示。
比如，
长时间的等待之前给出一个提示，
正在读写文件或者网络时给出提示，
等等。
与<code>cat()</code>等相比较，
<code>cat()</code>是用户要求的输出，
而<code>message()</code>是程序员对用户的提示。</p>
</div>
<div id="p-advfunc-debug-preventive" class="section level3">
<h3><span class="header-section-number">19.5.8</span> 预防性设计</h3>
<p>在编写自定义函数时，
可以检查自变量输入以确保输入符合要求。
函数<code>stopifnot</code>可以指定自变量的若干个条件，
当自变量不符合条件时自动出错停止。</p>
<p>例如，函数<code>f()</code>需要输入两个数值型向量x, y,
需要长度相等，
可以用如下的程序</p>
<div class="sourceCode" id="cb1095"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1095-1"><a href="p-advfunc.html#cb1095-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x, y){</span>
<span id="cb1095-2"><a href="p-advfunc.html#cb1095-2"></a>  <span class="kw">stopifnot</span>(<span class="kw">is.numeric</span>(x),</span>
<span id="cb1095-3"><a href="p-advfunc.html#cb1095-3"></a>            <span class="kw">is.numeric</span>(y),</span>
<span id="cb1095-4"><a href="p-advfunc.html#cb1095-4"></a>            <span class="kw">length</span>(x)<span class="op">==</span><span class="kw">length</span>(y))</span>
<span id="cb1095-5"><a href="p-advfunc.html#cb1095-5"></a>  <span class="co">## 函数体程序语句...</span></span>
<span id="cb1095-6"><a href="p-advfunc.html#cb1095-6"></a>}</span></code></pre></div>
</div>
<div id="p-advfunc-debug-try" class="section level3">
<h3><span class="header-section-number">19.5.9</span> 出错处理机制</h3>
<p>R运行可以用<code>stop()</code>产生错误状态，
停止运行；
用<code>warning()</code>产生警告，
用<code>message()</code>产生提示。
基本R提供了<code>tryCatch()</code>函数，
用来保护可能出错的代码，
并可以指定出错时用的恢复或诊断代码。
<code>try()</code>函数也可以保护可能出错的代码，
使得出错时错误信息照样显示但不中断运行。</p>
<p>扩展包rlang提供了一些对出错处理机制的增强功能。
详见<span class="citation">(Wickham <a href="#ref-Wickham2019:advanced-r-2ed" role="doc-biblioref">2019</a>)</span>第8章：Conditions。</p>
</div>
</div>
<div id="p-advfunc-funcprog" class="section level2">
<h2><span class="header-section-number">19.6</span> 函数式编程介绍</h2>
<p>R支持类(class)和方法(method)，
实际提供了适用于多种自变量的通用函数(generic function)，
不同自变量类型调用该类特有的方法， 但函数名可以保持不变。
这可以支持一定的面向对象编程方式。</p>
<p>R也支持函数式编程，
但不是专门的函数式编程语言。
R语言的设计主要用函数求值来进行运算；
R的用户主要使用函数调用来访问R的功能。</p>
<p>按照函数式编程的要求，
函数应该是“第一级对象”，
可以将函数对象绑定到变量名上面，
可以在列表等结构中保存多个函数，
可以在函数内定义函数，
可以用函数作为函数的自变量，
R函数满足这样的要求。</p>
<p>函数式编程的目的是提供可理解、可证明正确的软件。
R虽然带有函数式编程语言特点，
但并不强求使用函数式编程规范。
典型的函数式编程语言如Haskel, Lisp的运行与R的显式的、顺序的执行方式相差很大。</p>
<div id="p-advfunc-pure" class="section level3">
<h3><span class="header-section-number">19.6.1</span> 纯函数</h3>
<p>函数式编程要求每个函数必须功能清晰、定义确切，
最好是所谓“纯函数”。
R并不是专门的函数式编程语言，
专门的函数式编程语言提供了定义纯函数的功能。
纯函数需要满足如下条件：</p>
<ul>
<li><p>没有副作用。调用一个函数对后续运算没有影响，
不管是再次调用此函数还是调用其它函数。
这样，用全局变量在函数之间传递信息就是不允许的。
其它副作用包括写文件、打印、绘图等，
这样的副作用对函数式要求破坏不大。
函数返回值包含了函数执行的所有效果。</p></li>
<li><p>不受外部影响。函数返回值只依赖于其自变量及函数的定义。
函数定义仅由对所有可能的自变量值确定返回值来确定，
不依赖于任何外部信息（也就不能依赖于全局变量与系统设置值）。
在专用的函数时变成语言中，
函数定义返回值的方式是隐含地遍历所有可能的参数值给出返回值，
而不是用过程式的计算来修改对象的值。</p></li>
<li><p>不受赋值影响。
函数定义不需要反复对内部对象（所谓“状态变量”）赋值或修改。</p></li>
</ul>
<p>R的函数一般不能修改实参的值，
这有助于实现纯函数的要求。
但是，如果多个函数之间用全局变量传递信息，
就不能算是纯函数。
像<code>options()</code>函数这样修改全局运行环境的功能会破坏函数式要求。
尽可能让自己的函数不依赖于<code>options()</code>中的参数。</p>
<p>如果函数对相同的输入可以有不同的输出当然不是纯函数，
例如R中的随机数函数(<code>sample()</code>, <code>runif()</code>, <code>rnorm</code>等)。</p>
<p>与具体硬件、软件环境有关的一些因素也破坏纯函数要求，
如不同的硬件常数、精度等。
调用操作系统的功能对函数式要求破坏较大。
减少赋值主要需要减少循环，可以用R的向量化方法解决。</p>
<p>一个R函数是否满足纯函数要求不仅要看函数本身，
还要看函数内部调用的其它函数是否纯函数。</p>
<p>R不是专用的函数式编程语言，
但可以采用函数式编程的范式，
将大多数函数写成纯函数，
将有副作用的单独写在少数的函数中。</p>
</div>
<div id="p-advfunc-rec" class="section level3">
<h3><span class="header-section-number">19.6.2</span> 副作用和运行环境恢复</h3>
<p>如果函数除了输出之外还在其它方面影响了运行环境，
这样的函数就不是纯函数。
所有画图函数(<code>plot</code>等)、输出函数(<code>cat</code>, <code>print</code>, <code>save</code>等)都是这样的函数。
这些对运行环境的改变叫做<strong>副作用</strong>（side effects）。
又比如，<code>library()</code>函数会引入新的函数和变量，
<code>setwd()</code>, <code>Sys.setenv()</code>, <code>Sys.setlocale()</code>会改变R运行环境，
<code>options()</code>, <code>par()</code>会改变R全局设置。
自定义R函数中如果调用了非纯函数也就变成了非纯函数。
编程中要尽量控制副作用而且要意识到副作用的影响，
尤其是全局设置与全局变量的影响。</p>
<p>有些函数不可避免地要修改运行环境，
比如当前工作目录(用<code>setwd()</code>)、R运行选项(用<code>options()</code>)、绘图参数(用<code>par()</code>)等，
如果可能的话，
在函数结束运行前，
应该恢复对运行环境的修改。
为此，可以在函数体的前面部分调用<code>on.exit()</code>函数，
此函数的参数是在函数退出前要执行的表达式或复合表达式。</p>
<p>例如，
绘图的函数中经常需要用<code>par()</code>修改绘图参数，
这会使得后续程序出错。
为此，可以在函数开头保存原始的绘图参数，
函数结束时恢复到原始的绘图参数。
如</p>
<div class="sourceCode" id="cb1096"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1096-1"><a href="p-advfunc.html#cb1096-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1096-2"><a href="p-advfunc.html#cb1096-2"></a>  opar &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">mfrow=</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>))</span>
<span id="cb1096-3"><a href="p-advfunc.html#cb1096-3"></a>  <span class="kw">on.exit</span>(<span class="kw">par</span>(opar))</span>
<span id="cb1096-4"><a href="p-advfunc.html#cb1096-4"></a>  <span class="kw">plot</span>((<span class="op">-</span><span class="dv">10</span>)<span class="op">:</span><span class="dv">10</span>)</span>
<span id="cb1096-5"><a href="p-advfunc.html#cb1096-5"></a>  <span class="kw">plot</span>((<span class="op">-</span><span class="dv">10</span>)<span class="op">:</span><span class="dv">10</span>, ((<span class="op">-</span><span class="dv">10</span>)<span class="op">:</span><span class="dv">10</span>)<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb1096-6"><a href="p-advfunc.html#cb1096-6"></a>}</span>
<span id="cb1096-7"><a href="p-advfunc.html#cb1096-7"></a><span class="kw">f</span>()</span></code></pre></div>
<p><img src="static/picture/prog-func63-1.png" width="672" /></p>
<p>如果函数中需要多次调用<code>on.exit()</code>指定多个恢复动作，
除第一个调用的<code>on.exit()</code>以外都应该加上<code>add=TRUE</code>选项。
如果需要指定越晚添加的恢复动作越先执行，
在<code>on.exit()</code>中还要加上<code>after=FALSE</code>选项。</p>
</div>
<div id="p-advfunc-rsupp" class="section level3">
<h3><span class="header-section-number">19.6.3</span> R的函数式编程功能</h3>
<p>R语言不是专用的函数式编程语言，
但支持使用函数式编程的一些常见做法。
R函数时第一级对象，
支持内嵌函数，
并可以输入函数作为函数的自变量，
称这样的函数为<strong>泛函</strong>(functionals)，
如<code>lapply</code>类函数；
可以输出函数作为函数结果，
称这样的函数为<strong>函数工厂</strong>；
可以输入函数，
进行一定修改后输出函数，
称这样的函数为<strong>函数算子</strong>(function operators)。
这些功能都为函数式编程风格提供了有力的支持。</p>
<p>利用R的purrr扩展包，
可以用统一的风格使用函数式编程，
比基本R的lapply类函数、Map、Reduce等更容易使用。</p>
<p>下面讲解泛函、函数工厂和函数算子。</p>
</div>
</div>
<div id="p-advfunc-functional" class="section level2">
<h2><span class="header-section-number">19.7</span> 泛函</h2>
<p>许多函数需要用函数作为参数，称这样的函数为<strong>泛函</strong>(functionals)。
典型的泛函是<code>lapply</code>类函数。
这样的函数具有很好的通用性，
因为需要进行的操作可以输入一个函数来规定，
用输入的函数规定要进行什么样的操作。</p>
<div id="p-advfunc-fnctnl-map" class="section level3">
<h3><span class="header-section-number">19.7.1</span> <code>purrr::map</code>函数</h3>
<p>设我们要对列表或向量<code>x</code>的每个元素<code>x[[i]]</code>调用函数<code>f()</code>，
将结果保存成一个列表。
这样做的一个程序框架是：</p>
<div class="sourceCode" id="cb1097"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1097-1"><a href="p-advfunc.html#cb1097-1"></a>y &lt;-<span class="st"> </span><span class="kw">vector</span>(list, <span class="kw">length</span>(x))</span>
<span id="cb1097-2"><a href="p-advfunc.html#cb1097-2"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="kw">seq_along</span>(x)){</span>
<span id="cb1097-3"><a href="p-advfunc.html#cb1097-3"></a>  y[[i]] &lt;-<span class="st"> </span><span class="kw">f</span>(x[[i]])</span>
<span id="cb1097-4"><a href="p-advfunc.html#cb1097-4"></a>}</span>
<span id="cb1097-5"><a href="p-advfunc.html#cb1097-5"></a><span class="kw">names</span>(y) &lt;-<span class="st"> </span><span class="kw">names</span>(x)</span></code></pre></div>
<p>其中的输入<code>x</code>是任意的，
函数<code>f</code>是任意的。
<code>purrr</code>包的<code>map()</code>函数可以用一条命令完成上述任务：</p>
<div class="sourceCode" id="cb1098"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1098-1"><a href="p-advfunc.html#cb1098-1"></a>y &lt;-<span class="st"> </span><span class="kw">map</span>(x, f)</span></code></pre></div>
<p>这个函数与基本R的<code>lapply</code>功能基本相同，
对数据框、列表的每一项进行计算或操作时最为适用。</p>
<div id="p-advfunc-fnctnl-map-ex1" class="section level4">
<h4><span class="header-section-number">19.7.1.1</span> <code>map</code>数据框处理示例</h4>
<p>下面举例说明map函数对数据框处理的应用。</p>
<p><code>typeof()</code>函数求变量的存储类型，如</p>
<div class="sourceCode" id="cb1099"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1099-1"><a href="p-advfunc.html#cb1099-1"></a>d.class &lt;-<span class="st"> </span>readr<span class="op">::</span><span class="kw">read_csv</span>(<span class="st">&#39;class.csv&#39;</span>)</span></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   name = col_character(),
##   sex = col_character(),
##   age = col_double(),
##   height = col_double(),
##   weight = col_double()
## )</code></pre>
<div class="sourceCode" id="cb1101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1101-1"><a href="p-advfunc.html#cb1101-1"></a><span class="kw">typeof</span>(d.class[[<span class="st">&quot;age&quot;</span>]])</span></code></pre></div>
<pre><code>## [1] &quot;double&quot;</code></pre>
<p>这里<code>d.class</code>是一个tibble数据框，
tibble也是一个列表，
每个列表元素是数据框的一列。</p>
<p>如下程序使用<code>purrr::map()</code>求每一列的存储类型，
map的结果总是列表，每个列表元素对应于输入的一个元素，
如:</p>
<div class="sourceCode" id="cb1103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1103-1"><a href="p-advfunc.html#cb1103-1"></a><span class="kw">library</span>(purrr)</span>
<span id="cb1103-2"><a href="p-advfunc.html#cb1103-2"></a><span class="kw">map</span>(d.class, typeof)</span></code></pre></div>
<pre><code>## $name
## [1] &quot;character&quot;
## 
## $sex
## [1] &quot;character&quot;
## 
## $age
## [1] &quot;double&quot;
## 
## $height
## [1] &quot;double&quot;
## 
## $weight
## [1] &quot;double&quot;</code></pre>
<p>当结果比较简单时，
保存为列表不够方便，
函数<code>unlist()</code>可以将比较简单的列表转换为基本类型的向量，如：</p>
<div class="sourceCode" id="cb1105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1105-1"><a href="p-advfunc.html#cb1105-1"></a><span class="kw">unlist</span>(<span class="kw">map</span>(d.class, typeof))</span></code></pre></div>
<pre><code>##        name         sex         age      height      weight 
## &quot;character&quot; &quot;character&quot;    &quot;double&quot;    &quot;double&quot;    &quot;double&quot;</code></pre>
<p>关于一个数据框的结构，
用<code>str()</code>函数可以得到更为详细的信息：</p>
<div class="sourceCode" id="cb1107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1107-1"><a href="p-advfunc.html#cb1107-1"></a><span class="kw">str</span>(d.class)</span></code></pre></div>
<pre><code>## Classes &#39;spec_tbl_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 19 obs. of  5 variables:
##  $ name  : chr  &quot;Alice&quot; &quot;Becka&quot; &quot;Gail&quot; &quot;Karen&quot; ...
##  $ sex   : chr  &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; ...
##  $ age   : num  13 13 14 12 12 15 11 15 14 14 ...
##  $ height: num  56.5 65.3 64.3 56.3 59.8 66.5 51.3 62.5 62.8 69 ...
##  $ weight: num  84 98 90 77 84.5 ...
##  - attr(*, &quot;spec&quot;)=
##   .. cols(
##   ..   name = col_character(),
##   ..   sex = col_character(),
##   ..   age = col_double(),
##   ..   height = col_double(),
##   ..   weight = col_double()
##   .. )</code></pre>
</div>
<div id="p-advfunc-fnctnl-map-mapstr" class="section level4">
<h4><span class="header-section-number">19.7.1.2</span> <code>map</code>返回基本类型向量</h4>
<p><code>purrr::map()</code>总是返回列表。
如果确知其调用的函数总是返回某种类型的标量值，
可以用<code>map</code>的变种：</p>
<ul>
<li><code>map_lgl()</code>：返回逻辑向量；</li>
<li><code>map_int()</code>：返回整型向量；</li>
<li><code>map_dbl()</code>: 返回双精度浮点型向量(double类型)；</li>
<li><code>map_chr()</code>: 返回字符型向量。</li>
</ul>
<p>比如，
求<code>d.class</code>各列类型，
因为确知<code>typeof()</code>函数对每列返回一个标量字符串，所以可以写成：</p>
<div class="sourceCode" id="cb1109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1109-1"><a href="p-advfunc.html#cb1109-1"></a><span class="kw">map_chr</span>(d.class, typeof)</span></code></pre></div>
<pre><code>##        name         sex         age      height      weight 
## &quot;character&quot; &quot;character&quot;    &quot;double&quot;    &quot;double&quot;    &quot;double&quot;</code></pre>
<p>对<code>d.class</code>，
可以对每一列用<code>is.numeric</code>判断是否数值型，
结果为逻辑型向量，
如：</p>
<div class="sourceCode" id="cb1111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1111-1"><a href="p-advfunc.html#cb1111-1"></a><span class="kw">map_lgl</span>(d.class, is.numeric)</span></code></pre></div>
<pre><code>##   name    sex    age height weight 
##  FALSE  FALSE   TRUE   TRUE   TRUE</code></pre>
</div>
<div id="p-advfunc-fnctnl-map-ddd" class="section level4">
<h4><span class="header-section-number">19.7.1.3</span> <code>...</code>形参</h4>
<p>在R函数的形参中，
允许有一个特殊的<code>...</code>形参（三个小数点），
这在调用泛函类型的函数时起到重要作用。
在调用泛函时，
所有没有形参与之匹配的实参，
不论是带有名字还是不带有名字的，
都自动归入这个参数，
将会由泛函传递给作为其自变量的函数。
<code>...</code>参数的类型相当于一个列表，
列表元素可以部分有名部分无名，
用<code>list(...)</code>可以将其转换成列表再访问。</p>
<p>例如，函数<code>mean()</code>可以计算去掉部分最低、最高值之后的平均值，
用选项<code>trim=</code>指定一个两边分别舍弃的值的个数比例。
为了将<code>d.class</code>的三列数值型列计算上下各自扣除10%的平均值，
需要利用<code>map_dbl()</code>函数的<code>...</code>参数输入<code>trim</code>选项值，如：</p>
<div class="sourceCode" id="cb1113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1113-1"><a href="p-advfunc.html#cb1113-1"></a><span class="kw">map_dbl</span>(d.class[,<span class="dv">3</span><span class="op">:</span><span class="dv">5</span>], mean, <span class="dt">trim=</span><span class="fl">0.10</span>)</span></code></pre></div>
<pre><code>##       age    height    weight 
##  13.29412  62.41765 100.00000</code></pre>
<p>上面的数值型列是直接在程序中固定列号选出的，
也可以用<code>map_lgl()</code>选出：</p>
<div class="sourceCode" id="cb1115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1115-1"><a href="p-advfunc.html#cb1115-1"></a>dsub &lt;-<span class="st"> </span>d.class[, <span class="kw">map_lgl</span>(d.class, is.numeric)]</span>
<span id="cb1115-2"><a href="p-advfunc.html#cb1115-2"></a><span class="kw">map_dbl</span>(dsub, mean, <span class="dt">trim=</span><span class="fl">0.10</span>)</span></code></pre></div>
<pre><code>##       age    height    weight 
##  13.29412  62.41765 100.00000</code></pre>
<p>purrr包提供了一个<code>keep</code>函数，
可以专门用来选择数据框各列或列表元素中满足某种条件的子集，
这个条件用一个返回逻辑值的函数来给出。如：</p>
<div class="sourceCode" id="cb1117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1117-1"><a href="p-advfunc.html#cb1117-1"></a>dsub &lt;-<span class="st"> </span><span class="kw">keep</span>(d.class, is.numeric)</span>
<span id="cb1117-2"><a href="p-advfunc.html#cb1117-2"></a><span class="kw">map_dbl</span>(dsub, mean, <span class="dt">trim=</span><span class="fl">0.10</span>)</span></code></pre></div>
<pre><code>##       age    height    weight 
##  13.29412  62.41765 100.00000</code></pre>
<p>利用magrittr包的管道运算符<code>%&gt;%</code>可以将对一个数据框的删选、计算过程更清晰地表达出来，
不需要<code>dsub</code>这样存储中间结果的变量：</p>
<div class="sourceCode" id="cb1119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1119-1"><a href="p-advfunc.html#cb1119-1"></a>d.class <span class="op">%&gt;%</span></span>
<span id="cb1119-2"><a href="p-advfunc.html#cb1119-2"></a><span class="st">  </span><span class="kw">keep</span>(is.numeric) <span class="op">%&gt;%</span></span>
<span id="cb1119-3"><a href="p-advfunc.html#cb1119-3"></a><span class="st">  </span><span class="kw">map_dbl</span>(mean, <span class="dt">trim=</span><span class="fl">0.10</span>)</span></code></pre></div>
<pre><code>##       age    height    weight 
##  13.29412  62.41765 100.00000</code></pre>
<p>需要注意的是，
在<code>map</code>类泛函中<code>...</code>仅用来将额外的选项传递给要调用的函数，
不支持向量化，
如果需要对两个或多个自变量的对应元素作变换，
需用用purrr包的<code>map2</code>等函数。
如果泛函中调用的是无名函数，
则<code>...</code>参数会造成变量作用域理解困难。</p>
</div>
<div id="p-advfunc-fnctnl-map-ex2" class="section level4">
<h4><span class="header-section-number">19.7.1.4</span> 用<code>map</code>处理<code>strsplit</code>函数结果示例</h4>
<p>假设有4个学生的3次小测验成绩，
每个学生的成绩记录到了一个以逗号分隔的字符串中，如：</p>
<div class="sourceCode" id="cb1121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1121-1"><a href="p-advfunc.html#cb1121-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&#39;10, 8, 7&#39;</span>, </span>
<span id="cb1121-2"><a href="p-advfunc.html#cb1121-2"></a>      <span class="st">&#39;5, 2, 2&#39;</span>, </span>
<span id="cb1121-3"><a href="p-advfunc.html#cb1121-3"></a>      <span class="st">&#39;3, 7, 8&#39;</span>, </span>
<span id="cb1121-4"><a href="p-advfunc.html#cb1121-4"></a>      <span class="st">&#39;8, 8, 9&#39;</span>)</span></code></pre></div>
<p>对单个学生，可以用<code>strsplit()</code>函数把三个成绩拆分，如：</p>
<div class="sourceCode" id="cb1122"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1122-1"><a href="p-advfunc.html#cb1122-1"></a><span class="kw">strsplit</span>(s[<span class="dv">1</span>], <span class="st">&#39;,&#39;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;10&quot; &quot; 8&quot; &quot; 7&quot;</code></pre>
<p>注意这里<code>strspil()</code>的结果是仅有一个元素的列表，
用了“<code>[[...]]</code>”格式取出列表元素。
拆分的结果可以用<code>as.numeric()</code>转换为有三个元素的数值型向量：</p>
<div class="sourceCode" id="cb1124"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1124-1"><a href="p-advfunc.html#cb1124-1"></a><span class="kw">as.numeric</span>(<span class="kw">strsplit</span>(s[<span class="dv">1</span>], <span class="st">&#39;,&#39;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)[[<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [1] 10  8  7</code></pre>
<p>还可以求三次小测验的总分：</p>
<div class="sourceCode" id="cb1126"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1126-1"><a href="p-advfunc.html#cb1126-1"></a><span class="kw">sum</span>(<span class="kw">as.numeric</span>(<span class="kw">strsplit</span>(s[<span class="dv">1</span>], <span class="st">&#39;,&#39;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)[[<span class="dv">1</span>]]))</span></code></pre></div>
<pre><code>## [1] 25</code></pre>
<p>用<code>strsplit()</code>处理有4个字符串的字符型向量s,
结果是长度为4的列表：</p>
<div class="sourceCode" id="cb1128"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1128-1"><a href="p-advfunc.html#cb1128-1"></a>tmpr &lt;-<span class="st"> </span><span class="kw">strsplit</span>(s, <span class="st">&#39;,&#39;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>); tmpr</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;10&quot; &quot; 8&quot; &quot; 7&quot;
## 
## [[2]]
## [1] &quot;5&quot;  &quot; 2&quot; &quot; 2&quot;
## 
## [[3]]
## [1] &quot;3&quot;  &quot; 7&quot; &quot; 8&quot;
## 
## [[4]]
## [1] &quot;8&quot;  &quot; 8&quot; &quot; 9&quot;</code></pre>
<p>用<code>map()</code>和<code>as.numeric()</code>可以把列表中所有字符型转为数值型，
输出为一个列表，
然后再对各个列表元素中的向量求和。
使用管道运算符表达逐步的操作：</p>
<div class="sourceCode" id="cb1130"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1130-1"><a href="p-advfunc.html#cb1130-1"></a>s <span class="op">%&gt;%</span></span>
<span id="cb1130-2"><a href="p-advfunc.html#cb1130-2"></a><span class="st">  </span><span class="kw">strsplit</span>(<span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>) <span class="op">%&gt;%</span></span>
<span id="cb1130-3"><a href="p-advfunc.html#cb1130-3"></a><span class="st">  </span><span class="kw">map</span>(as.numeric) <span class="op">%&gt;%</span></span>
<span id="cb1130-4"><a href="p-advfunc.html#cb1130-4"></a><span class="st">  </span><span class="kw">map_dbl</span>(sum)</span></code></pre></div>
<pre><code>## [1] 25  9 18 25</code></pre>
</div>
<div id="p-advfunc-fnctnl-map-anon" class="section level4">
<h4><span class="header-section-number">19.7.1.5</span> 在<code>map</code>中使用无名函数以及简写方法</h4>
<p><code>map()</code>中调用的函数可以是在<code>map()</code>中直接现场定义的无名函数。</p>
<p>仍考虑上面的问题，有4个学生，
每个学生有三门成绩，成绩之间用逗号分隔。
将每个学生的成绩拆分为三个字符串后，
就可以对每个学生调用一个统一的无名函数，
将字符型转换为数值型以后求和：</p>
<div class="sourceCode" id="cb1132"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1132-1"><a href="p-advfunc.html#cb1132-1"></a><span class="kw">map_dbl</span>(<span class="kw">strsplit</span>(s, <span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>),</span>
<span id="cb1132-2"><a href="p-advfunc.html#cb1132-2"></a>  <span class="cf">function</span>(x) <span class="kw">sum</span>(<span class="kw">as.numeric</span>(x)))</span></code></pre></div>
<pre><code>## [1] 25  9 18 25</code></pre>
<p>或用管道运算符：</p>
<div class="sourceCode" id="cb1134"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1134-1"><a href="p-advfunc.html#cb1134-1"></a>s <span class="op">%&gt;%</span></span>
<span id="cb1134-2"><a href="p-advfunc.html#cb1134-2"></a><span class="st">  </span><span class="kw">strsplit</span>(<span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>) <span class="op">%&gt;%</span></span>
<span id="cb1134-3"><a href="p-advfunc.html#cb1134-3"></a><span class="st">  </span><span class="kw">map_dbl</span>(<span class="cf">function</span>(x) <span class="kw">sum</span>(<span class="kw">as.numeric</span>(x)))</span></code></pre></div>
<pre><code>## [1] 25  9 18 25</code></pre>
<p>使用无名函数格式比较复杂，
purrr包为在<code>map()</code>等泛函中使用无名函数提供了简化的写法，
将无名函数写成“<code>~ 表达式</code>”格式，
表达式就是无名函数定义，
用<code>.</code>表示只有一个自变量时的自变量名，
用<code>.x</code>和<code>.y</code>表示只有两个自变量时的自变量名，
用<code>..1</code>、<code>..2</code>、<code>..3</code>这样的名字表示有多个自变量时的自变量名。
如：</p>
<div class="sourceCode" id="cb1136"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1136-1"><a href="p-advfunc.html#cb1136-1"></a><span class="kw">map_dbl</span>(<span class="kw">strsplit</span>(s, <span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>),</span>
<span id="cb1136-2"><a href="p-advfunc.html#cb1136-2"></a>  <span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">as.numeric</span>(.)))</span></code></pre></div>
<pre><code>## [1] 25  9 18 25</code></pre>
<p>需要注意的是，
如果<code>map()</code>等泛函中的无名函数需要访问其它变量的话，
需要理解其变量作用域或访问环境（参见<a href="p-advfunc.html#p-advfunc-env">19.9</a>）。
另外，
无名函数中的其它变量在每次被<code>map()</code>应用到输入列表的元素时都会重新计算求值。
建议这样的情况改用有名函数，
这样其中访问其它变量时作用域规则比较容易掌控，
也不会重复求值。</p>
</div>
<div id="p-advfunc-fnctnl-map-pluck" class="section level4">
<h4><span class="header-section-number">19.7.1.6</span> 在<code>map</code>中提取列表元素成员的简写</h4>
<p>较为复杂的数据，
有时表现为列表的列表，
每个列表元素都是列表或者向量。
JSON、YAML等格式转换为R对象就经常具有这种嵌套结构。</p>
<p>例如，
有如下的嵌套格式数据，
这样的数据不利于用数据框格式保存：</p>
<div class="sourceCode" id="cb1138"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1138-1"><a href="p-advfunc.html#cb1138-1"></a>od &lt;-<span class="st"> </span><span class="kw">list</span>(</span>
<span id="cb1138-2"><a href="p-advfunc.html#cb1138-2"></a>  <span class="kw">list</span>(</span>
<span id="cb1138-3"><a href="p-advfunc.html#cb1138-3"></a>    <span class="dv">101</span>, <span class="dt">name=</span><span class="st">&quot;李明&quot;</span>, <span class="dt">age=</span><span class="dv">15</span>, </span>
<span id="cb1138-4"><a href="p-advfunc.html#cb1138-4"></a>    <span class="dt">hobbies=</span><span class="kw">c</span>(<span class="st">&quot;绘画&quot;</span>, <span class="st">&quot;音乐&quot;</span>)),</span>
<span id="cb1138-5"><a href="p-advfunc.html#cb1138-5"></a>  <span class="kw">list</span>(</span>
<span id="cb1138-6"><a href="p-advfunc.html#cb1138-6"></a>    <span class="dv">102</span>, <span class="dt">name=</span><span class="st">&quot;张聪&quot;</span>, <span class="dt">age=</span><span class="dv">17</span>,</span>
<span id="cb1138-7"><a href="p-advfunc.html#cb1138-7"></a>    <span class="dt">hobbies=</span><span class="kw">c</span>(<span class="st">&quot;足球&quot;</span>),</span>
<span id="cb1138-8"><a href="p-advfunc.html#cb1138-8"></a>    <span class="dt">birth=</span><span class="st">&quot;2002-10-01&quot;</span>)</span>
<span id="cb1138-9"><a href="p-advfunc.html#cb1138-9"></a>)</span></code></pre></div>
<p>为了取出每个列表元素的第一项，本来应该写成：</p>
<div class="sourceCode" id="cb1139"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1139-1"><a href="p-advfunc.html#cb1139-1"></a><span class="kw">map_dbl</span>(od, <span class="cf">function</span>(x) x[[<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [1] 101 102</code></pre>
<p>或：</p>
<div class="sourceCode" id="cb1141"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1141-1"><a href="p-advfunc.html#cb1141-1"></a><span class="kw">map_dbl</span>(od, <span class="op">~</span><span class="st"> </span>.[[<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [1] 101 102</code></pre>
<p>purrr包提供了进一步的简化写法，
在需要一个函数或者一个“<code>~ 表达式</code>”的地方，
可以用整数下标值表示对每个列表元素提取其中的指定成分，如：</p>
<div class="sourceCode" id="cb1143"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1143-1"><a href="p-advfunc.html#cb1143-1"></a><span class="kw">map_dbl</span>(od, <span class="dv">1</span>)</span></code></pre></div>
<pre><code>## [1] 101 102</code></pre>
<p>类似地，可以在需要函数的地方写一个成员名，
提取每个列表元素中该成员，如：</p>
<div class="sourceCode" id="cb1145"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1145-1"><a href="p-advfunc.html#cb1145-1"></a><span class="kw">map_chr</span>(od, <span class="st">&quot;name&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot; &quot;张聪&quot;</code></pre>
<p>在应该用函数的地方还可以提供一个列表，
列表元素为成员序号或者成员名，
进行逐层挖掘，如：</p>
<div class="sourceCode" id="cb1147"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1147-1"><a href="p-advfunc.html#cb1147-1"></a><span class="kw">map_chr</span>(od, <span class="kw">list</span>(<span class="st">&quot;hobbies&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] &quot;绘画&quot; &quot;足球&quot;</code></pre>
<p>表示取出每个列表元素的<code>hobbies</code>成员的第一个元素（每人的第一个业余爱好）。</p>
<p>取出不存在的成员会出错，
但可以用一个<code>.default</code>选项指定查找不到成员时的选项，
如：</p>
<div class="sourceCode" id="cb1149"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1149-1"><a href="p-advfunc.html#cb1149-1"></a><span class="kw">map_chr</span>(od, <span class="st">&quot;birth&quot;</span>, <span class="dt">.default=</span><span class="ot">NA</span>)</span></code></pre></div>
<pre><code>## [1] NA           &quot;2002-10-01&quot;</code></pre>
</div>
<div id="p-advfunc-fnctnl-map-split" class="section level4">
<h4><span class="header-section-number">19.7.1.7</span> 数据框分组处理示例</h4>
<p>对<code>d.class</code>数据框，
希望分成男女生两个组，
每组内建立用身高预测体重的一元线性回归模型，
提取各模型的斜率项。
基本R的<code>split</code>函数可以按数据框的某列将数据框分成若干个子数据框，
结果为子数据框的列表。
借助于purrr包的<code>map</code>类函数和管道运算符，
可以将分组建模过程写成：</p>
<div class="sourceCode" id="cb1151"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1151-1"><a href="p-advfunc.html#cb1151-1"></a>d.class <span class="op">%&gt;%</span></span>
<span id="cb1151-2"><a href="p-advfunc.html#cb1151-2"></a><span class="st">  </span><span class="kw">split</span>(d.class[[<span class="st">&quot;sex&quot;</span>]]) <span class="op">%&gt;%</span></span>
<span id="cb1151-3"><a href="p-advfunc.html#cb1151-3"></a><span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="st"> </span><span class="kw">lm</span>(weight <span class="op">~</span><span class="st"> </span>height, <span class="dt">data=</span>.)) <span class="op">%&gt;%</span></span>
<span id="cb1151-4"><a href="p-advfunc.html#cb1151-4"></a><span class="st">  </span><span class="co"># 这里的“.”是map需要输入的无名函数的自变量</span></span>
<span id="cb1151-5"><a href="p-advfunc.html#cb1151-5"></a><span class="st">  </span><span class="kw">map</span>(coef) <span class="op">%&gt;%</span></span>
<span id="cb1151-6"><a href="p-advfunc.html#cb1151-6"></a><span class="st">  </span><span class="kw">map_dbl</span>(<span class="dv">2</span>)</span></code></pre></div>
<pre><code>##        F        M 
## 3.424405 3.912549</code></pre>
<p>这些步骤用基本R的lapply或者for循环也能够完成，
但会更难读懂，
或者需要生成许多中间临时变量，
不如上面例子这样步骤清晰而且不需要产生中间结果。</p>
<p>dplyr包和plyr包与这个例子的思想类似，
只不过更有针对性。</p>
</div>
</div>
<div id="p-advfunc-fnctnl-mapv" class="section level3">
<h3><span class="header-section-number">19.7.2</span> purrr包中<code>map</code>函数的变种</h3>
<p>purrr包的<code>map</code>函数输入一个数据自变量和一个函数，
输出为列表；
<code>map_dbl()</code>等将输出转化为基础类型的向量。</p>
<p>purrr包还提供了与<code>map</code>目的类似，
但输入输出类型有变化的一些函数，
包括：</p>
<ul>
<li><code>modify()</code>，输入一个数据自变量和一个函数，
输出与输入数据同类型的结果；</li>
<li><code>map2()</code>可以输入两个数据自变量和一个函数，
将两个自变量相同下标的元素用函数进行变换，
输出列表；</li>
<li><code>imap()</code>根据一个下标遍历；</li>
<li><code>walk()</code>输入一个数据自变量和一个函数，
不返回任何结果，仅利用输入的函数的副作用；</li>
<li>输入若干个数据自变量和一个函数，
对数据自变量相同下标的元素用函数进行变换；</li>
</ul>
<p>将这些<code>map</code>变种输入类型分为：</p>
<ul>
<li>一个数据自变量，代表为<code>map()</code>；</li>
<li>两个自变量，代表为<code>map2()</code>；</li>
<li>一个自变量和一个下标变量，代表为<code>imap()</code>；</li>
<li>多个自变量，代表为<code>pmap()</code>。</li>
</ul>
<p>将输入结果分为：</p>
<ul>
<li>列表，代表为<code>map()</code>;</li>
<li>基础类型的向量，如<code>map_dbl()</code>, <code>map_chr()</code>等；</li>
<li>与输入数据类型相同的输出，代表为<code>modify()</code>；</li>
<li>不输出结果，代表为<code>walk()</code>。</li>
</ul>
<p>输入类型和输出类型两两搭配，
purrr包提供了27种<code>map</code>类函数。</p>
<div id="p-advfunc-fnctnl-mapv-modify" class="section level4">
<h4><span class="header-section-number">19.7.2.1</span> 输入输出类型相同的<code>modify</code>函数</h4>
<p>purrr的<code>modify</code>函数与<code>map</code>函数作用类似，
并不会原地修改输入数据，
而是制作修改后的副本，
输出的结果类型与输入数据的结果类型相同，
所以可以用来修改数据框各列生成一个副本数据框。</p>
<p>比如，
对<code>d.class</code>中的三个数值型列，
都减去列中位数，其它列保持不变：</p>
<div class="sourceCode" id="cb1153"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1153-1"><a href="p-advfunc.html#cb1153-1"></a>d1 &lt;-<span class="st"> </span><span class="kw">modify</span>(d.class, <span class="op">~</span><span class="st"> </span><span class="cf">if</span>(<span class="kw">is.numeric</span>(.x)) .x <span class="op">-</span><span class="st"> </span><span class="kw">median</span>(.x) <span class="cf">else</span> .x)</span></code></pre></div>
<p>purrr包还提供了一个<code>modify_if()</code>函数，
可以对满足条件的列进行修改，如：</p>
<div class="sourceCode" id="cb1154"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1154-1"><a href="p-advfunc.html#cb1154-1"></a>d2 &lt;-<span class="st"> </span><span class="kw">modify_if</span>(d.class, is.numeric, <span class="op">~</span><span class="st"> </span>.x <span class="op">-</span><span class="st"> </span><span class="kw">median</span>(.x))</span></code></pre></div>
</div>
<div id="p-advfunc-fnctnl-mapv-map2" class="section level4">
<h4><span class="header-section-number">19.7.2.2</span> 对两个自变量的相同下标元素调用函数</h4>
<p><code>map()</code>函数仅支持一个输入数据的列表或向量。
<code>map2()</code>函数支持两个输入数据的列表或向量，
<code>map2(x, y, f, ...)</code>对每个下标<code>i</code>调用<code>f(x[[i]], y[[i]], ...)</code>，
结果返回一个列表。
如果知道函数<code>f()</code>会返回类型确定的标量值，
可以用<code>map2_dbl()</code>等变种。</p>
<p>例如，
<code>d1</code>是某市2001年四个季度的若干项经济指标，
<code>d2</code>是2002年的对应指标，
计算每项指标年度总和的同比增幅：</p>
<div class="sourceCode" id="cb1155"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1155-1"><a href="p-advfunc.html#cb1155-1"></a>d1 &lt;-<span class="st"> </span><span class="kw">tibble</span>(</span>
<span id="cb1155-2"><a href="p-advfunc.html#cb1155-2"></a>  <span class="dt">x1 =</span> <span class="kw">c</span>(<span class="dv">106</span>, <span class="dv">108</span>, <span class="dv">103</span>, <span class="dv">110</span>),</span>
<span id="cb1155-3"><a href="p-advfunc.html#cb1155-3"></a>  <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">101</span>, <span class="dv">112</span>, <span class="dv">107</span>, <span class="dv">105</span>) )</span>
<span id="cb1155-4"><a href="p-advfunc.html#cb1155-4"></a>d2 &lt;-<span class="st"> </span><span class="kw">tibble</span>(</span>
<span id="cb1155-5"><a href="p-advfunc.html#cb1155-5"></a>  <span class="dt">x1 =</span> <span class="kw">c</span>(<span class="dv">104</span>, <span class="dv">111</span>, <span class="dv">112</span>, <span class="dv">109</span>),</span>
<span id="cb1155-6"><a href="p-advfunc.html#cb1155-6"></a>  <span class="dt">x2 =</span> <span class="kw">c</span>(<span class="dv">102</span>, <span class="dv">114</span>, <span class="dv">105</span>, <span class="dv">107</span>) )</span>
<span id="cb1155-7"><a href="p-advfunc.html#cb1155-7"></a><span class="kw">map2_dbl</span>(d1, d2, <span class="op">~</span><span class="st"> </span>(<span class="kw">sum</span>(.y) <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(.x)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(.x))</span></code></pre></div>
<pre><code>##          x1          x2 
## 0.021077283 0.007058824</code></pre>
<p>如果计算结果与两个输入数据类型相同，
可以用<code>modify2()</code>。
比如，
上面的例子数据计算每个指标的同比增幅：</p>
<div class="sourceCode" id="cb1157"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1157-1"><a href="p-advfunc.html#cb1157-1"></a><span class="kw">modify2</span>(d1, d2, <span class="op">~</span><span class="st"> </span>(.y <span class="op">-</span><span class="st"> </span>.x) <span class="op">/</span><span class="st"> </span>.x)</span></code></pre></div>
<pre><code>## # A tibble: 4 x 2
##         x1       x2
##      &lt;dbl&gt;    &lt;dbl&gt;
## 1 -0.0189   0.00990
## 2  0.0278   0.0179 
## 3  0.0874  -0.0187 
## 4 -0.00909  0.0190</code></pre>
<p><code>map2()</code>允许输入的<code>x</code>和<code>y</code>两个列表其中一个长度为1，
这时长度为1的列表的一个元素被重复利用。如：</p>
<div class="sourceCode" id="cb1159"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1159-1"><a href="p-advfunc.html#cb1159-1"></a>d1b &lt;-<span class="st"> </span>d1[,<span class="dv">1</span>,drop=<span class="ot">FALSE</span>]</span>
<span id="cb1159-2"><a href="p-advfunc.html#cb1159-2"></a><span class="kw">map2_dbl</span>(d1b, d2, <span class="op">~</span><span class="st"> </span>(<span class="kw">sum</span>(.y) <span class="op">-</span><span class="st"> </span><span class="kw">sum</span>(.x)) <span class="op">/</span><span class="st"> </span><span class="kw">sum</span>(.x))</span></code></pre></div>
<pre><code>## [1] 0.02107728 0.00234192</code></pre>
<p>基本R的<code>Map()</code>函数起到与<code>map2()</code>和<code>pmap()</code>类似的作用。</p>
</div>
<div id="p-advfunc-fnctnl-mapv-walk" class="section level4">
<h4><span class="header-section-number">19.7.2.3</span> 不产生输出的<code>walk</code>类函数</h4>
<p>有时仅需要遍历一个数据结构调用函数进行一些显示、绘图，
这称为函数的副作用，
不需要返回结果。
purrr的<code>walk</code>函数针对这种情形。</p>
<p>例如，
显示数据框中每个变量的类别：</p>
<div class="sourceCode" id="cb1161"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1161-1"><a href="p-advfunc.html#cb1161-1"></a><span class="kw">walk</span>(d.class, <span class="op">~</span><span class="st"> </span><span class="kw">cat</span>(<span class="kw">typeof</span>(.x), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))</span></code></pre></div>
<pre><code>## character 
## character 
## double 
## double 
## double</code></pre>
<p>上面这个例子缺点是没有显示对应的变量名。</p>
<p><code>walk2()</code>函数可以接受两个数据自变量，
类似于<code>map2()</code>。
例如，
需要对一组数据分别保存到文件中，
就可以将数据列表与保存文件名的字符型向量作为<code>walk2()</code>的两个数据自变量。
下面的程序将<code>d.class</code>分成男女生两个子集，
保存到两个csv文件中：</p>
<div class="sourceCode" id="cb1163"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1163-1"><a href="p-advfunc.html#cb1163-1"></a>dl &lt;-<span class="st"> </span><span class="kw">split</span>(d.class, d.class[[<span class="st">&quot;sex&quot;</span>]])</span>
<span id="cb1163-2"><a href="p-advfunc.html#cb1163-2"></a><span class="kw">walk2</span>(dl, <span class="kw">paste0</span>(<span class="st">&quot;class-&quot;</span>, <span class="kw">names</span>(dl), <span class="st">&quot;.csv&quot;</span>), </span>
<span id="cb1163-3"><a href="p-advfunc.html#cb1163-3"></a>      <span class="op">~</span><span class="st"> </span><span class="kw">write.csv</span>(.x, <span class="dt">file=</span>.y))</span></code></pre></div>
<p>改用管道运算符：</p>
<div class="sourceCode" id="cb1164"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1164-1"><a href="p-advfunc.html#cb1164-1"></a>d.class <span class="op">%&gt;%</span></span>
<span id="cb1164-2"><a href="p-advfunc.html#cb1164-2"></a><span class="st">  </span><span class="kw">split</span>(d.class[[<span class="st">&quot;sex&quot;</span>]]) <span class="op">%&gt;%</span></span>
<span id="cb1164-3"><a href="p-advfunc.html#cb1164-3"></a><span class="st">  </span><span class="kw">walk2</span>(<span class="kw">paste0</span>(<span class="st">&quot;class-&quot;</span>, <span class="kw">names</span>(.), <span class="st">&quot;.csv&quot;</span>), <span class="op">~</span><span class="st"> </span><span class="kw">write.csv</span>(.x, <span class="dt">file=</span>.y))</span></code></pre></div>
<p>事实上，
<code>walk</code>、<code>walk2</code>并不是没有输出，
它们返回不显示的第一个自变量，
所以也适合用在管道运算的中间使得管道不至于中断。</p>
<p>基本R没有提供类似<code>walk</code>的功能。</p>
</div>
<div id="p-advfunc-fnctnl-mapv-imap" class="section level4">
<h4><span class="header-section-number">19.7.2.4</span> 可同时访问下标或元素名与元素值的<code>imap</code>类函数</h4>
<p>在前面用<code>walk</code>函数显示数据框各列类型的例子中，
没有能够同时显示变量名。
如果<code>x</code>有元素名，
<code>imap(x, f)</code>相当于<code>imap2(x, names(x), f)</code>；
如果<code>x</code>没有元素名，
<code>imap(x, f)</code>相当于<code>imap2(x, seq_along(x), f)</code>。
<code>iwalk()</code>与<code>imap()</code>类似但不返回信息。
调用的函数的第二个自变量，
或者无名函数的<code>.y</code>自变量是元素名或者元素下标。
<code>imap_chr()</code>等是固定返回类型的变种。</p>
<p>例如，
显示数据框各列的变量名：</p>
<div class="sourceCode" id="cb1165"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1165-1"><a href="p-advfunc.html#cb1165-1"></a><span class="kw">iwalk</span>(d.class, <span class="op">~</span><span class="st"> </span><span class="kw">cat</span>(.y, <span class="st">&quot;: &quot;</span>, <span class="kw">typeof</span>(.x), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))</span></code></pre></div>
<pre><code>## name :  character 
## sex :  character 
## age :  double 
## height :  double 
## weight :  double</code></pre>
<p>返回字符型向量的写法：</p>
<div class="sourceCode" id="cb1167"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1167-1"><a href="p-advfunc.html#cb1167-1"></a><span class="kw">imap_chr</span>(d.class, <span class="op">~</span><span class="st"> </span><span class="kw">paste0</span>(.y, <span class="st">&quot; ==&gt; &quot;</span>, <span class="kw">typeof</span>(.x))) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">unname</span>()</span></code></pre></div>
<pre><code>## [1] &quot;name ==&gt; character&quot; &quot;sex ==&gt; character&quot;  &quot;age ==&gt; double&quot;    
## [4] &quot;height ==&gt; double&quot;  &quot;weight ==&gt; double&quot;</code></pre>
<p>输入数据没有元素名的演示：</p>
<div class="sourceCode" id="cb1169"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1169-1"><a href="p-advfunc.html#cb1169-1"></a>dl &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">101</span><span class="op">:</span><span class="dv">103</span>)</span>
<span id="cb1169-2"><a href="p-advfunc.html#cb1169-2"></a><span class="kw">iwalk</span>(dl, <span class="op">~</span><span class="st"> </span><span class="kw">cat</span>(<span class="st">&quot;NO. &quot;</span>, .y, <span class="st">&quot;: &quot;</span>, .x[[<span class="dv">1</span>]], <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>))</span></code></pre></div>
<pre><code>## NO.  1 :  1 
## NO.  2 :  101</code></pre>
<p>显示了每个列表元素的第一项。</p>
<p>基本R没有提供类似<code>imap</code>的功能。</p>
</div>
<div id="p-advfunc-fnctnl-mapv-pmap" class="section level4">
<h4><span class="header-section-number">19.7.2.5</span> 多个数据自变量的<code>pmap</code>类函数</h4>
<p>R的向量化可以很好地处理各个自变量是向量的情形，
但是对于列表、数据框等多个自变量则不能自动进行向量化处理。
purrr包的<code>pmap</code>类函数支持对多个列表、数据框、向量等进行向量化处理。
<code>pmap</code>不是将多个列表等作为多个自变量，
而是将它们打包为一个列表。
所以，
<code>map2(x, y, f)</code>用<code>pmap()</code>表示为<code>pmap(list(x, y), f)</code>。</p>
<p>在确知输出类型时可以用<code>pmap_chr()</code>, <code>pmap_dbl()</code>等变种，
在不需要输出结果时可以用<code>pwalk()</code>。</p>
<p>比如，
将三个列表中的对应项用<code>c()</code>函数连接：</p>
<div class="sourceCode" id="cb1171"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1171-1"><a href="p-advfunc.html#cb1171-1"></a>x &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">101</span>, <span class="dt">name=</span><span class="st">&quot;李明&quot;</span>)</span>
<span id="cb1171-2"><a href="p-advfunc.html#cb1171-2"></a>y &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">102</span>, <span class="dt">name=</span><span class="st">&quot;张聪&quot;</span>)</span>
<span id="cb1171-3"><a href="p-advfunc.html#cb1171-3"></a>z &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dv">103</span>, <span class="dt">name=</span><span class="st">&quot;王国&quot;</span>)</span>
<span id="cb1171-4"><a href="p-advfunc.html#cb1171-4"></a><span class="kw">pmap</span>(<span class="kw">list</span>(x, y, z), c)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 101 102 103
## 
## $name
## [1] &quot;李明&quot; &quot;张聪&quot; &quot;王国&quot;</code></pre>
<p><code>pmap()</code>除了输入一个列表和要并行执行的函数以外，
也可以输入一个数据框，
对数据框的每一行执行函数。
例如：</p>
<div class="sourceCode" id="cb1173"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1173-1"><a href="p-advfunc.html#cb1173-1"></a>d &lt;-<span class="st"> </span>tibble<span class="op">::</span><span class="kw">tibble</span>(</span>
<span id="cb1173-2"><a href="p-advfunc.html#cb1173-2"></a>  <span class="dt">x =</span> <span class="dv">101</span><span class="op">:</span><span class="dv">103</span>, </span>
<span id="cb1173-3"><a href="p-advfunc.html#cb1173-3"></a>  <span class="dt">y=</span><span class="kw">c</span>(<span class="st">&quot;李明&quot;</span>, <span class="st">&quot;张聪&quot;</span>, <span class="st">&quot;王国&quot;</span>))</span>
<span id="cb1173-4"><a href="p-advfunc.html#cb1173-4"></a><span class="kw">pmap_chr</span>(d, <span class="cf">function</span>(...) <span class="kw">paste</span>(..., <span class="dt">sep=</span><span class="st">&quot;:&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;101:李明&quot; &quot;102:张聪&quot; &quot;103:王国&quot;</code></pre>
<p><code>pmap()</code>和其它的<code>map()</code>类函数有一个区别是，
因为将输入数据打包在一个列表中，
而列表元素是有变量名的，
这样就可以将列表变量名取为要调用的函数的自变量名，
使得对输入列表中各元素的每个成员调用函数时，
可以带有对应的形参名调用。</p>
<p>例如，<code>mean()</code>函数可以计算去掉最小、最大一部分后的平均值，
<code>mean(x, trim)</code>用<code>trim</code>选项控制两端分别去掉的比例，
但是<code>trim</code>选项必须是标量。
用<code>map_dbl()</code>解决方法如下：</p>
<div class="sourceCode" id="cb1175"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1175-1"><a href="p-advfunc.html#cb1175-1"></a><span class="kw">set.seed</span>(<span class="dv">101</span>)</span>
<span id="cb1175-2"><a href="p-advfunc.html#cb1175-2"></a>x &lt;-<span class="st"> </span><span class="kw">rcauchy</span>(<span class="dv">1000</span>)</span>
<span id="cb1175-3"><a href="p-advfunc.html#cb1175-3"></a>trims &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.05</span>, <span class="fl">0.1</span>, <span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.4</span>)</span>
<span id="cb1175-4"><a href="p-advfunc.html#cb1175-4"></a><span class="kw">map_dbl</span>(trims, <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(<span class="dt">x=</span>x, <span class="dt">trims=</span>.))</span></code></pre></div>
<pre><code>## [1] 0.7271278 0.7271278 0.7271278 0.7271278 0.7271278</code></pre>
<p>可以用<code>pmap()</code>的列表元素名自动对应到调用函数形参名的方法：</p>
<div class="sourceCode" id="cb1177"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1177-1"><a href="p-advfunc.html#cb1177-1"></a><span class="kw">pmap_dbl</span>(<span class="kw">list</span>(<span class="dt">trims =</span> trims), mean, <span class="dt">x=</span>x)</span></code></pre></div>
<pre><code>## [1] 0.7271278 0.7271278 0.7271278 0.7271278 0.7271278</code></pre>
<p>或：</p>
<div class="sourceCode" id="cb1179"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1179-1"><a href="p-advfunc.html#cb1179-1"></a><span class="kw">pmap_dbl</span>(<span class="kw">list</span>(<span class="dt">trims =</span> trims), <span class="op">~</span><span class="st"> </span><span class="kw">mean</span>(x))</span></code></pre></div>
<pre><code>## [1] 0.7271278 0.7271278 0.7271278 0.7271278 0.7271278</code></pre>
<p><code>pmap()</code>的变种有<code>ivoke_map(.f, .x, ...)</code>，
其中<code>.f</code>是一个元素为函数名的字符型向量，
<code>.x</code>是列表，
<code>.x</code>的每个元素是<code>.f</code>列表中对应的函数的参数。
如：</p>
<div class="sourceCode" id="cb1181"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1181-1"><a href="p-advfunc.html#cb1181-1"></a>sim &lt;-<span class="st"> </span><span class="kw">tribble</span>(</span>
<span id="cb1181-2"><a href="p-advfunc.html#cb1181-2"></a>  <span class="op">~</span>f,      <span class="op">~</span>params,</span>
<span id="cb1181-3"><a href="p-advfunc.html#cb1181-3"></a>  <span class="st">&quot;runif&quot;</span>, <span class="kw">list</span>(<span class="dt">min =</span> <span class="dv">-1</span>, <span class="dt">max =</span> <span class="dv">1</span>),</span>
<span id="cb1181-4"><a href="p-advfunc.html#cb1181-4"></a>  <span class="st">&quot;rnorm&quot;</span>, <span class="kw">list</span>(<span class="dt">sd =</span> <span class="dv">5</span>),</span>
<span id="cb1181-5"><a href="p-advfunc.html#cb1181-5"></a>  <span class="st">&quot;rpois&quot;</span>, <span class="kw">list</span>(<span class="dt">lambda =</span> <span class="dv">10</span>)</span>
<span id="cb1181-6"><a href="p-advfunc.html#cb1181-6"></a>)</span>
<span id="cb1181-7"><a href="p-advfunc.html#cb1181-7"></a>sim <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb1181-8"><a href="p-advfunc.html#cb1181-8"></a><span class="st">  </span><span class="kw">mutate</span>(<span class="dt">sim =</span> <span class="kw">invoke_map</span>(f, params, <span class="dt">n =</span> <span class="dv">10</span>))</span></code></pre></div>
<pre><code>## # A tibble: 3 x 3
##   f     params           sim       
##   &lt;chr&gt; &lt;list&gt;           &lt;list&gt;    
## 1 runif &lt;named list [2]&gt; &lt;dbl [10]&gt;
## 2 rnorm &lt;named list [1]&gt; &lt;dbl [10]&gt;
## 3 rpois &lt;named list [1]&gt; &lt;int [10]&gt;</code></pre>
<p>这里利用了tibble类型的高级功能：
某一列可以是列表类型，
然后列表元素有可以是列表、向量等复合类型。</p>
<p>基本R的<code>Map()</code>函数提供了类似的功能，
但是不允许多个自变量中有长度为1的；
基本R的<code>mapply()</code>函数与<code>Map()</code>类似，
但是会像<code>sapply()</code>函数那样试图自动找到最简化的输出数据结构，
这在通用程序中会使得结果不可控。</p>
</div>
</div>
<div id="p-advfunc-fnctnl-reduce" class="section level3">
<h3><span class="header-section-number">19.7.3</span> purrr包中<code>reduce</code>类函数</h3>
<div id="p-advfunc-fnctnl-reduce-reduce" class="section level4">
<h4><span class="header-section-number">19.7.3.1</span> <code>reduce</code>函数</h4>
<p>许多二元运算符如加法、乘法，
可以很自然地推广到多个运算元之间的运算，
变成连加、连乘积等等。
某些常用的操作已经变成了R函数，
比如<code>sum()</code>、<code>prod()</code>，
但是其它一些运算，
包括用函数表示的运算，
也需要推广到对多个进行，
比如<code>intersect(x, y)</code>求两个变量的交集，
希望能推广到求多个变量的交集。</p>
<p>purrr包的<code>reduce</code>函数把输入列表（或向量）的元素逐次地用给定的函数进行合并计算。
比如，设<code>f(x,y)</code>是一个二元函数，
设<code>z</code>是有4个元素的列表，
则<code>reduce(z, f)</code>表示</p>
<div class="sourceCode" id="cb1183"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1183-1"><a href="p-advfunc.html#cb1183-1"></a><span class="kw">f</span>(<span class="kw">f</span>(<span class="kw">f</span>(z[[<span class="dv">1</span>]], z[[<span class="dv">2</span>]]), z[[<span class="dv">3</span>]]), z[[<span class="dv">4</span>]])</span></code></pre></div>
<p>例如，</p>
<div class="sourceCode" id="cb1184"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1184-1"><a href="p-advfunc.html#cb1184-1"></a><span class="kw">reduce</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>, <span class="st">`</span><span class="dt">+</span><span class="st">`</span>)</span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<p>实际执行的是<span class="math inline">\((((1 + 2) + 3) + 4)\)</span>。
当然，求<span class="math inline">\(1:4\)</span>的和只需要<code>sum(1:4)</code>，
但是<code>reduce</code>可以对元素为复杂类型的列表进行逐项合并计算。</p>
<p>考虑多个集合的交集的问题。
下面的例子产生了4个集合，
然后反复调用<code>intersect()</code>求出了交集：</p>
<div class="sourceCode" id="cb1186"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1186-1"><a href="p-advfunc.html#cb1186-1"></a><span class="kw">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb1186-2"><a href="p-advfunc.html#cb1186-2"></a>x &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">4</span>, <span class="kw">sample</span>(</span>
<span id="cb1186-3"><a href="p-advfunc.html#cb1186-3"></a>  <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">size=</span><span class="dv">5</span>, <span class="dt">replace=</span><span class="ot">TRUE</span>), <span class="dt">simplify=</span><span class="ot">FALSE</span>); x</span></code></pre></div>
<pre><code>## [[1]]
## [1] 2 3 1 3 1
## 
## [[2]]
## [1] 1 5 3 3 2
## 
## [[3]]
## [1] 5 4 2 5 3
## 
## [[4]]
## [1] 1 4 3 2 5</code></pre>
<div class="sourceCode" id="cb1188"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1188-1"><a href="p-advfunc.html#cb1188-1"></a><span class="kw">intersect</span>(<span class="kw">intersect</span>(<span class="kw">intersect</span>(x[[<span class="dv">1</span>]], x[[<span class="dv">2</span>]]), x[[<span class="dv">3</span>]]), x[[<span class="dv">4</span>]])</span></code></pre></div>
<pre><code>## [1] 2 3</code></pre>
<p>也可以用magrittr包的%&gt;%符号写成:</p>
<div class="sourceCode" id="cb1190"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1190-1"><a href="p-advfunc.html#cb1190-1"></a>x[[<span class="dv">1</span>]] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">intersect</span>(x[[<span class="dv">2</span>]]) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">intersect</span>(x[[<span class="dv">3</span>]]) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">intersect</span>(x[[<span class="dv">4</span>]])</span></code></pre></div>
<pre><code>## [1] 2 3</code></pre>
<p>还可以写成循环:</p>
<div class="sourceCode" id="cb1192"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1192-1"><a href="p-advfunc.html#cb1192-1"></a>y &lt;-<span class="st"> </span>x[[<span class="dv">1</span>]]</span>
<span id="cb1192-2"><a href="p-advfunc.html#cb1192-2"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">4</span>) y &lt;-<span class="st"> </span><span class="kw">intersect</span>(y, x[[i]])</span>
<span id="cb1192-3"><a href="p-advfunc.html#cb1192-3"></a>y</span></code></pre></div>
<pre><code>## [1] 2 3</code></pre>
<p>都比较繁琐。</p>
<p>利用purrr包的<code>reduce</code>函数，只要写成</p>
<div class="sourceCode" id="cb1194"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1194-1"><a href="p-advfunc.html#cb1194-1"></a><span class="kw">reduce</span>(x, intersect)</span></code></pre></div>
<pre><code>## [1] 2 3</code></pre>
<p>泛函的好处是需要进行的变换或计算是作为参数输入的，
只要输入其它函数就可以改变要做的计算，
比如，
变成求各个集合的并集：</p>
<div class="sourceCode" id="cb1196"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1196-1"><a href="p-advfunc.html#cb1196-1"></a><span class="kw">reduce</span>(x, union)</span></code></pre></div>
<pre><code>## [1] 2 3 1 5 4</code></pre>
<p><code>reduce()</code>支持<code>...</code>参数，
所以可以给要调用的函数额外的自变量或选项。</p>
<p><code>reduce</code>函数对多个输入默认从左向右计算，
可以用<code>.dir = "backward"</code>选项东球从右向左合并。</p>
<p>可以用选项<code>.init</code>给出合并初值，
在通用程序中使用<code>reduce()</code>时应该提供此选项，
这样如果输入了零长度数据，
可以有一个默认的返回值；
输入非零长度数据时，
此初值作为第一个元素之前的值参与计算，
所以一定要取为与要进行的运算一致的值，
比如连加的初始值自然为0，
连乘积的初始值自然为1，
多个集合交集的初始值为全集（所有参与运算的各个集合应为此初值的子集），
等等。</p>
<p>基本R的<code>Reduce()</code>函数提供了类似<code>purrr:reduce()</code>的功能，
不支持<code>...</code>参数。</p>
</div>
<div id="p-advfunc-fnctnl-reduce-reduce2" class="section level4">
<h4><span class="header-section-number">19.7.3.2</span> <code>reduce2</code>函数</h4>
<p><code>reduce2(x, y, f)</code>中的<code>x</code>是要进行连续运算的数据列表或向量，
而<code>y</code>是给这些运算提供不同的参数。
如果没有<code>.init</code>初始值，
<code>f</code>仅需调用<code>length(x)-1</code>次，
所以<code>y</code>仅需要有<code>length(x)-1</code>个元素；
如果有<code>.init</code>初始值，
<code>f</code>需要调用<code>length(x)</code>次，
<code>y</code>也需要与<code>x</code>等长。</p>
</div>
<div id="p-advfunc-fnctnl-reduce-accumulate" class="section level4">
<h4><span class="header-section-number">19.7.3.3</span> <code>accumulate</code>函数</h4>
<p>对于加法，
R的<code>sum()</code>函数可以计算连加，
而<code>cumsum()</code>函数可以计算逐步的连加。如：</p>
<div class="sourceCode" id="cb1198"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1198-1"><a href="p-advfunc.html#cb1198-1"></a><span class="kw">sum</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] 10</code></pre>
<div class="sourceCode" id="cb1200"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1200-1"><a href="p-advfunc.html#cb1200-1"></a><span class="kw">cumsum</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1]  1  3  6 10</code></pre>
<p><code>purrr::reduce()</code>将连加推广到了其它的二元运算，
<code>purrr::accumulate()</code>则类似<code>cumsum()</code>的推广。</p>
<p>例如，对前面例子中的4个集合，
计算逐步的并集，
结果的第一项保持原来的第一项不变：</p>
<div class="sourceCode" id="cb1202"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1202-1"><a href="p-advfunc.html#cb1202-1"></a><span class="kw">accumulate</span>(x, union)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 2 3 1 3 1
## 
## [[2]]
## [1] 2 3 1 5
## 
## [[3]]
## [1] 2 3 1 5 4
## 
## [[4]]
## [1] 2 3 1 5 4</code></pre>
<p>将上述结果简化显示：</p>
<div class="sourceCode" id="cb1204"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1204-1"><a href="p-advfunc.html#cb1204-1"></a><span class="kw">accumulate</span>(x, union) <span class="op">%&gt;%</span></span>
<span id="cb1204-2"><a href="p-advfunc.html#cb1204-2"></a><span class="st">  </span><span class="kw">map</span>(<span class="op">~</span><span class="kw">sort</span>(<span class="kw">unique</span>(.)))</span></code></pre></div>
<pre><code>## [[1]]
## [1] 1 2 3
## 
## [[2]]
## [1] 1 2 3 5
## 
## [[3]]
## [1] 1 2 3 4 5
## 
## [[4]]
## [1] 1 2 3 4 5</code></pre>
</div>
<div id="p-advfunc-fnctnl-reduce-mapreduce" class="section level4">
<h4><span class="header-section-number">19.7.3.4</span> Map-reduce算法</h4>
<p>Map-reduce是大数据技术中的重要算法，
在Hadoop分布式数据库中主要使用此算法思想。
将数据分散存储在不同计算节点中，
将需要的操作先映射到每台计算节点，
进行信息提取压缩，
最后用reduce的思想将不同节点的信息整合在一起。</p>
</div>
</div>
<div id="p-advfunc-fnctnl-pred" class="section level3">
<h3><span class="header-section-number">19.7.4</span> purrr包中使用示性函数的泛函</h3>
<p>返回逻辑向量的函数称为示性函数，
R中有许多<code>is.xxx</code>函数都是示性函数(predicate functions)。
示性函数本身不是泛函，
但是它们可以作为泛函的输入。</p>
<p>purrr包提供了如下的以示性函数函数为输入的泛函：</p>
<ul>
<li><code>some(.x, .p)</code>，对数据列表或向量<code>.x</code>的每一个元素用<code>.p</code>判断，
只要至少有一个为真，结果就为真；
<code>every(.x, .p)</code>与<code>some</code>类似，但需要所有元素的结果都为真结果才为真。
这些函数与<code>any(map_lgl(.x, .p))</code>和<code>all(map_lgl(.x, .p))</code>类似，
但是只要在遍历过程中能提前确定返回值就提前结束计算，
比如<code>some</code>只要遇到一个真值就不再继续判断，
<code>every</code>只要遇到一个价值就不再继续判断。</li>
<li><code>detect(.x, .p)</code>返回数据<code>.x</code>的元素中第一个用<code>.p</code>判断为真的元素值，
而<code>detect_index(.x, .p)</code>返回第一个为真的下标值。</li>
<li><code>keep(.x, .p)</code>选取数据<code>.x</code>的元素中用<code>.p</code>判断为真的元素的子集；
<code>discard(.x, .p)</code>返回不满足条件的元素子集。</li>
</ul>
<p>例如，判断数据框中有无因子类型的列：</p>
<div class="sourceCode" id="cb1206"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1206-1"><a href="p-advfunc.html#cb1206-1"></a><span class="kw">some</span>(d.class, is.factor)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>判断数据框是否完全由数值型列组成：</p>
<div class="sourceCode" id="cb1208"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1208-1"><a href="p-advfunc.html#cb1208-1"></a><span class="kw">every</span>(d.class, is.numeric)</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>返回向量中的第一个超过100的元素的值：</p>
<div class="sourceCode" id="cb1210"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1210-1"><a href="p-advfunc.html#cb1210-1"></a><span class="kw">detect</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">77</span>, <span class="dv">105</span>, <span class="dv">99</span>, <span class="dv">123</span>), <span class="op">~</span><span class="st"> </span>. <span class="op">&gt;=</span><span class="st"> </span><span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 105</code></pre>
<p>返回向量中的第一个超过100的元素的下标：</p>
<div class="sourceCode" id="cb1212"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1212-1"><a href="p-advfunc.html#cb1212-1"></a><span class="kw">detect_index</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">77</span>, <span class="dv">105</span>, <span class="dv">99</span>, <span class="dv">123</span>),</span>
<span id="cb1212-2"><a href="p-advfunc.html#cb1212-2"></a>  <span class="op">~</span><span class="st"> </span>. <span class="op">&gt;=</span><span class="st"> </span><span class="dv">100</span>)</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
<p>对于上一个例子，<code>which(x &gt;= 100)</code>可以返回所有满足条件的元素的下标。</p>
<p>下面的例子筛选出数据框的数值型列，
并用<code>map_dbl</code>求每列的平方和：</p>
<div class="sourceCode" id="cb1214"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1214-1"><a href="p-advfunc.html#cb1214-1"></a>d.class <span class="op">%&gt;%</span></span>
<span id="cb1214-2"><a href="p-advfunc.html#cb1214-2"></a><span class="st">  </span><span class="kw">keep</span>(is.numeric) <span class="op">%&gt;%</span></span>
<span id="cb1214-3"><a href="p-advfunc.html#cb1214-3"></a><span class="st">  </span><span class="kw">map_dbl</span>(<span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(. <span class="op">^</span><span class="st"> </span><span class="dv">2</span>))</span></code></pre></div>
<pre><code>##       age    height    weight 
##   3409.00  74304.92 199435.75</code></pre>
<p>从数据框（或列表）中选一部分满足某种条件的子集进行变换是常用的做法，
所以<code>map</code>提供了<code>map_if()</code>和<code>modify_if()</code>变种，
允许输入一个示性函数，
对满足条件的子集才应用输入的变换函数进行处理，
输入数据中其它元素原样返回。
<code>map_if</code>返回列表，
<code>modify_if</code>返回与输入数据相同类型的输出。
例如，
将数据框中数值型列除以100， 其它列保持不变：</p>
<div class="sourceCode" id="cb1216"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1216-1"><a href="p-advfunc.html#cb1216-1"></a><span class="kw">modify_if</span>(d.class, is.numeric, <span class="st">`</span><span class="dt">/</span><span class="st">`</span>, <span class="dv">100</span>)</span></code></pre></div>
<pre><code>## # A tibble: 19 x 5
##    name    sex     age height weight
##    &lt;chr&gt;   &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 Alice   F      0.13  0.565  0.84 
##  2 Becka   F      0.13  0.653  0.98 
##  3 Gail    F      0.14  0.643  0.9  
##  4 Karen   F      0.12  0.563  0.77 
##  5 Kathy   F      0.12  0.598  0.845
##  6 Mary    F      0.15  0.665  1.12 
##  7 Sandy   F      0.11  0.513  0.505
##  8 Sharon  F      0.15  0.625  1.12 
##  9 Tammy   F      0.14  0.628  1.02 
## 10 Alfred  M      0.14  0.69   1.12 
## 11 Duke    M      0.14  0.635  1.02 
## 12 Guido   M      0.15  0.67   1.33 
## 13 James   M      0.12  0.573  0.83 
## 14 Jeffrey M      0.13  0.625  0.84 
## 15 John    M      0.12  0.59   0.995
## 16 Philip  M      0.16  0.72   1.5  
## 17 Robert  M      0.12  0.648  1.28 
## 18 Thomas  M      0.11  0.575  0.85 
## 19 William M      0.15  0.665  1.12</code></pre>
<p>基本R的<code>Find</code>函数与<code>detect</code>作用类似，
<code>Position</code>与<code>detect_index</code>作用类似，
<code>Filter</code>函数与<code>keep</code>作用类似。</p>
</div>
<div id="p-advfunc-fnctnl-lapp" class="section level3">
<h3><span class="header-section-number">19.7.5</span> 基本R的函数式编程支持</h3>
<p>使用purrr包的泛函的好处是用法风格一致，
有许多方便功能。
对于少量的使用泛函的需求，
在不想使用purrr包的情况下，
可以使用基本R中的类似功能。</p>
<p>基本R的<code>apply</code>函数可以对矩阵的每行或每列进行计算，
或对多维向量的某个维度进行计算。
参见<a href="prog-type-matrix.html#p-t-array-apply">12.6</a>。</p>
<p>基本R中的<code>integrate</code>、<code>uniroot</code>、<code>optim</code>、<code>omptimize</code>等函数也需要输入函数，
但主要用于数学计算，
与一般的函数式编程关系不大。</p>
<p>基本R<code>lapply</code>函数用输入的函数对数据的每个元素进行变换，格式为</p>
<div class="sourceCode" id="cb1218"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1218-1"><a href="p-advfunc.html#cb1218-1"></a><span class="kw">lapply</span>(X, FUN, ...)</span></code></pre></div>
<p>其中<code>X</code>是一个列表或向量，
<code>FUN</code>是一个函数（可以是有名或无名函数），
结果也总是一个列表，
结果列表的第<span class="math inline">\(i\)</span>个元素是将<code>X</code>的第<span class="math inline">\(i\)</span>个元素输入到<code>FUN</code>中的返回结果。
<code>...</code>参数会输入到<code>FUN</code>中。
这与<code>purrr::map()</code>功能类似。</p>
<p><code>sapply</code>与<code>lapply</code>函数类似，
但是<code>sapply</code>试图简化输出结果为向量或矩阵，
在不可行时才和<code>lapply</code>返回列表结果。
如果<code>X</code>长度为零，结果是长度为零的列表；
如果<code>FUN(X[i])</code>都是长度为1的结果，
<code>sapply()</code>结果是一个向量；
如果<code>FUN(X[i])</code>都是长度相同且长度大于1的向量，
<code>sapply()</code>结果是一个矩阵，
矩阵的第<span class="math inline">\(i\)</span>列保存<code>FUN(X[i])</code>的结果。
因为<code>sapply()</code>的结果类型的不确定性，
在自定义函数中应慎用。</p>
<p><code>vapply()</code>函数与<code>sapply()</code>函数类似，
但是它需要第三个参数即<code>函数</code>返回值类型的例子，格式为</p>
<div class="sourceCode" id="cb1219"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1219-1"><a href="p-advfunc.html#cb1219-1"></a><span class="kw">vapply</span>(X, FUN, FUN.VALUE, ...)</span></code></pre></div>
<p>其中<code>FUN.VALUE</code>是每个<code>FUN(X[i])</code>的返回值的例子，
要求所有<code>FUN(X[i])</code>结果类型和长度相同。</p>
<p>例如，求<code>d.class</code>每一列类型的问题，用lapply，写成：</p>
<div class="sourceCode" id="cb1220"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1220-1"><a href="p-advfunc.html#cb1220-1"></a><span class="kw">lapply</span>(d.class, typeof)</span></code></pre></div>
<pre><code>## $name
## [1] &quot;character&quot;
## 
## $sex
## [1] &quot;character&quot;
## 
## $age
## [1] &quot;double&quot;
## 
## $height
## [1] &quot;double&quot;
## 
## $weight
## [1] &quot;double&quot;</code></pre>
<p><code>lapply</code>的结果总是列表。
<code>sapply</code>会尽可能将结果简化为向量或矩阵，如：</p>
<div class="sourceCode" id="cb1222"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1222-1"><a href="p-advfunc.html#cb1222-1"></a><span class="kw">sapply</span>(d.class, typeof)</span></code></pre></div>
<pre><code>##        name         sex         age      height      weight 
## &quot;character&quot; &quot;character&quot;    &quot;double&quot;    &quot;double&quot;    &quot;double&quot;</code></pre>
<p>或使用<code>vapply()</code>:</p>
<div class="sourceCode" id="cb1224"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1224-1"><a href="p-advfunc.html#cb1224-1"></a><span class="kw">vapply</span>(d.class, typeof, <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<pre><code>##        name         sex         age      height      weight 
## &quot;character&quot; &quot;character&quot;    &quot;double&quot;    &quot;double&quot;    &quot;double&quot;</code></pre>
<p><code>vapply</code>可以处理遍历时每次调用的函数返回值不是标量的情形，
结果为矩阵，
purrr包的<code>map_dbl</code>等只能处理调用的函数返回值是标量的情形。</p>
<p>R提供了 <code>Map</code>, <code>Reduce</code>, <code>Filter</code>, <code>Find</code>,
<code>Negate</code>, <code>Position</code>等支持函数式编程的泛函。</p>
<p><code>Map()</code>与<code>purrr::map</code>、<code>purrr::pmap</code>功能类似，
以一个函数作为参数，
可以对其它参数的每一对应元素进行变换，
结果为列表。</p>
<p>例如，
对数据框<code>d</code>，
如下的程序可以计算每列的平方和：</p>
<div class="sourceCode" id="cb1226"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1226-1"><a href="p-advfunc.html#cb1226-1"></a>d &lt;-<span class="st"> </span><span class="kw">data.frame</span>(</span>
<span id="cb1226-2"><a href="p-advfunc.html#cb1226-2"></a>  <span class="dt">x =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">2</span>),</span>
<span id="cb1226-3"><a href="p-advfunc.html#cb1226-3"></a>  <span class="dt">y =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">9</span>))</span>
<span id="cb1226-4"><a href="p-advfunc.html#cb1226-4"></a><span class="kw">Map</span>(<span class="cf">function</span>(x) <span class="kw">sum</span>(x<span class="op">^</span><span class="dv">2</span>), d)</span></code></pre></div>
<pre><code>## $x
## [1] 54
## 
## $y
## [1] 115</code></pre>
<p>实际上，这个例子也可以用<code>lapply()</code>改写成</p>
<div class="sourceCode" id="cb1228"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1228-1"><a href="p-advfunc.html#cb1228-1"></a><span class="kw">lapply</span>(d, <span class="cf">function</span>(x) <span class="kw">sum</span>(x<span class="op">^</span><span class="dv">2</span>))</span></code></pre></div>
<pre><code>## $x
## [1] 54
## 
## $y
## [1] 115</code></pre>
<p><code>Map()</code>比<code>lapply()</code>增强的地方在于它允许对多个列表的对应元素逐一处理。
例如，为了求出<code>d</code>中每一行的最大值，可以用</p>
<div class="sourceCode" id="cb1230"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1230-1"><a href="p-advfunc.html#cb1230-1"></a><span class="kw">Map</span>(max, d<span class="op">$</span>x, d<span class="op">$</span>y)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 3
## 
## [[2]]
## [1] 7
## 
## [[3]]
## [1] 9</code></pre>
<p>可以用<code>unlist()</code>函数将列表结果转换为向量，如</p>
<div class="sourceCode" id="cb1232"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1232-1"><a href="p-advfunc.html#cb1232-1"></a><span class="kw">unlist</span>(<span class="kw">Map</span>(max, d<span class="op">$</span>x, d<span class="op">$</span>y))</span></code></pre></div>
<pre><code>## [1] 3 7 9</code></pre>
<p><code>mapply()</code>函数与<code>Map()</code>类似，
但是可以自动简化结果类型，
可以看成是<code>sapply()</code>推广到了可以对多个输入的对应元素逐项处理。
<code>mapply()</code>可以用参数<code>MoreArgs</code>指定逐项处理时一些共同的参数。
如</p>
<div class="sourceCode" id="cb1234"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1234-1"><a href="p-advfunc.html#cb1234-1"></a><span class="kw">mapply</span>(max, d<span class="op">$</span>x, d<span class="op">$</span>y)</span></code></pre></div>
<pre><code>## [1] 3 7 9</code></pre>
<p>当<code>d</code>数据框有多列时为了求每行的最大值，
可以用<code>Reduce</code>函数将两两求最大值的运算推广到多个之间的运算。</p>
<p><code>Reduce</code>函数功能与<code>purrr::reduce</code>类似，
把输入列表（或向量）的元素逐次地用给定的函数进行合并计算。</p>
<p>例如，求四个集合的交集：</p>
<div class="sourceCode" id="cb1236"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1236-1"><a href="p-advfunc.html#cb1236-1"></a><span class="kw">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb1236-2"><a href="p-advfunc.html#cb1236-2"></a>x &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">4</span>, <span class="kw">sample</span>(</span>
<span id="cb1236-3"><a href="p-advfunc.html#cb1236-3"></a>  <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dt">size=</span><span class="dv">5</span>, <span class="dt">replace=</span><span class="ot">TRUE</span>), <span class="dt">simplify=</span><span class="ot">FALSE</span>); x</span></code></pre></div>
<pre><code>## [[1]]
## [1] 2 3 1 3 1
## 
## [[2]]
## [1] 1 5 3 3 2
## 
## [[3]]
## [1] 5 4 2 5 3
## 
## [[4]]
## [1] 1 4 3 2 5</code></pre>
<div class="sourceCode" id="cb1238"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1238-1"><a href="p-advfunc.html#cb1238-1"></a><span class="kw">Reduce</span>(intersect, x)</span></code></pre></div>
<pre><code>## [1] 2 3</code></pre>
<p><code>Reduce</code>函数对多个输入默认从左向右计算，
可以用<code>right</code>参数选择是否从右向左合并。
参数<code>init</code>给出合并初值，
参数<code>accumulate</code>要求保留每一步合并的结果（累计）。
这个函数可以把很多仅适用于两个运算元的运算推广到多个参数的情形。</p>
<p><code>Filter(f, x)</code>与<code>purrr::keep</code>作用类似，
用一个示性函数<code>f</code>作为筛选规则，
从列表或向量<code>x</code>中筛选出用<code>f</code>作用后为真值的元素子集。
例如</p>
<div class="sourceCode" id="cb1240"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1240-1"><a href="p-advfunc.html#cb1240-1"></a>f &lt;-<span class="st"> </span><span class="cf">function</span>(x) x <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1240-2"><a href="p-advfunc.html#cb1240-2"></a><span class="kw">Filter</span>(f, <span class="kw">c</span>(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] 0.5 0.8</code></pre>
<p>当然，这样的简单例子完全可以改写成：</p>
<div class="sourceCode" id="cb1242"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1242-1"><a href="p-advfunc.html#cb1242-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="op">-</span><span class="fl">0.5</span>, <span class="fl">0.5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>)</span>
<span id="cb1242-2"><a href="p-advfunc.html#cb1242-2"></a>x[x<span class="op">&gt;</span><span class="dv">0</span> <span class="op">&amp;</span><span class="st"> </span>x <span class="op">&lt;</span><span class="st"> </span><span class="dv">1</span>]</span></code></pre></div>
<pre><code>## [1] 0.5 0.8</code></pre>
<p>但是，对于比较复杂类型的判断，
比如当<code>x</code>是列表且其元素本身也是复合类型的时候，
就需要把判断写成一个函数，
然后可以用<code>Filter</code>比较简单地表达按照判断规则取子集的操作。</p>
<p><code>Find()</code>功能与<code>purrr::detect</code>类似，
返回满足条件的第一个元素，
也可以用参数<code>right=TRUE</code>要求返回满足条件的最后一个。</p>
<p><code>Position()</code>功能与<code>purrr::detect_index</code>类似，
返回第一个满足条件的元素所在的下标位置。</p>
</div>
<div id="p-advfunc-fnctnl-udef" class="section level3">
<h3><span class="header-section-number">19.7.6</span> 自定义泛函</h3>
<p>用户也可以自定义泛函。
比如，希望对一个数据框中所有的数值型变量计算某些统计量，
要计算的统计量由用户决定而不是由此自定义函数决定，
输入的函数的结果总是数值型向量，
编写自定义的泛函为：</p>
<div class="sourceCode" id="cb1244"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1244-1"><a href="p-advfunc.html#cb1244-1"></a>summary.df.numeric &lt;-<span class="st"> </span><span class="cf">function</span>(df, FUN, ...){</span>
<span id="cb1244-2"><a href="p-advfunc.html#cb1244-2"></a>  <span class="kw">sapply</span>(<span class="kw">Filter</span>(is.numeric, df), FUN, ...)</span>
<span id="cb1244-3"><a href="p-advfunc.html#cb1244-3"></a>}</span></code></pre></div>
<p>这里参数<code>FUN</code>是用来计算统计量的函数。
例如对d.class中每个数值型变量计算最小值：</p>
<div class="sourceCode" id="cb1245"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1245-1"><a href="p-advfunc.html#cb1245-1"></a>d.class &lt;-<span class="st"> </span>readr<span class="op">::</span><span class="kw">read_csv</span>(<span class="st">&quot;class.csv&quot;</span>)</span></code></pre></div>
<pre><code>## Parsed with column specification:
## cols(
##   name = col_character(),
##   sex = col_character(),
##   age = col_double(),
##   height = col_double(),
##   weight = col_double()
## )</code></pre>
<div class="sourceCode" id="cb1247"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1247-1"><a href="p-advfunc.html#cb1247-1"></a><span class="kw">summary.df.numeric</span>(d.class, summary, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>##              age   height   weight
## Min.    11.00000 51.30000  50.5000
## 1st Qu. 12.00000 58.25000  84.2500
## Median  13.00000 62.80000  99.5000
## Mean    13.31579 62.33684 100.0263
## 3rd Qu. 14.50000 65.90000 112.2500
## Max.    16.00000 72.00000 150.0000</code></pre>
<p>为了说明上面定义的泛函是如何对数据框进行处理的，
我们对其进行如下的改写：</p>
<div class="sourceCode" id="cb1249"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1249-1"><a href="p-advfunc.html#cb1249-1"></a>summary.df.numeric2 &lt;-<span class="st"> </span><span class="cf">function</span>(df, FUN, ...){</span>
<span id="cb1249-2"><a href="p-advfunc.html#cb1249-2"></a>  res &lt;-<span class="st"> </span><span class="kw">c</span>()</span>
<span id="cb1249-3"><a href="p-advfunc.html#cb1249-3"></a>  nd &lt;-<span class="st"> </span><span class="kw">c</span>()</span>
<span id="cb1249-4"><a href="p-advfunc.html#cb1249-4"></a>  <span class="cf">for</span>(j <span class="cf">in</span> <span class="kw">seq_along</span>(df)){</span>
<span id="cb1249-5"><a href="p-advfunc.html#cb1249-5"></a>    <span class="cf">if</span>(<span class="kw">is.numeric</span>(df[[j]])){</span>
<span id="cb1249-6"><a href="p-advfunc.html#cb1249-6"></a>      resj &lt;-<span class="st"> </span><span class="kw">FUN</span>(df[[j]], ...) <span class="co"># 这里！</span></span>
<span id="cb1249-7"><a href="p-advfunc.html#cb1249-7"></a>      res &lt;-<span class="st"> </span><span class="kw">cbind</span>(res, resj)</span>
<span id="cb1249-8"><a href="p-advfunc.html#cb1249-8"></a>      nd &lt;-<span class="st"> </span><span class="kw">cbind</span>(nd, <span class="kw">names</span>(df)[j])</span>
<span id="cb1249-9"><a href="p-advfunc.html#cb1249-9"></a>    }</span>
<span id="cb1249-10"><a href="p-advfunc.html#cb1249-10"></a>  }</span>
<span id="cb1249-11"><a href="p-advfunc.html#cb1249-11"></a>  <span class="cf">if</span>(<span class="kw">ncol</span>(res)<span class="op">&gt;</span><span class="dv">0</span>) {</span>
<span id="cb1249-12"><a href="p-advfunc.html#cb1249-12"></a>    <span class="kw">colnames</span>(res) &lt;-<span class="st"> </span>nd</span>
<span id="cb1249-13"><a href="p-advfunc.html#cb1249-13"></a>    <span class="cf">if</span>(<span class="kw">nrow</span>(res) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>) {</span>
<span id="cb1249-14"><a href="p-advfunc.html#cb1249-14"></a>      res &lt;-<span class="st"> </span><span class="kw">c</span>(res)</span>
<span id="cb1249-15"><a href="p-advfunc.html#cb1249-15"></a>      <span class="kw">names</span>(res) &lt;-<span class="st"> </span>nd</span>
<span id="cb1249-16"><a href="p-advfunc.html#cb1249-16"></a>    }</span>
<span id="cb1249-17"><a href="p-advfunc.html#cb1249-17"></a>  }</span>
<span id="cb1249-18"><a href="p-advfunc.html#cb1249-18"></a>  res</span>
<span id="cb1249-19"><a href="p-advfunc.html#cb1249-19"></a>}</span>
<span id="cb1249-20"><a href="p-advfunc.html#cb1249-20"></a><span class="kw">summary.df.numeric2</span>(d.class, min, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>##    age height weight 
##   11.0   51.3   50.5</code></pre>
<div class="sourceCode" id="cb1251"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1251-1"><a href="p-advfunc.html#cb1251-1"></a><span class="kw">summary.df.numeric2</span>(d.class, summary, <span class="dt">na.rm=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>##              age   height   weight
## Min.    11.00000 51.30000  50.5000
## 1st Qu. 12.00000 58.25000  84.2500
## Median  13.00000 62.80000  99.5000
## Mean    13.31579 62.33684 100.0263
## 3rd Qu. 14.50000 65.90000 112.2500
## Max.    16.00000 72.00000 150.0000</code></pre>
</div>
</div>
<div id="p-advfunc-factory" class="section level2">
<h2><span class="header-section-number">19.8</span> 函数工厂</h2>
<p>函数的返回值可以是函数，
为此只要在函数内部定义嵌套函数并以嵌套函数为返回值。
返回函数的函数称为<strong>函数工厂</strong>，
函数工厂的输出结果称为一个闭包(closer)。
因为函数由形参表、函数体和定义环境三个部分组成，
函数工厂输出的闭包的定义环境是函数工厂的内部环境，
即函数工厂运行时产生的运行环境，
所以闭包包含了生产它的函数工厂的运行环境，
可以将闭包的一些状态信息保存在该环境中，
实现带有状态的函数。</p>
<p>基本R函数<code>approxfun</code>和<code>splinefun</code>就是以函数为输出的函数工厂。</p>
<div id="p-advfunc-factory-clex" class="section level3">
<h3><span class="header-section-number">19.8.1</span> 闭包例子</h3>
<p>利用函数工厂和闭包可以解决前面提出的记录函数已运行次数的问题。如</p>
<div class="sourceCode" id="cb1253"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1253-1"><a href="p-advfunc.html#cb1253-1"></a>f.gen &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1253-2"><a href="p-advfunc.html#cb1253-2"></a>  runTimes &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1253-3"><a href="p-advfunc.html#cb1253-3"></a></span>
<span id="cb1253-4"><a href="p-advfunc.html#cb1253-4"></a>  <span class="cf">function</span>(){</span>
<span id="cb1253-5"><a href="p-advfunc.html#cb1253-5"></a>    runTimes &lt;&lt;-<span class="st"> </span>runTimes <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1253-6"><a href="p-advfunc.html#cb1253-6"></a>    <span class="kw">print</span>(runTimes)</span>
<span id="cb1253-7"><a href="p-advfunc.html#cb1253-7"></a>  }</span>
<span id="cb1253-8"><a href="p-advfunc.html#cb1253-8"></a>}</span>
<span id="cb1253-9"><a href="p-advfunc.html#cb1253-9"></a>f &lt;-<span class="st"> </span><span class="kw">f.gen</span>()</span>
<span id="cb1253-10"><a href="p-advfunc.html#cb1253-10"></a><span class="kw">f</span>()</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb1255"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1255-1"><a href="p-advfunc.html#cb1255-1"></a><span class="kw">f</span>()</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>函数<code>f.gen</code>中定义了内嵌函数并以内嵌函数为输出，
<code>f.gen</code>是一个函数工厂,
其返回值是一个闭包，
闭包也是一个R函数，
这个返回值“绑定”(bind)到变量名<code>f</code>上，
所以<code>f</code>是一个函数。</p>
<p>调用函数<code>f</code>时用到变量<code>runTimes</code>，
用了<code>&lt;&lt;-</code>这种格式给这个变量赋值，
这样赋值的含义是在定义时的环境中逐层向上(向外，向父环境方向)查找变量是否存在，
在哪一层找到变量就给那里的变量赋值。
这样查找的结果是变量<code>runTimes</code>在<code>f.gen</code>的运行环境中。
调用<code>f</code>的时候<code>f.gen</code>已经结束运行了，
一般说来<code>f.gen</code>的运行环境应该已经不存在了；
但是，
函数的定义环境是随函数本身一同保存的，
因为函数工厂<code>f.gen</code>输出了函数<code>f</code>，
<code>f</code>的定义环境是<code>f.gen</code>的运行环境，
所以起到了把<code>f.gen</code>的运行环境保存在<code>f</code>中的效果，
而<code>f.gen</code>运行环境中的变量值<code>runTimes</code>也就保存在了函数<code>f</code>中，
可以持续被<code>f</code>访问，
不像<code>f</code>的局部变量那样每次运行结束就会被清除掉。</p>
<p>注意，
如果函数工厂生产出了两个闭包，
这两个闭包的定义环境是不同的，
因为生产时的运行环境是不同的。
例如，
生产两个计数器，
这两个计数器是分别计数的：</p>
<div class="sourceCode" id="cb1257"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1257-1"><a href="p-advfunc.html#cb1257-1"></a>c1 &lt;-<span class="st"> </span><span class="kw">f.gen</span>()</span>
<span id="cb1257-2"><a href="p-advfunc.html#cb1257-2"></a>c2 &lt;-<span class="st"> </span><span class="kw">f.gen</span>()</span>
<span id="cb1257-3"><a href="p-advfunc.html#cb1257-3"></a><span class="kw">c1</span>()</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb1259"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1259-1"><a href="p-advfunc.html#cb1259-1"></a><span class="kw">c1</span>()</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<div class="sourceCode" id="cb1261"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1261-1"><a href="p-advfunc.html#cb1261-1"></a><span class="kw">c2</span>()</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>下面是一个类似的函数工厂例子,
产生的闭包可以显示从上次调用到下次调用之间经过的时间：</p>
<div class="sourceCode" id="cb1263"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1263-1"><a href="p-advfunc.html#cb1263-1"></a>make_stop_watch &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1263-2"><a href="p-advfunc.html#cb1263-2"></a>  saved.time &lt;-<span class="st"> </span><span class="kw">proc.time</span>()[<span class="dv">3</span>]</span>
<span id="cb1263-3"><a href="p-advfunc.html#cb1263-3"></a>  </span>
<span id="cb1263-4"><a href="p-advfunc.html#cb1263-4"></a>  <span class="cf">function</span>(){</span>
<span id="cb1263-5"><a href="p-advfunc.html#cb1263-5"></a>    t1 &lt;-<span class="st"> </span><span class="kw">proc.time</span>()[<span class="dv">3</span>]</span>
<span id="cb1263-6"><a href="p-advfunc.html#cb1263-6"></a>    td &lt;-<span class="st"> </span>t1 <span class="op">-</span><span class="st"> </span>saved.time</span>
<span id="cb1263-7"><a href="p-advfunc.html#cb1263-7"></a>    saved.time &lt;&lt;-<span class="st"> </span>t1</span>
<span id="cb1263-8"><a href="p-advfunc.html#cb1263-8"></a>    <span class="kw">cat</span>(<span class="st">&quot;流逝时间（秒）：&quot;</span>, td, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb1263-9"><a href="p-advfunc.html#cb1263-9"></a>    <span class="kw">invisible</span>(td)</span>
<span id="cb1263-10"><a href="p-advfunc.html#cb1263-10"></a>  }</span>
<span id="cb1263-11"><a href="p-advfunc.html#cb1263-11"></a>}</span>
<span id="cb1263-12"><a href="p-advfunc.html#cb1263-12"></a>ticker &lt;-<span class="st"> </span><span class="kw">make_stop_watch</span>()</span>
<span id="cb1263-13"><a href="p-advfunc.html#cb1263-13"></a><span class="kw">ticker</span>()</span>
<span id="cb1263-14"><a href="p-advfunc.html#cb1263-14"></a><span class="co">## 流逝时间（秒）： 0 </span></span>
<span id="cb1263-15"><a href="p-advfunc.html#cb1263-15"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">1000</span>) <span class="kw">sort</span>(<span class="kw">runif</span>(<span class="dv">10000</span>))</span>
<span id="cb1263-16"><a href="p-advfunc.html#cb1263-16"></a><span class="kw">ticker</span>()</span>
<span id="cb1263-17"><a href="p-advfunc.html#cb1263-17"></a><span class="co">## 流逝时间（秒）： 1.53 </span></span></code></pre></div>
<p>其中<code>proc.time()</code>返回当前的R会话已运行的时间，
结果在MS Windows系统中有三个值，分别是用户时间、系统时间、流逝时间，
其中流逝时间比较客观。</p>
</div>
<div id="p-advfunc-factory-lazy" class="section level3">
<h3><span class="header-section-number">19.8.2</span> 动态查找和懒惰求值引起的问题</h3>
<p>上面的两个函数工厂都没有使用任何选项。
如果函数工厂有选项，
其中的选项值会被保存到生产出的闭包函数中，
但是因为懒惰求值规则的影响，
有可能调用闭包函数时才对选项求值，
如果保存选项的变量在生产和调用之间改变了值，
就会发生错误。</p>
<p>比如，
下面的函数工厂可以生产出进行幂变换的函数：</p>
<div class="sourceCode" id="cb1264"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1264-1"><a href="p-advfunc.html#cb1264-1"></a>make.pf &lt;-<span class="st"> </span><span class="cf">function</span>(power){</span>
<span id="cb1264-2"><a href="p-advfunc.html#cb1264-2"></a>  <span class="cf">function</span>(x) x<span class="op">^</span>power</span>
<span id="cb1264-3"><a href="p-advfunc.html#cb1264-3"></a>}</span>
<span id="cb1264-4"><a href="p-advfunc.html#cb1264-4"></a>p &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb1264-5"><a href="p-advfunc.html#cb1264-5"></a>square &lt;-<span class="st"> </span><span class="kw">make.pf</span>(p)</span>
<span id="cb1264-6"><a href="p-advfunc.html#cb1264-6"></a>p &lt;-<span class="st"> </span><span class="dv">3</span></span>
<span id="cb1264-7"><a href="p-advfunc.html#cb1264-7"></a><span class="kw">square</span>(<span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] 64</code></pre>
<p>在生产出<code>square</code>函数时，
选项<code>p</code>的值是2，
所以函数<code>square</code>应该是做平方变换的函数，
虽然在调用之前<code>p</code>的值被改成了3，
但是按理说不应该修改已经生产出来的<code>square</code>定义。
程序结果说明调用<code>square</code>时用的是<code>p=3</code>的值，
这是怎么回事？</p>
<p>R函数有懒惰求值规则，
在生产出<code>square</code>的哪一步，
因为并不需要实际计算<code>x^power</code>，
所以实参<code>p</code>的值并没有被计算，
而是将<code>square</code>的定义环境中的<code>power</code>指向了全局空间的变量<code>p</code>，
调用<code>square(4)</code>的时候才实际需要<code>power</code>的值，
这时<code>power</code>才求值，
其值为<code>p</code>的<strong>当前</strong>值。</p>
<p>避免这样的问题的办法是在函数工厂内用<code>force()</code>函数命令输入的参数当场求值而不是懒惰求值。
如：</p>
<div class="sourceCode" id="cb1266"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1266-1"><a href="p-advfunc.html#cb1266-1"></a>make.pf &lt;-<span class="st"> </span><span class="cf">function</span>(power){</span>
<span id="cb1266-2"><a href="p-advfunc.html#cb1266-2"></a>  <span class="kw">force</span>(power)</span>
<span id="cb1266-3"><a href="p-advfunc.html#cb1266-3"></a>  <span class="cf">function</span>(x) x<span class="op">^</span>power</span>
<span id="cb1266-4"><a href="p-advfunc.html#cb1266-4"></a>}</span>
<span id="cb1266-5"><a href="p-advfunc.html#cb1266-5"></a>p &lt;-<span class="st"> </span><span class="dv">2</span></span>
<span id="cb1266-6"><a href="p-advfunc.html#cb1266-6"></a>square &lt;-<span class="st"> </span><span class="kw">make.pf</span>(p)</span>
<span id="cb1266-7"><a href="p-advfunc.html#cb1266-7"></a>p &lt;-<span class="st"> </span><span class="dv">3</span></span>
<span id="cb1266-8"><a href="p-advfunc.html#cb1266-8"></a><span class="kw">square</span>(<span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] 16</code></pre>
<p>这个版本的程序结果正确。</p>
</div>
<div id="p-advfunc-factory-mem" class="section level3">
<h3><span class="header-section-number">19.8.3</span> 函数工厂的内存负担</h3>
<p>因为函数工厂生产出的闭包函数保存了函数工厂的运行环境，
如果这个运行环境很大，
就会造成较大的不必要的内存占用。
所以，
函数工厂内应尽量不要有占用大量内存的变量。
可以在函数工厂内用<code>rm()</code>删除不再使用的变量。</p>
</div>
<div id="p-advfunc-operator" class="section level3">
<h3><span class="header-section-number">19.8.4</span> 函数算子</h3>
<p>函数算子输入函数，输出函数，
通常用来对输入函数的行为进行改进或做细微的修改。
基本R的<code>Vectorize</code>函数输入一个函数，
将其改造成支持向量化的版本。</p>
<p>下面的<code>dot_every</code>函数输入一个函数，
将其改造为被循环调用时可以每调用一定次数就显示一个小数点，
这样可以用来显示循环的进度，
也适用于在<code>lapply</code>或<code>purrr::map</code>等函数调用时显示仅需。</p>
<div class="sourceCode" id="cb1268"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1268-1"><a href="p-advfunc.html#cb1268-1"></a>dot_every &lt;-<span class="st"> </span><span class="cf">function</span>(f, n) {</span>
<span id="cb1268-2"><a href="p-advfunc.html#cb1268-2"></a>  <span class="kw">force</span>(f)</span>
<span id="cb1268-3"><a href="p-advfunc.html#cb1268-3"></a>  <span class="kw">force</span>(n)</span>
<span id="cb1268-4"><a href="p-advfunc.html#cb1268-4"></a>  </span>
<span id="cb1268-5"><a href="p-advfunc.html#cb1268-5"></a>  i &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1268-6"><a href="p-advfunc.html#cb1268-6"></a>  <span class="cf">function</span>(...) {</span>
<span id="cb1268-7"><a href="p-advfunc.html#cb1268-7"></a>    i &lt;&lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1268-8"><a href="p-advfunc.html#cb1268-8"></a>    <span class="cf">if</span> (i <span class="op">%%</span><span class="st"> </span>n <span class="op">==</span><span class="st"> </span><span class="dv">0</span>) <span class="kw">cat</span>(<span class="st">&quot;.&quot;</span>)</span>
<span id="cb1268-9"><a href="p-advfunc.html#cb1268-9"></a>    <span class="kw">f</span>(...)</span>
<span id="cb1268-10"><a href="p-advfunc.html#cb1268-10"></a>  }</span>
<span id="cb1268-11"><a href="p-advfunc.html#cb1268-11"></a>}</span>
<span id="cb1268-12"><a href="p-advfunc.html#cb1268-12"></a>sim &lt;-<span class="st"> </span><span class="cf">function</span>(i){</span>
<span id="cb1268-13"><a href="p-advfunc.html#cb1268-13"></a>  x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1E6</span>)</span>
<span id="cb1268-14"><a href="p-advfunc.html#cb1268-14"></a>  <span class="kw">invisible</span>(<span class="kw">sort</span>(x))</span>
<span id="cb1268-15"><a href="p-advfunc.html#cb1268-15"></a>}</span>
<span id="cb1268-16"><a href="p-advfunc.html#cb1268-16"></a><span class="kw">walk</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">100</span>, <span class="kw">dot_every</span>(sim, <span class="dv">10</span>))</span></code></pre></div>
</div>
</div>
<div id="p-advfunc-env" class="section level2">
<h2><span class="header-section-number">19.9</span> 环境</h2>
<p>环境是R语言比较困难的概念，
一般用户也不需要了解环境就能很好地使用R，
也不影响自定义函数。
环境是支持变量作用域、命名空间、R6类型等功能的数据结构，
了解环境有助于更好地理解作用域等概念。</p>
<p>这部分内容主要来自<span class="citation">(Wickham <a href="#ref-Wickham2019:advanced-r-2ed" role="doc-biblioref">2019</a>)</span>相应章节。</p>
<div id="p-advfunc-env-def" class="section level3">
<h3><span class="header-section-number">19.9.1</span> 基本概念</h3>
<div id="p-advfunc-env-def-basics" class="section level4">
<h4><span class="header-section-number">19.9.1.1</span> 基本认识</h4>
<p>环境作为一个数据结构与有名的列表相似，
但是其中的名字必须都互不相同，
且没有次序（类似集合），
环境都有一个父环境，
修改环境内容时都不制作副本。</p>
<p>rlang扩展包可以比较方便地操作R的语法内容。
可以用<code>rlang::env()</code>生成新的环境，
这类似于<code>list()</code>函数的用法，
如：</p>
<div class="sourceCode" id="cb1269"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1269-1"><a href="p-advfunc.html#cb1269-1"></a>e1 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(</span>
<span id="cb1269-2"><a href="p-advfunc.html#cb1269-2"></a>  <span class="dt">a =</span> <span class="ot">FALSE</span>,</span>
<span id="cb1269-3"><a href="p-advfunc.html#cb1269-3"></a>  <span class="dt">b =</span> <span class="st">&quot;a&quot;</span>,</span>
<span id="cb1269-4"><a href="p-advfunc.html#cb1269-4"></a>  <span class="dt">c =</span> <span class="fl">2.3</span>,</span>
<span id="cb1269-5"><a href="p-advfunc.html#cb1269-5"></a>  <span class="dt">d =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>)</span></code></pre></div>
<p>环境的作用是将一系列的名字（变量名、函数名等）与R对象绑定起来，
即建立从名字到对象的对应关系，
不计次序。
对环境的修改是直接进行而不制作副本的。
如：</p>
<div class="sourceCode" id="cb1270"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1270-1"><a href="p-advfunc.html#cb1270-1"></a>e1<span class="op">$</span>e &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">x=</span><span class="dv">1</span>, <span class="dt">y=</span><span class="st">&quot;abcd&quot;</span>)</span></code></pre></div>
<p>显示环境，
只会显示一个地址信息，
对用户没有什么用处：</p>
<div class="sourceCode" id="cb1271"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1271-1"><a href="p-advfunc.html#cb1271-1"></a>e1</span>
<span id="cb1271-2"><a href="p-advfunc.html#cb1271-2"></a><span class="co">## &lt;environment: 0x000001d185e88860&gt;</span></span></code></pre></div>
<p>rlang包的<code>env_print()</code>函数可以给出较多的信息：</p>
<div class="sourceCode" id="cb1272"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1272-1"><a href="p-advfunc.html#cb1272-1"></a>rlang<span class="op">::</span><span class="kw">env_print</span>(e1)</span>
<span id="cb1272-2"><a href="p-advfunc.html#cb1272-2"></a><span class="co">## &lt;environment: 000001D185E88860&gt;</span></span>
<span id="cb1272-3"><a href="p-advfunc.html#cb1272-3"></a><span class="co">## parent: &lt;environment: global&gt;</span></span>
<span id="cb1272-4"><a href="p-advfunc.html#cb1272-4"></a><span class="co">## bindings:</span></span>
<span id="cb1272-5"><a href="p-advfunc.html#cb1272-5"></a><span class="co">##  * a: &lt;lgl&gt;</span></span>
<span id="cb1272-6"><a href="p-advfunc.html#cb1272-6"></a><span class="co">##  * b: &lt;chr&gt;</span></span>
<span id="cb1272-7"><a href="p-advfunc.html#cb1272-7"></a><span class="co">##  * c: &lt;dbl&gt;</span></span>
<span id="cb1272-8"><a href="p-advfunc.html#cb1272-8"></a><span class="co">##  * d: &lt;int&gt;</span></span>
<span id="cb1272-9"><a href="p-advfunc.html#cb1272-9"></a><span class="co">##  * e: &lt;list&gt;</span></span></code></pre></div>
<p><code>rlang::env_names()</code>可以获得环境中绑定的名字组成的字符型向量：</p>
<div class="sourceCode" id="cb1273"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1273-1"><a href="p-advfunc.html#cb1273-1"></a>rlang<span class="op">::</span><span class="kw">env_names</span>(e1)</span>
<span id="cb1273-2"><a href="p-advfunc.html#cb1273-2"></a><span class="co">## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot;</span></span></code></pre></div>
</div>
<div id="p-advfunc-env-def-imptnt" class="section level4">
<h4><span class="header-section-number">19.9.1.2</span> 重要环境</h4>
<p><code>rlang::current_env()</code>或基本R的<code>environment()</code>返回调用代码时所在的环境，
比如，
在命令行调用时，返回<code>&lt;environment: R_GlobalEnv&gt;</code>。</p>
<p><code>rlang::global_env()</code>和基本R的<code>globalenv()</code>返回全局环境，
这是另一个重要环境，
也称为“工作空间”，
是在命令行运行时所处的环境。</p>
<p>为了比较两个环境是否同一个，
需要用<code>indentical(e1, e2)</code>，
而不能用<code>==</code>比较。</p>
</div>
<div id="p-advfunc-env-def-parent" class="section level4">
<h4><span class="header-section-number">19.9.1.3</span> 父环境</h4>
<p>每个环境都有一个父环境，
这样在按句法规则查找变量的绑定对象时，
就依次查找环境本身、其父环境、父环境的父环境，
等等。内嵌函数的父环境是定义它的函数的内部环境。</p>
<p>rlang的<code>env()</code>在生成环境时，
可以用第一个无名的参数输入父环境，
如：</p>
<div class="sourceCode" id="cb1274"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1274-1"><a href="p-advfunc.html#cb1274-1"></a>e1 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(<span class="dt">a=</span><span class="dv">1</span>, <span class="dt">b=</span><span class="dv">2</span>)</span>
<span id="cb1274-2"><a href="p-advfunc.html#cb1274-2"></a>e2 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(e1, <span class="dt">c=</span><span class="dv">3</span>, <span class="dt">d=</span><span class="dv">4</span>)</span></code></pre></div>
<p>当<code>rlang::env()</code>没有输入父环境时，
父环境就设为调用时的环境。
用<code>rlang::env_parent()</code>获得父环境，
用<code>rlang::env_parents()</code>获得各层父环境，如：</p>
<div class="sourceCode" id="cb1275"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1275-1"><a href="p-advfunc.html#cb1275-1"></a>rlang<span class="op">::</span><span class="kw">env_print</span>(e1)</span>
<span id="cb1275-2"><a href="p-advfunc.html#cb1275-2"></a><span class="co">## &lt;environment: 000001D185DDE7D0&gt;</span></span>
<span id="cb1275-3"><a href="p-advfunc.html#cb1275-3"></a><span class="co">## parent: &lt;environment: global&gt;</span></span>
<span id="cb1275-4"><a href="p-advfunc.html#cb1275-4"></a><span class="co">## bindings:</span></span>
<span id="cb1275-5"><a href="p-advfunc.html#cb1275-5"></a><span class="co">##  * a: &lt;dbl&gt;</span></span>
<span id="cb1275-6"><a href="p-advfunc.html#cb1275-6"></a><span class="co">##  * b: &lt;dbl&gt;</span></span>
<span id="cb1275-7"><a href="p-advfunc.html#cb1275-7"></a>rlang<span class="op">::</span><span class="kw">env_parent</span>(e2)</span>
<span id="cb1275-8"><a href="p-advfunc.html#cb1275-8"></a><span class="co">## &lt;environment: 0x000001d185dde7d0&gt;</span></span>
<span id="cb1275-9"><a href="p-advfunc.html#cb1275-9"></a>rlang<span class="op">::</span><span class="kw">env_parents</span>(e2)</span>
<span id="cb1275-10"><a href="p-advfunc.html#cb1275-10"></a><span class="co">## [[1]]   &lt;env: 000001D185DDE7D0&gt;</span></span>
<span id="cb1275-11"><a href="p-advfunc.html#cb1275-11"></a><span class="co">## [[2]] $ &lt;env: global&gt;</span></span></code></pre></div>
<p>对于以全局环境为父环境的环境，
<code>env_parents()</code>的输出截止到全局环境为止；
但是，
全局环境的上层还有加载的各个扩展包的环境，
这也是查找变量的较后面的搜索路径。</p>
<p>为了制造一个上层不包含全局环境的环境，
可以用<code>rlang::empty_env()</code>作为父环境，
这个环境称为空环境，记为<code>R_EmptyEnv</code>。</p>
</div>
<div id="p-advfunc-env-def-supassign" class="section level4">
<h4><span class="header-section-number">19.9.1.4</span> 在上层环境中赋值</h4>
<p>用“<code>&lt;&lt;-</code>”在各级父环境中赋值，
最先在那一层父环境中找到变量就在那一层中赋值，
如果直到全局环境都没有找到变量，
就在全局环境中新建一个变量。
全局变量应谨慎使用，
它使得程序之间的数据输入输出变得不明晰。
在使用闭包时常常需要使用这种赋值方式保存并修改一个闭包的状态。</p>
<p>如：</p>
<div class="sourceCode" id="cb1276"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1276-1"><a href="p-advfunc.html#cb1276-1"></a>f0 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1276-2"><a href="p-advfunc.html#cb1276-2"></a>  x &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1276-3"><a href="p-advfunc.html#cb1276-3"></a>  f1 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1276-4"><a href="p-advfunc.html#cb1276-4"></a>    f2 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1276-5"><a href="p-advfunc.html#cb1276-5"></a>      x &lt;&lt;-<span class="st"> </span>x<span class="op">+</span><span class="dv">1</span></span>
<span id="cb1276-6"><a href="p-advfunc.html#cb1276-6"></a>      x</span>
<span id="cb1276-7"><a href="p-advfunc.html#cb1276-7"></a>    }</span>
<span id="cb1276-8"><a href="p-advfunc.html#cb1276-8"></a>    <span class="kw">f2</span>()</span>
<span id="cb1276-9"><a href="p-advfunc.html#cb1276-9"></a>  }</span>
<span id="cb1276-10"><a href="p-advfunc.html#cb1276-10"></a>  f1</span>
<span id="cb1276-11"><a href="p-advfunc.html#cb1276-11"></a>}</span>
<span id="cb1276-12"><a href="p-advfunc.html#cb1276-12"></a>f01 &lt;-<span class="st"> </span><span class="kw">f0</span>()</span>
<span id="cb1276-13"><a href="p-advfunc.html#cb1276-13"></a><span class="kw">f01</span>()</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb1278"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1278-1"><a href="p-advfunc.html#cb1278-1"></a><span class="kw">f01</span>()</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>在上面的例子中，
<code>&lt;&lt;-</code>首先在<code>f1</code>环境内查找<code>x</code>，
没有找到就继续向上在<code>f0</code>的环境内查找<code>x</code>。</p>
</div>
<div id="p-advfunc-env-def-getset" class="section level4">
<h4><span class="header-section-number">19.9.1.5</span> 环境中名字的访问</h4>
<p>类似于列表元素访问，用“<code>环境$名字</code>”格式或者“<code>环境[["名字"]]</code>”读取环境的元素，
不存在时返回<code>NULL</code>。如：</p>
<div class="sourceCode" id="cb1280"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1280-1"><a href="p-advfunc.html#cb1280-1"></a>e1 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(rlang<span class="op">::</span><span class="kw">empty_env</span>(), <span class="dt">x=</span><span class="dv">1</span>, <span class="dt">y=</span><span class="dv">2</span>)</span>
<span id="cb1280-2"><a href="p-advfunc.html#cb1280-2"></a>e2 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(e1, <span class="dt">a=</span><span class="dv">3</span>, <span class="dt">b=</span><span class="dv">4</span>)</span>
<span id="cb1280-3"><a href="p-advfunc.html#cb1280-3"></a>e2<span class="op">$</span>a</span>
<span id="cb1280-4"><a href="p-advfunc.html#cb1280-4"></a><span class="co">## [1] 3</span></span>
<span id="cb1280-5"><a href="p-advfunc.html#cb1280-5"></a>e2[[<span class="st">&quot;b&quot;</span>]]</span>
<span id="cb1280-6"><a href="p-advfunc.html#cb1280-6"></a><span class="co">## [1] 4</span></span>
<span id="cb1280-7"><a href="p-advfunc.html#cb1280-7"></a>e2<span class="op">$</span>x</span>
<span id="cb1280-8"><a href="p-advfunc.html#cb1280-8"></a><span class="co">## NULL</span></span></code></pre></div>
<p>从上例也可以看出不能直接读取父环境中的变量。</p>
<p>如果希望在找不到变量时出错，
可以用<code>rlang::env_get(环境名, "名字")</code>，如：</p>
<div class="sourceCode" id="cb1281"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1281-1"><a href="p-advfunc.html#cb1281-1"></a>rlang<span class="op">::</span><span class="kw">env_get</span>(e2, <span class="st">&quot;x&quot;</span>)</span>
<span id="cb1281-2"><a href="p-advfunc.html#cb1281-2"></a><span class="co">## Error in rlang::env_get(e2, &quot;x&quot;) : 找不到对象&#39;x&#39;</span></span></code></pre></div>
<p>可以设置<code>env_get()</code>在查找不到时的缺省值，如：</p>
<div class="sourceCode" id="cb1282"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1282-1"><a href="p-advfunc.html#cb1282-1"></a>rlang<span class="op">::</span><span class="kw">env_get</span>(e2, <span class="st">&quot;x&quot;</span>, <span class="dt">default=</span><span class="ot">NA</span>)</span>
<span id="cb1282-2"><a href="p-advfunc.html#cb1282-2"></a><span class="co">## [1] NA</span></span></code></pre></div>
<p>为了在环境中增加绑定或重新绑定，
可以用<code>$</code>或<code>[[</code>格式直接赋值，
可以用<code>rlang::env_poke()</code>或<code>rlang::env_bind()</code>，
<code>rlang::env_bind()</code>运行同时进行多个绑定，如：</p>
<div class="sourceCode" id="cb1283"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1283-1"><a href="p-advfunc.html#cb1283-1"></a>e1 &lt;-<span class="st"> </span>rlang<span class="op">::</span><span class="kw">env</span>(<span class="dt">x=</span><span class="dv">1</span>, <span class="dt">y=</span><span class="dv">2</span>)</span>
<span id="cb1283-2"><a href="p-advfunc.html#cb1283-2"></a>e1<span class="op">$</span>z &lt;-<span class="st"> </span><span class="dv">3</span></span>
<span id="cb1283-3"><a href="p-advfunc.html#cb1283-3"></a>rlang<span class="op">::</span><span class="kw">env_poke</span>(e1, <span class="st">&quot;a&quot;</span>, <span class="dv">11</span>)</span>
<span id="cb1283-4"><a href="p-advfunc.html#cb1283-4"></a>rlang<span class="op">::</span><span class="kw">env_bind</span>(e1, <span class="dt">b=</span><span class="dv">12</span>, <span class="dt">c=</span><span class="dv">13</span>)</span>
<span id="cb1283-5"><a href="p-advfunc.html#cb1283-5"></a>rlang<span class="op">::</span><span class="kw">env_names</span>(e1)</span>
<span id="cb1283-6"><a href="p-advfunc.html#cb1283-6"></a><span class="co">## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; &quot;a&quot; &quot;b&quot; &quot;c&quot;</span></span></code></pre></div>
<p>用<code>rlang::env_has()</code>检查某个环境中是否绑定了指定的名字，如：</p>
<div class="sourceCode" id="cb1284"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1284-1"><a href="p-advfunc.html#cb1284-1"></a>rlang<span class="op">::</span><span class="kw">env_has</span>(e1, <span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;c&quot;</span>, <span class="st">&quot;f&quot;</span>))</span>
<span id="cb1284-2"><a href="p-advfunc.html#cb1284-2"></a><span class="co">##     x     c     f </span></span>
<span id="cb1284-3"><a href="p-advfunc.html#cb1284-3"></a><span class="co">##  TRUE  TRUE FALSE </span></span></code></pre></div>
<p>为了在环境中删除一个名字的绑定，
需要用<code>rlang::env_unbind()</code>，如：</p>
<div class="sourceCode" id="cb1285"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1285-1"><a href="p-advfunc.html#cb1285-1"></a>rlang<span class="op">::</span><span class="kw">env_unbind</span>(e1, <span class="kw">c</span>(<span class="st">&quot;z&quot;</span>, <span class="st">&quot;c&quot;</span>))</span>
<span id="cb1285-2"><a href="p-advfunc.html#cb1285-2"></a>rlang<span class="op">::</span><span class="kw">env_names</span>(e1)</span>
<span id="cb1285-3"><a href="p-advfunc.html#cb1285-3"></a><span class="co">## [1] &quot;x&quot; &quot;y&quot; &quot;a&quot; &quot;b&quot;</span></span></code></pre></div>
<p>注意<code>env_unbind()</code>只是解除了绑定，
原来的对象并不会马上被删除，
如果没有其它名字引用该对象，
R的垃圾收集器会随后删除该对象。</p>
<p>基本R的<code>get()</code>，<code>assign()</code>, <code>exists()</code>，<code>rm()</code>等函数起到与rlang包中的<code>env_get()</code>，
<code>env_poke()</code>, <code>env_has()</code>, <code>env_unbind()</code>类似的功能，
但是这些函数通常都针对调用时的当前环境，
不容易处理其他环境，
另外它们都有一个<code>inherits</code>选项默认为<code>TRUE</code>，
可以自动搜索父环境，
所以不如rlang包的函数功能明确。</p>
</div>
<div id="p-advfunc-env-def-spebind" class="section level4">
<h4><span class="header-section-number">19.9.1.6</span> 两种较少使用的特殊环境</h4>
<p><code>rlang::env_bind_lazy()</code>可以创造延迟的绑定，
就是类似于R函数形参缺省值的懒惰求值那样，
第一次使用其值的时候才进行绑定。
利用这种技术，
可以实现类似<code>autoload()</code>的功能，
<code>autoload()</code>可以使得用到某个扩展包中指定的名字时才自动载入该扩展包，
利用延迟绑定，
可以使得数据框看起来像是已经在内存中，
但实际是用到该数据框时才中硬盘中读入。
基本R中提供了类似的<code>delayedAssign()</code>函数。</p>
<p><code>rlang::env_bind_acitive()</code>可以制造一个环境，
每次访问环境中的名字都重新求值并绑定一次。
基本R中提供了类似的<code>makeActiveBinding()</code>函数。</p>
</div>
</div>
<div id="p-advfunc-env-recurs" class="section level3">
<h3><span class="header-section-number">19.9.2</span> 逐层向上访问环境</h3>
<p>要逐层向上访问环境，
可以利用R的递归函数。
下面写一个逐层向上查找指定的名字所在的环境的自定义函数。
（来自Advanced R）。</p>
<div class="sourceCode" id="cb1286"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1286-1"><a href="p-advfunc.html#cb1286-1"></a>where &lt;-<span class="st"> </span><span class="cf">function</span>(name, <span class="dt">env =</span> rlang<span class="op">::</span><span class="kw">caller_env</span>()) {</span>
<span id="cb1286-2"><a href="p-advfunc.html#cb1286-2"></a>  <span class="cf">if</span> (<span class="kw">identical</span>(env, <span class="kw">empty_env</span>())) {</span>
<span id="cb1286-3"><a href="p-advfunc.html#cb1286-3"></a>    <span class="co"># 找到了顶层都没有找到</span></span>
<span id="cb1286-4"><a href="p-advfunc.html#cb1286-4"></a>    <span class="kw">stop</span>(<span class="st">&quot;找不到 &quot;</span>, name, <span class="dt">call. =</span> <span class="ot">FALSE</span>)</span>
<span id="cb1286-5"><a href="p-advfunc.html#cb1286-5"></a>  } <span class="cf">else</span> <span class="cf">if</span> (rlang<span class="op">::</span><span class="kw">env_has</span>(env, name)) {</span>
<span id="cb1286-6"><a href="p-advfunc.html#cb1286-6"></a>    <span class="co"># 在当前的env环境中找到了，返回找到时的环境</span></span>
<span id="cb1286-7"><a href="p-advfunc.html#cb1286-7"></a>    env</span>
<span id="cb1286-8"><a href="p-advfunc.html#cb1286-8"></a>  } <span class="cf">else</span> {</span>
<span id="cb1286-9"><a href="p-advfunc.html#cb1286-9"></a>    <span class="co"># 利用递归向上层查找</span></span>
<span id="cb1286-10"><a href="p-advfunc.html#cb1286-10"></a>    <span class="kw">Recall</span>(name, rlang<span class="op">::</span><span class="kw">env_parent</span>(env))</span>
<span id="cb1286-11"><a href="p-advfunc.html#cb1286-11"></a>  }</span>
<span id="cb1286-12"><a href="p-advfunc.html#cb1286-12"></a>}</span></code></pre></div>
<p>自变量<code>name</code>是要查找的名字，
<code>env</code>是从那个环境开始逐层向上查找，
<code>env</code>的缺省值是调用<code>where()</code>函数时的环境。
定义中分了三种情况：
到顶层（空环境）都没有找到，
出错停止；
在向上逐层查找中在某个环境中找到了，
返回找到时的环境；
否则就利用递归向上层查找。</p>
<p>这个例子可以用作环境逐层向上遍历的模板。</p>
</div>
<div id="p-advfunc-env-spec" class="section level3">
<h3><span class="header-section-number">19.9.3</span> 特殊环境</h3>
<p>实际上，
一般用户都不会用到<code>rlang::env()</code>生成的环境；
但是用户都会接触到使用R语言时自然产生的各种环境，
只不过许多用户可能没有认识到自己是在使用环境。</p>
<p>R语言使用中涉及到环境的情景有：</p>
<ul>
<li>扩展包的环境和搜索路径；</li>
<li>函数环境；</li>
<li>命名空间；</li>
<li>运行环境。</li>
</ul>
<div id="p-advfunc-env-spec-pac" class="section level4">
<h4><span class="header-section-number">19.9.3.1</span> 扩展包环境</h4>
<p>每次用<code>library()</code>或<code>require()</code>命令载入一个扩展包，
它定义的变量和函数就构成一个环境，
这个环境变成全局环境的父环境。
这样，
全局环境的各层父环境包括用户载入的扩展包和启动R会话时会自动载入的扩展包（如stats等），
载入最晚的一个扩展包的环境是全局环境的父环境，
载入越早的扩展包的环境距离全局环境的层次越远。
实际上，
在查找某个名字时，
在当前环境没有找到时会逐层向父环境查找，
这些父环境一般就包括全局环境和全局环境上层的各个加载了的扩展包形成的环境，
这种搜索次序称为当前搜索路径，
<code>search()</code>返回当前搜索路径，如：</p>
<div class="sourceCode" id="cb1287"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1287-1"><a href="p-advfunc.html#cb1287-1"></a><span class="kw">search</span>()</span>
<span id="cb1287-2"><a href="p-advfunc.html#cb1287-2"></a><span class="co">## [1] &quot;.GlobalEnv&quot;        &quot;tools:rstudio&quot;     &quot;package:stats&quot;</span></span>
<span id="cb1287-3"><a href="p-advfunc.html#cb1287-3"></a><span class="co">## [4] &quot;package:graphics&quot;  &quot;package:grDevices&quot; &quot;package:utils&quot;</span></span>
<span id="cb1287-4"><a href="p-advfunc.html#cb1287-4"></a><span class="co">## [7] &quot;package:datasets&quot;  &quot;package:methods&quot;   &quot;Autoloads&quot;</span></span>
<span id="cb1287-5"><a href="p-advfunc.html#cb1287-5"></a><span class="co">## [10]&quot;package:base&quot;     </span></span></code></pre></div>
<p><code>rlang::search_envs()</code>返回以环境为元素的搜索路径。</p>
<p>搜索路径中除了全局环境之外，
最后两个比较特殊：</p>
<ul>
<li><code>Autoloads</code>用类似于函数缺省值懒惰求值的方法在需要用到某个变量时才从磁盘将其载入到内存中，
适用于占用存储空间很大的数据框之类的对象。</li>
<li><code>package:base</code>是基本R的环境，必须先载入这一环境才能加载其它环境。
可以直接用<code>rlang::base_env()</code>返回这一环境。</li>
</ul>
</div>
<div id="p-advfunc-env-spec-fun" class="section level4">
<h4><span class="header-section-number">19.9.3.2</span> 函数内部的环境</h4>
<p>自定义函数包括形参表、函数体和定义时绑定的环境三个部分，
非内嵌的也不在扩展包中定义的函数一般都与全局环境绑定，
这样的函数的绑定环境没有什么用处，
即使不了解环境部分也能够很好地使用这样的函数。</p>
<p>内嵌在函数内定义的函数称为闭包，
闭包的绑定的环境是定义它的函数的内部环境，
如果这个闭包作为定义它的函数的输出，
闭包对象带有一个私有环境，
即定义它的函数的内部环境，
可以用来保存闭包函数的状态。
在前面的讲到函数工厂时给出了闭包的例子。</p>
<p>用<code>rlang::fn_env(f)</code>可以求函数<code>f</code>的绑定环境。
如：</p>
<div class="sourceCode" id="cb1288"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1288-1"><a href="p-advfunc.html#cb1288-1"></a>f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) <span class="dv">2</span><span class="op">*</span>x</span>
<span id="cb1288-2"><a href="p-advfunc.html#cb1288-2"></a>rlang<span class="op">::</span><span class="kw">fn_env</span>(f1)</span>
<span id="cb1288-3"><a href="p-advfunc.html#cb1288-3"></a><span class="co">## &lt;environment: R_GlobalEnv&gt;</span></span></code></pre></div>
<p>又如闭包：</p>
<div class="sourceCode" id="cb1289"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1289-1"><a href="p-advfunc.html#cb1289-1"></a>f1 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1289-2"><a href="p-advfunc.html#cb1289-2"></a>  times &lt;-<span class="st"> </span><span class="dv">0</span></span>
<span id="cb1289-3"><a href="p-advfunc.html#cb1289-3"></a>  f2 &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb1289-4"><a href="p-advfunc.html#cb1289-4"></a>    times &lt;&lt;-<span class="st"> </span>times <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb1289-5"><a href="p-advfunc.html#cb1289-5"></a>    <span class="kw">cat</span>(<span class="st">&quot;NO. &quot;</span>, times, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb1289-6"><a href="p-advfunc.html#cb1289-6"></a>  }</span>
<span id="cb1289-7"><a href="p-advfunc.html#cb1289-7"></a>  <span class="kw">print</span>(rlang<span class="op">::</span><span class="kw">fn_env</span>(f2))</span>
<span id="cb1289-8"><a href="p-advfunc.html#cb1289-8"></a>  f2</span>
<span id="cb1289-9"><a href="p-advfunc.html#cb1289-9"></a>}</span>
<span id="cb1289-10"><a href="p-advfunc.html#cb1289-10"></a>f2b &lt;-<span class="st"> </span><span class="kw">f1</span>()</span>
<span id="cb1289-11"><a href="p-advfunc.html#cb1289-11"></a><span class="co">## &lt;environment: 0x00000201dc5096d8&gt;</span></span>
<span id="cb1289-12"><a href="p-advfunc.html#cb1289-12"></a><span class="kw">print</span>(rlang<span class="op">::</span><span class="kw">fn_env</span>(f2b))</span>
<span id="cb1289-13"><a href="p-advfunc.html#cb1289-13"></a><span class="co">## &lt;environment: 0x00000201dc5096d8&gt;</span></span>
<span id="cb1289-14"><a href="p-advfunc.html#cb1289-14"></a><span class="kw">f2b</span>()</span>
<span id="cb1289-15"><a href="p-advfunc.html#cb1289-15"></a><span class="co">## NO. 1</span></span>
<span id="cb1289-16"><a href="p-advfunc.html#cb1289-16"></a><span class="kw">f2b</span>()</span>
<span id="cb1289-17"><a href="p-advfunc.html#cb1289-17"></a><span class="co">## NO. 2</span></span></code></pre></div>
<p>这个例子显示的<code>f2</code>和<code>f2b</code>的环境都是<code>f1</code>内部的环境，
在现实<code>f2b</code>的环境时虽然<code>f1()</code>已经结束运行，
但是闭包可以保存其定义时的环境。</p>
</div>
<div id="p-advfunc-env-spec-ns" class="section level4">
<h4><span class="header-section-number">19.9.3.3</span> 命名空间</h4>
<p>变量名和函数名的搜索路径中包含了已载入的扩展包的环境，
这就造成一个问题：
后载入的扩展包中的函数会遮盖住先载入的扩展包中的同名函数，
变量也是如此。
所以，
应该仅载入必要的扩展包，
尽可能用“<code>扩展包名::函数名</code>”的格式调用。</p>
<p>这些问题是用户可控的，
还有一个本质性的问题：
假设扩展包A中的函数<code>f1</code>要用到扩展包B中的函数<code>f11</code>，
先载入了扩展包B，
然后载入了扩展包A，
这时调用A中的<code>f1()</code>没有问题。
现在假设随后又调入了一个扩展C，
扩展包C中也定义了一个<code>f11</code>函数，
那么，
现在调用A中的<code>f1</code>时，
会调用B中的<code>f11</code>还是C中的<code>f11</code>?
如果调用C中的<code>f11</code>就是会程序出错或给出错误结果。</p>
<p>为了避免这样的不可控的错误发生，
R语言的扩展包开发进行了严格的规定。
R的扩展包与两个环境有关，
一个就是扩展包的环境，
这实际是用户能看到的R扩展包提供的变量和函数，
在载入扩展包时会插入到搜索路径中。
另一个环境是命名空间环境，
这是扩展包私有的一个环境，
其中的变量和函数有一些对包的用户不可见，
扩展包环境中那些用户可见的变量和函数也在命名空间环境中。
R扩展包在设计时都会利用命名空间严格限定包内部调用的其它包中的函数，
不至于引起歧义。</p>
<p>每个扩展包的命名空间环境都有如下的一套上层环境：</p>
<ul>
<li>imports环境，其中包含所有的用到的其它扩展包的函数，
这是由扩展包的开发者确定的，所以不会错误调用错误的包；</li>
<li>imports环境的父环境是基本R环境对应的命名空间环境，但其父环境与基本R环境的父环境不同；</li>
<li>基本R命名空间环境的父环境是全局环境。注意基本R环境的父环境是空环境。</li>
</ul>
<p>所以，
扩展包内调用其它扩展包的函数是需要开发者明确地加入到imports环境中的，
不受用户调用时载入了那些扩展包和载入次序影响。
扩展包环境（针对用户的）和扩展包命名空间环境（包开发者自用）这`两个环境不发生直接的引用联系，
可以通过函数环境逐层向上变量发生联系。</p>
</div>
<div id="p-advfunc-env-spec-exe" class="section level4">
<h4><span class="header-section-number">19.9.3.4</span> 运行环境</h4>
<p>函数在调用执行时自动生成一个运行环境，
其父环境为函数定义时的环境，
比如，
设<code>f</code>是在命令行定义的函数，
调用<code>f()</code>时自动生成一个<code>f</code>的运行环境，
相当于<code>f</code>的局部变量和形参的环境，
其父环境为<code>f</code>定义时的环境，
即全局环境。</p>
<p>设函数<code>f2</code>在函数工厂<code>f1</code>中定义并被<code>f1</code>输出为一个闭包<code>f2b</code>，
则调用<code>f2b</code>时自动生成一个<code>f2b</code>的运行环境，
相当于<code>f2b</code>的局部变量和形参组成的环境，
此运行环境的父环境是定义时的环境，
即<code>f2</code>函数内部的环境。
函数执行结束则运行环境消失。</p>
<p>为了能够保留下来运行环境，
一种办法是将运行环境在运行时用<code>rlang::current_env()</code>获取并作为函数的返回值保存到变量中，
另一种办法是像函数工厂那样输出一个闭包，
闭包的环境就是函数工厂的运行环境。</p>
</div>
</div>
<div id="p-advfunc-env-callst" class="section level3">
<h3><span class="header-section-number">19.9.4</span> 调用栈</h3>
<p>函数在被调用时，
还涉及到调用它的环境，
可以用<code>rlang::caller_env()</code>获得。
调用环境与调用时的实参计算有关，
需要了解调用栈(call stack)概念，
调用栈由若干个分层的框架(frames)组成。
R运行出错时会显示一个<code>traceback()</code>结果，
就是调用栈的各个框架。
如：</p>
<div class="sourceCode" id="cb1290"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1290-1"><a href="p-advfunc.html#cb1290-1"></a>f1 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb1290-2"><a href="p-advfunc.html#cb1290-2"></a>  <span class="kw">f2</span>(<span class="dt">x =</span> <span class="dv">2</span>)</span>
<span id="cb1290-3"><a href="p-advfunc.html#cb1290-3"></a>}</span>
<span id="cb1290-4"><a href="p-advfunc.html#cb1290-4"></a>f2 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb1290-5"><a href="p-advfunc.html#cb1290-5"></a>  <span class="kw">f3</span>(<span class="dt">x =</span> <span class="dv">3</span>)</span>
<span id="cb1290-6"><a href="p-advfunc.html#cb1290-6"></a>}</span>
<span id="cb1290-7"><a href="p-advfunc.html#cb1290-7"></a>f3 &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</span>
<span id="cb1290-8"><a href="p-advfunc.html#cb1290-8"></a>  <span class="kw">stop</span>()</span>
<span id="cb1290-9"><a href="p-advfunc.html#cb1290-9"></a>}</span>
<span id="cb1290-10"><a href="p-advfunc.html#cb1290-10"></a><span class="kw">f1</span>()</span>
<span id="cb1290-11"><a href="p-advfunc.html#cb1290-11"></a></span>
<span id="cb1290-12"><a href="p-advfunc.html#cb1290-12"></a><span class="co">##  Error in f3(x = 3) : </span></span>
<span id="cb1290-13"><a href="p-advfunc.html#cb1290-13"></a><span class="co">## 4. stop() </span></span>
<span id="cb1290-14"><a href="p-advfunc.html#cb1290-14"></a><span class="co">## 3. f3(x = 3) </span></span>
<span id="cb1290-15"><a href="p-advfunc.html#cb1290-15"></a><span class="co">## 2. f2(x = 2) </span></span>
<span id="cb1290-16"><a href="p-advfunc.html#cb1290-16"></a><span class="co">## 1. f1() </span></span></code></pre></div>
<p>上面例子在用<code>stop()</code>产生出错信号时显示调用栈，
下面的函数调用了上面的函数。</p>
<p>可以用<code>lobstr::cst()</code>显示函数的调用栈。</p>
<p>当调用时有懒惰求值时，
调用栈就可能有多个分支。</p>
<p>调用栈中的每一次调用称为一个框架，
或求值上下文(evaluation context)。
框架是支持R语言的重要成分，
R程序仅能对框架数据结构作很少的操作。
每个框架有三个构成部分：</p>
<ul>
<li>一个表示调用函数的表达式<code>expr</code>。</li>
<li>一个环境，通常是调用的函数的运行环境。
但是，全局框架的环境还是全局环境，
使用<code>eval()</code>会造出一个框架，
其环境则是可以由用户干预的。</li>
<li>父框架，即调用它的框架。</li>
</ul>
<p>框架还会保存函数的一些非正常执行路径，
如<code>on.exit()</code>指定的操作，
出错时的处理。</p>
<p>R采用句法作用域，
即由定义决定变量作用域，
有少数语言如Lisp采用动态作用域(dynamic scoping)，
即在调用栈上查找变量值。</p>
</div>
<div id="p-advfunc-env-usedt" class="section level3">
<h3><span class="header-section-number">19.9.5</span> 将环境用作一般数据结构</h3>
<p>环境中的变量都是引用，
或者绑定，
不需要制作环境副本，
这使得环境可以当作一种高级的数据类型使用。</p>
<p>将环境作为一般数据结构使用，
可以用在如下一些方面：</p>
<ul>
<li>因为不需要制作副本，
所以可以节省内存空间。
但是直接使用环境不够友好，
可以使用R6类型的数据，
R6类型是建立在环境的基础上的。</li>
<li>在自己建立的扩展包中，
用环境保存包的状态。
这样一个包中的函数多次调用时，
可以在多次调用之间传递一些状态信息。
可以在包中用<code>get.xxx()</code>函数和<code>set.xxx()</code>函数提供包用户访问状态的接口函数。</li>
<li>环境可以当作一个杂凑表用，
杂凑表可以在常数时间将名字对应到值。</li>
</ul>

</div>
</div>
</div>



<h3>References</h3>
<div id="refs" class="references">
<div id="ref-Wickham2019:advanced-r-2ed">
<p>Wickham, Hadley. 2019. <em>Advanced R</em>. 2nd Edition.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="prog-prof.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="knitr.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="static/js/app.min.js"></script>
<script src="static/js/lunr.js"></script>
<script src="static/js/clipboard.min.js"></script>
<script src="static/js/plugin-search.js"></script>
<script src="static/js/plugin-sharing.js"></script>
<script src="static/js/plugin-fontsettings.js"></script>
<script src="static/js/plugin-bookdown.js"></script>
<script src="static/js/jquery.highlight.js"></script>
<script src="static/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Rbook.pdf"],
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

<div style="display:none">
    <script src="http://s11.cnzz.com/z_stat.php?id=610720&web_id=610720" language="JavaScript"></script>
</div>

</body>

</html>
