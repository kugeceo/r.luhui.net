<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>36 R语言的文本处理 | R语言教程</title>
  <meta name="description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  <meta name="generator" content="bookdown 0.21 and GitBook 2.6.7" />

  <meta property="og:title" content="36 R语言的文本处理 | R语言教程" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="36 R语言的文本处理 | R语言教程" />
  
  <meta name="twitter:description" content="李东风在北京大学数学科学学院开设本科生《统计软件》教材。采用R的bookdown制作，输出格式为bookdown::gitbook." />
  

<meta name="author" content="李东风" />


<meta name="date" content="2020-12-28" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="simulation.html"/>
<link rel="next" href="rcpp.html"/>
<script src="static/js/jquery.min.js"></script>
<link href="static/css/style.css" rel="stylesheet" />
<link href="static/css/plugin-table.css" rel="stylesheet" />
<link href="static/css/plugin-bookdown.css" rel="stylesheet" />
<link href="static/css/plugin-highlight.css" rel="stylesheet" />
<link href="static/css/plugin-search.css" rel="stylesheet" />
<link href="static/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="static/css/plugin-clipboard.css" rel="stylesheet" />






<div style="display:none">
    <script src="http://s11.cnzz.com/z_stat.php?id=610720&web_id=610720" language="JavaScript"></script>
</div>





<script src="static/js/empty-anchor.js"></script>
<script src="static/js/htmlwidgets.js"></script>
<link href="static/css/str_view.css" rel="stylesheet" />
<script src="static/js/str_view.js"></script>
<link href="static/css/wordcloud.css" rel="stylesheet" />
<script src="static/js/wordcloud2-all.js"></script>
<script src="static/js/hover.js"></script>
<script src="static/js/wordcloud2.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX","output/SVG"],
  extensions: ["tex2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});
</script>
<script type="text/javascript"
   src="static/js/mathjax.js">
</script>


<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="http://www.math.pku.edu.cn/teachers/lidf/docs/Rbook/html/_Rbook/index.html">R语言教程</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>前言</a></li>
<li class="part"><span><b>I 介绍</b></span></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> R语言介绍</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#intro-hist-char"><i class="fa fa-check"></i><b>1.1</b> R的历史和特点</a><ul>
<li class="chapter" data-level="1.1.1" data-path="intro.html"><a href="intro.html#intro-hc-hist"><i class="fa fa-check"></i><b>1.1.1</b> R的历史</a></li>
<li class="chapter" data-level="1.1.2" data-path="intro.html"><a href="intro.html#intro-hc-char"><i class="fa fa-check"></i><b>1.1.2</b> R的特点</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#intro-install"><i class="fa fa-check"></i><b>1.2</b> R的下载与安装</a><ul>
<li class="chapter" data-level="1.2.1" data-path="intro.html"><a href="intro.html#intro-ins-down"><i class="fa fa-check"></i><b>1.2.1</b> R的下载</a></li>
<li class="chapter" data-level="1.2.2" data-path="intro.html"><a href="intro.html#intro-ins-install"><i class="fa fa-check"></i><b>1.2.2</b> R软件安装</a></li>
<li class="chapter" data-level="1.2.3" data-path="intro.html"><a href="intro.html#intro-ins-other-soft"><i class="fa fa-check"></i><b>1.2.3</b> 辅助软件</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#intro-ins-packages"><i class="fa fa-check"></i><b>1.3</b> R扩展软件包的安装与管理</a><ul>
<li class="chapter" data-level="1.3.1" data-path="intro.html"><a href="intro.html#intro-ins-pack-ins"><i class="fa fa-check"></i><b>1.3.1</b> 安装</a></li>
<li class="chapter" data-level="1.3.2" data-path="intro.html"><a href="intro.html#intro-ins-pack-gitbioc"><i class="fa fa-check"></i><b>1.3.2</b> Github和BioConductor的扩展包</a></li>
<li class="chapter" data-level="1.3.3" data-path="intro.html"><a href="intro.html#intro-ins-pack-upd"><i class="fa fa-check"></i><b>1.3.3</b> 更新扩展包</a></li>
<li class="chapter" data-level="1.3.4" data-path="intro.html"><a href="intro.html#intro-ins-pack-verup"><i class="fa fa-check"></i><b>1.3.4</b> 迁移扩展包</a></li>
<li class="chapter" data-level="1.3.5" data-path="intro.html"><a href="intro.html#intro-ins-pack-renv"><i class="fa fa-check"></i><b>1.3.5</b> 项目私有扩展包目录</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#intro-ruse"><i class="fa fa-check"></i><b>1.4</b> 基本R软件的用法</a><ul>
<li class="chapter" data-level="1.4.1" data-path="intro.html"><a href="intro.html#intro-ruse-run"><i class="fa fa-check"></i><b>1.4.1</b> 基本运行</a></li>
<li class="chapter" data-level="1.4.2" data-path="intro.html"><a href="intro.html#intro-ruse-proj"><i class="fa fa-check"></i><b>1.4.2</b> 项目目录</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#intro-rstudio"><i class="fa fa-check"></i><b>1.5</b> RStudio软件</a><ul>
<li class="chapter" data-level="1.5.1" data-path="intro.html"><a href="intro.html#intro-rstudio-intro"><i class="fa fa-check"></i><b>1.5.1</b> 介绍</a></li>
<li class="chapter" data-level="1.5.2" data-path="intro.html"><a href="intro.html#intro-rstudio-proj"><i class="fa fa-check"></i><b>1.5.2</b> 项目</a></li>
<li class="chapter" data-level="1.5.3" data-path="intro.html"><a href="intro.html#intro-rstudio-help"><i class="fa fa-check"></i><b>1.5.3</b> 帮助</a></li>
<li class="chapter" data-level="1.5.4" data-path="intro.html"><a href="intro.html#intro-rstudio-shortcuts"><i class="fa fa-check"></i><b>1.5.4</b> 使用技巧</a></li>
<li class="chapter" data-level="1.5.5" data-path="intro.html"><a href="intro.html#intro-rstudio-rmd"><i class="fa fa-check"></i><b>1.5.5</b> Rmd文件</a></li>
</ul></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#intro-ins-ex"><i class="fa fa-check"></i><b>1.6</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="intro-example.html"><a href="intro-example.html"><i class="fa fa-check"></i><b>2</b> R语言入门运行样例</a><ul>
<li class="chapter" data-level="2.1" data-path="intro-example.html"><a href="intro-example.html#i-e-command-line"><i class="fa fa-check"></i><b>2.1</b> 命令行界面</a></li>
<li class="chapter" data-level="2.2" data-path="intro-example.html"><a href="intro-example.html#i-e-arith-op"><i class="fa fa-check"></i><b>2.2</b> 四则运算</a><ul>
<li class="chapter" data-level="2.2.1" data-path="intro-example.html"><a href="intro-example.html#i-e-arith-op-poker"><i class="fa fa-check"></i><b>2.2.1</b> 计算例子</a></li>
<li class="chapter" data-level="2.2.2" data-path="intro-example.html"><a href="intro-example.html#i-e-a-o-ex"><i class="fa fa-check"></i><b>2.2.2</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="intro-example.html"><a href="intro-example.html#i-e-math-func"><i class="fa fa-check"></i><b>2.3</b> 数学函数</a><ul>
<li class="chapter" data-level="2.3.1" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-sqrt"><i class="fa fa-check"></i><b>2.3.1</b> 数学函数——平方根、指数、对数</a></li>
<li class="chapter" data-level="2.3.2" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-round"><i class="fa fa-check"></i><b>2.3.2</b> 数学函数——取整</a></li>
<li class="chapter" data-level="2.3.3" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-sin"><i class="fa fa-check"></i><b>2.3.3</b> 数学函数——三角函数</a></li>
<li class="chapter" data-level="2.3.4" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-asin"><i class="fa fa-check"></i><b>2.3.4</b> 数学函数——反三角函数</a></li>
<li class="chapter" data-level="2.3.5" data-path="intro-example.html"><a href="intro-example.html#i-e-m-f-dist"><i class="fa fa-check"></i><b>2.3.5</b> 分布函数和分位数函数</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="intro-example.html"><a href="intro-example.html#i-e-output"><i class="fa fa-check"></i><b>2.4</b> 输出</a><ul>
<li class="chapter" data-level="2.4.1" data-path="intro-example.html"><a href="intro-example.html#i-e-o-simple"><i class="fa fa-check"></i><b>2.4.1</b> 简单输出</a></li>
<li class="chapter" data-level="2.4.2" data-path="intro-example.html"><a href="intro-example.html#i-e-o-sink"><i class="fa fa-check"></i><b>2.4.2</b> 用<code>sink()</code>函数作运行记录</a></li>
<li class="chapter" data-level="2.4.3" data-path="intro-example.html"><a href="intro-example.html#i-e-o-ex"><i class="fa fa-check"></i><b>2.4.3</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="intro-example.html"><a href="intro-example.html#i-e-vector"><i class="fa fa-check"></i><b>2.5</b> 向量计算与变量赋值</a></li>
<li class="chapter" data-level="2.6" data-path="intro-example.html"><a href="intro-example.html#i-e-workspace"><i class="fa fa-check"></i><b>2.6</b> 工作空间介绍</a><ul>
<li class="chapter" data-level="2.6.1" data-path="intro-example.html"><a href="intro-example.html#i-e-w-ex"><i class="fa fa-check"></i><b>2.6.1</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="intro-example.html"><a href="intro-example.html#i-e-graph"><i class="fa fa-check"></i><b>2.7</b> 绘图示例</a><ul>
<li class="chapter" data-level="2.7.1" data-path="intro-example.html"><a href="intro-example.html#i-e-g-curve"><i class="fa fa-check"></i><b>2.7.1</b> 函数曲线示例</a></li>
<li class="chapter" data-level="2.7.2" data-path="intro-example.html"><a href="intro-example.html#i-e-g-barplot"><i class="fa fa-check"></i><b>2.7.2</b> 条形图示例</a></li>
<li class="chapter" data-level="2.7.3" data-path="intro-example.html"><a href="intro-example.html#i-e-g-scatter"><i class="fa fa-check"></i><b>2.7.3</b> 散点图示例</a></li>
<li class="chapter" data-level="2.7.4" data-path="intro-example.html"><a href="intro-example.html#i-e-g-demo"><i class="fa fa-check"></i><b>2.7.4</b> R软件自带的图形示例</a></li>
<li class="chapter" data-level="2.7.5" data-path="intro-example.html"><a href="intro-example.html#i-e-g-ex"><i class="fa fa-check"></i><b>2.7.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.8" data-path="intro-example.html"><a href="intro-example.html#i-e-summary"><i class="fa fa-check"></i><b>2.8</b> 汇总统计示例</a><ul>
<li class="chapter" data-level="2.8.1" data-path="intro-example.html"><a href="intro-example.html#i-e-s-table"><i class="fa fa-check"></i><b>2.8.1</b> 表格数据</a></li>
<li class="chapter" data-level="2.8.2" data-path="intro-example.html"><a href="intro-example.html#i-e-s-t-read-table"><i class="fa fa-check"></i><b>2.8.2</b> 读入表格数据</a></li>
<li class="chapter" data-level="2.8.3" data-path="intro-example.html"><a href="intro-example.html#i-e-s-ex"><i class="fa fa-check"></i><b>2.8.3</b> 练习</a></li>
<li class="chapter" data-level="2.8.4" data-path="intro-example.html"><a href="intro-example.html#i-e-s-qual-freq"><i class="fa fa-check"></i><b>2.8.4</b> 分类变量频数统计</a></li>
<li class="chapter" data-level="2.8.5" data-path="intro-example.html"><a href="intro-example.html#i-e-s-num-summ"><i class="fa fa-check"></i><b>2.8.5</b> 数值型变量的统计</a></li>
<li class="chapter" data-level="2.8.6" data-path="intro-example.html"><a href="intro-example.html#i-e-s-ex2"><i class="fa fa-check"></i><b>2.8.6</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.9" data-path="intro-example.html"><a href="intro-example.html#i-e-source"><i class="fa fa-check"></i><b>2.9</b> 运行源程序文件</a><ul>
<li class="chapter" data-level="2.9.1" data-path="intro-example.html"><a href="intro-example.html#i-e-source-enc"><i class="fa fa-check"></i><b>2.9.1</b> 源文件编码</a></li>
<li class="chapter" data-level="2.9.2" data-path="intro-example.html"><a href="intro-example.html#i-e-cwd"><i class="fa fa-check"></i><b>2.9.2</b> 当前工作目录</a></li>
<li class="chapter" data-level="2.9.3" data-path="intro-example.html"><a href="intro-example.html#i-e-source-ex"><i class="fa fa-check"></i><b>2.9.3</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="2.10" data-path="intro-example.html"><a href="intro-example.html#i-e-appendix-data"><i class="fa fa-check"></i><b>2.10</b> 附录：数据</a><ul>
<li class="chapter" data-level="2.10.1" data-path="intro-example.html"><a href="intro-example.html#i-e-appendix-data-tax"><i class="fa fa-check"></i><b>2.10.1</b> 公司纳税数据样例</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>II 数据类型与相应的运算</b></span></li>
<li class="chapter" data-level="3" data-path="prog-type-intro.html"><a href="prog-type-intro.html"><i class="fa fa-check"></i><b>3</b> 常量与变量</a><ul>
<li class="chapter" data-level="3.1" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-const"><i class="fa fa-check"></i><b>3.1</b> 常量</a></li>
<li class="chapter" data-level="3.2" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-cv-var"><i class="fa fa-check"></i><b>3.2</b> 变量</a></li>
<li class="chapter" data-level="3.3" data-path="prog-type-intro.html"><a href="prog-type-intro.html#p-t-type"><i class="fa fa-check"></i><b>3.3</b> R数据类型</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="prog-type-num.html"><a href="prog-type-num.html"><i class="fa fa-check"></i><b>4</b> 数值型向量及其运算</a><ul>
<li class="chapter" data-level="4.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-num"><i class="fa fa-check"></i><b>4.1</b> 数值型向量</a></li>
<li class="chapter" data-level="4.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith"><i class="fa fa-check"></i><b>4.2</b> 向量运算</a><ul>
<li class="chapter" data-level="4.2.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-scalar"><i class="fa fa-check"></i><b>4.2.1</b> 标量和标量运算</a></li>
<li class="chapter" data-level="4.2.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-with-scalar"><i class="fa fa-check"></i><b>4.2.2</b> 向量与标量运算</a></li>
<li class="chapter" data-level="4.2.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-eq-len"><i class="fa fa-check"></i><b>4.2.3</b> 等长向量运算</a></li>
<li class="chapter" data-level="4.2.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-arith-vec-uneq-len"><i class="fa fa-check"></i><b>4.2.4</b> 不等长向量的运算</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc"><i class="fa fa-check"></i><b>4.3</b> 向量函数</a><ul>
<li class="chapter" data-level="4.3.1" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-vector-func"><i class="fa fa-check"></i><b>4.3.1</b> 向量化的函数</a></li>
<li class="chapter" data-level="4.3.2" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-sort"><i class="fa fa-check"></i><b>4.3.2</b> 排序函数</a></li>
<li class="chapter" data-level="4.3.3" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-stat"><i class="fa fa-check"></i><b>4.3.3</b> 统计函数</a></li>
<li class="chapter" data-level="4.3.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-seq"><i class="fa fa-check"></i><b>4.3.4</b> 生成规则序列的函数</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-complex"><i class="fa fa-check"></i><b>4.4</b> 复数向量</a></li>
<li class="chapter" data-level="4.5" data-path="prog-type-num.html"><a href="prog-type-num.html#p-t-vfunc-ex"><i class="fa fa-check"></i><b>4.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="prog-type-logi.html"><a href="prog-type-logi.html"><i class="fa fa-check"></i><b>5</b> 逻辑型向量及其运算</a><ul>
<li class="chapter" data-level="5.1" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-logical-vec"><i class="fa fa-check"></i><b>5.1</b> 逻辑型向量与比较运算</a></li>
<li class="chapter" data-level="5.2" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-lvec-logic-op"><i class="fa fa-check"></i><b>5.2</b> 逻辑运算</a></li>
<li class="chapter" data-level="5.3" data-path="prog-type-logi.html"><a href="prog-type-logi.html#p-t-lvec-logic-op-vec"><i class="fa fa-check"></i><b>5.3</b> 逻辑运算函数</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="prog-type-char.html"><a href="prog-type-char.html"><i class="fa fa-check"></i><b>6</b> 字符型数据及其处理</a><ul>
<li class="chapter" data-level="6.1" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char"><i class="fa fa-check"></i><b>6.1</b> 字符型向量</a></li>
<li class="chapter" data-level="6.2" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-paste"><i class="fa fa-check"></i><b>6.2</b> <code>paste()</code>函数</a></li>
<li class="chapter" data-level="6.3" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-toupper"><i class="fa fa-check"></i><b>6.3</b> 转换大小写</a></li>
<li class="chapter" data-level="6.4" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-nchar"><i class="fa fa-check"></i><b>6.4</b> 字符串长度</a></li>
<li class="chapter" data-level="6.5" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-substr"><i class="fa fa-check"></i><b>6.5</b> 取子串</a></li>
<li class="chapter" data-level="6.6" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-asnum"><i class="fa fa-check"></i><b>6.6</b> 类型转换</a></li>
<li class="chapter" data-level="6.7" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-strsplit"><i class="fa fa-check"></i><b>6.7</b> 字符串拆分</a></li>
<li class="chapter" data-level="6.8" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-gsub"><i class="fa fa-check"></i><b>6.8</b> 字符串替换功能</a></li>
<li class="chapter" data-level="6.9" data-path="prog-type-char.html"><a href="prog-type-char.html#p-t-char-regexp"><i class="fa fa-check"></i><b>6.9</b> 正则表达式</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="prog-type-index.html"><a href="prog-type-index.html"><i class="fa fa-check"></i><b>7</b> R向量下标和子集</a><ul>
<li class="chapter" data-level="7.1" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-int"><i class="fa fa-check"></i><b>7.1</b> 正整数下标</a></li>
<li class="chapter" data-level="7.2" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-negint"><i class="fa fa-check"></i><b>7.2</b> 负整数下标</a></li>
<li class="chapter" data-level="7.3" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-all"><i class="fa fa-check"></i><b>7.3</b> 空下标与零下标</a></li>
<li class="chapter" data-level="7.4" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-over"><i class="fa fa-check"></i><b>7.4</b> 下标超界</a></li>
<li class="chapter" data-level="7.5" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-logic"><i class="fa fa-check"></i><b>7.5</b> 逻辑下标</a></li>
<li class="chapter" data-level="7.6" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-which"><i class="fa fa-check"></i><b>7.6</b> <code>which()</code>、<code>which.min()</code>、<code>which.max()</code>函数</a></li>
<li class="chapter" data-level="7.7" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-names"><i class="fa fa-check"></i><b>7.7</b> 元素名</a></li>
<li class="chapter" data-level="7.8" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-mapping"><i class="fa fa-check"></i><b>7.8</b> 用R向量下标作映射</a></li>
<li class="chapter" data-level="7.9" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-subset-set"><i class="fa fa-check"></i><b>7.9</b> 集合运算</a></li>
<li class="chapter" data-level="7.10" data-path="prog-type-index.html"><a href="prog-type-index.html#p-t-set-ex"><i class="fa fa-check"></i><b>7.10</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="prog-type-attr.html"><a href="prog-type-attr.html"><i class="fa fa-check"></i><b>8</b> R数据类型的性质</a><ul>
<li class="chapter" data-level="8.1" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-typeof"><i class="fa fa-check"></i><b>8.1</b> 存储模式与基本类型</a></li>
<li class="chapter" data-level="8.2" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-as"><i class="fa fa-check"></i><b>8.2</b> 类型转换与类型升档</a></li>
<li class="chapter" data-level="8.3" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr"><i class="fa fa-check"></i><b>8.3</b> 属性</a><ul>
<li class="chapter" data-level="8.3.1" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-asfun"><i class="fa fa-check"></i><b>8.3.1</b> <code>attributes</code>函数</a></li>
<li class="chapter" data-level="8.3.2" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-attrfun"><i class="fa fa-check"></i><b>8.3.2</b> <code>attr</code>函数</a></li>
<li class="chapter" data-level="8.3.3" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-names"><i class="fa fa-check"></i><b>8.3.3</b> <code>names</code>属性</a></li>
<li class="chapter" data-level="8.3.4" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-attr-dim"><i class="fa fa-check"></i><b>8.3.4</b> <code>dim</code>属性</a></li>
</ul></li>
<li class="chapter" data-level="8.4" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-class"><i class="fa fa-check"></i><b>8.4</b> 类属</a></li>
<li class="chapter" data-level="8.5" data-path="prog-type-attr.html"><a href="prog-type-attr.html#p-t-modes-str"><i class="fa fa-check"></i><b>8.5</b> <code>str()</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="prog-type-date.html"><a href="prog-type-date.html"><i class="fa fa-check"></i><b>9</b> R日期时间</a><ul>
<li class="chapter" data-level="9.1" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-intro"><i class="fa fa-check"></i><b>9.1</b> R日期和日期时间类型</a></li>
<li class="chapter" data-level="9.2" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-fromchr"><i class="fa fa-check"></i><b>9.2</b> 从字符串生成日期数据</a></li>
<li class="chapter" data-level="9.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-format"><i class="fa fa-check"></i><b>9.3</b> 日期显示格式</a></li>
<li class="chapter" data-level="9.4" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-comp"><i class="fa fa-check"></i><b>9.4</b> 访问日期时间的组成值</a></li>
<li class="chapter" data-level="9.5" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-round"><i class="fa fa-check"></i><b>9.5</b> 日期舍入计算</a></li>
<li class="chapter" data-level="9.6" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc"><i class="fa fa-check"></i><b>9.6</b> 日期计算</a><ul>
<li class="chapter" data-level="9.6.1" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-dur"><i class="fa fa-check"></i><b>9.6.1</b> 时间长度</a></li>
<li class="chapter" data-level="9.6.2" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-per"><i class="fa fa-check"></i><b>9.6.2</b> 时间周期</a></li>
<li class="chapter" data-level="9.6.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-calc-int"><i class="fa fa-check"></i><b>9.6.3</b> 时间区间</a></li>
</ul></li>
<li class="chapter" data-level="9.7" data-path="prog-type-date.html"><a href="prog-type-date.html#prog-type-dt-baser"><i class="fa fa-check"></i><b>9.7</b> 基本R软件的日期功能</a><ul>
<li class="chapter" data-level="9.7.1" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-gen"><i class="fa fa-check"></i><b>9.7.1</b> 生成日期和日期时间型数据</a></li>
<li class="chapter" data-level="9.7.2" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-comp"><i class="fa fa-check"></i><b>9.7.2</b> 取出日期时间的组成值</a></li>
<li class="chapter" data-level="9.7.3" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-baser-calc"><i class="fa fa-check"></i><b>9.7.3</b> 日期计算</a></li>
</ul></li>
<li class="chapter" data-level="9.8" data-path="prog-type-date.html"><a href="prog-type-date.html#p-t-date-ex"><i class="fa fa-check"></i><b>9.8</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="prog-type-fact.html"><a href="prog-type-fact.html"><i class="fa fa-check"></i><b>10</b> R因子类型</a><ul>
<li class="chapter" data-level="10.1" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-fact"><i class="fa fa-check"></i><b>10.1</b> 因子</a></li>
<li class="chapter" data-level="10.2" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-table"><i class="fa fa-check"></i><b>10.2</b> <code>table()</code>函数</a></li>
<li class="chapter" data-level="10.3" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-tapply"><i class="fa fa-check"></i><b>10.3</b> <code>tapply()</code>函数</a></li>
<li class="chapter" data-level="10.4" data-path="prog-type-fact.html"><a href="prog-type-fact.html#summ-by-forcats"><i class="fa fa-check"></i><b>10.4</b> forcats包的因子函数</a></li>
<li class="chapter" data-level="10.5" data-path="prog-type-fact.html"><a href="prog-type-fact.html#p-t-factor-ex"><i class="fa fa-check"></i><b>10.5</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="prog-type-list.html"><a href="prog-type-list.html"><i class="fa fa-check"></i><b>11</b> 列表类型</a><ul>
<li class="chapter" data-level="11.1" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list"><i class="fa fa-check"></i><b>11.1</b> 列表</a></li>
<li class="chapter" data-level="11.2" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-access"><i class="fa fa-check"></i><b>11.2</b> 列表元素访问</a></li>
<li class="chapter" data-level="11.3" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-as"><i class="fa fa-check"></i><b>11.3</b> 列表类型转换</a></li>
<li class="chapter" data-level="11.4" data-path="prog-type-list.html"><a href="prog-type-list.html#p-t-list-ex-strsplit"><i class="fa fa-check"></i><b>11.4</b> 返回列表的函数示例–<code>strsplit()</code></a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html"><i class="fa fa-check"></i><b>12</b> R矩阵和数组</a><ul>
<li class="chapter" data-level="12.1" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matrix"><i class="fa fa-check"></i><b>12.1</b> R矩阵</a></li>
<li class="chapter" data-level="12.2" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-subset"><i class="fa fa-check"></i><b>12.2</b> 矩阵子集</a></li>
<li class="chapter" data-level="12.3" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-cbind"><i class="fa fa-check"></i><b>12.3</b> <code>cbind()</code>和<code>rbind()</code>函数</a></li>
<li class="chapter" data-level="12.4" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop"><i class="fa fa-check"></i><b>12.4</b> 矩阵运算</a><ul>
<li class="chapter" data-level="12.4.1" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-arith"><i class="fa fa-check"></i><b>12.4.1</b> 四则运算</a></li>
<li class="chapter" data-level="12.4.2" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-mult"><i class="fa fa-check"></i><b>12.4.2</b> 矩阵乘法</a></li>
<li class="chapter" data-level="12.4.3" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-vecmat"><i class="fa fa-check"></i><b>12.4.3</b> 向量与矩阵相乘</a></li>
<li class="chapter" data-level="12.4.4" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-inprod"><i class="fa fa-check"></i><b>12.4.4</b> 内积</a></li>
<li class="chapter" data-level="12.4.5" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-matop-outer"><i class="fa fa-check"></i><b>12.4.5</b> 外积</a></li>
</ul></li>
<li class="chapter" data-level="12.5" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-solve"><i class="fa fa-check"></i><b>12.5</b> 逆矩阵与线性方程组求解</a></li>
<li class="chapter" data-level="12.6" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-apply"><i class="fa fa-check"></i><b>12.6</b> <code>apply()</code>函数</a></li>
<li class="chapter" data-level="12.7" data-path="prog-type-matrix.html"><a href="prog-type-matrix.html#p-t-array-array"><i class="fa fa-check"></i><b>12.7</b> 多维数组</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="prog-type-df.html"><a href="prog-type-df.html"><i class="fa fa-check"></i><b>13</b> 数据框</a><ul>
<li class="chapter" data-level="13.1" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-dataframe"><i class="fa fa-check"></i><b>13.1</b> 数据框</a></li>
<li class="chapter" data-level="13.2" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-access"><i class="fa fa-check"></i><b>13.2</b> 数据框内容访问</a></li>
<li class="chapter" data-level="13.3" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-rownames"><i class="fa fa-check"></i><b>13.3</b> 数据框的行名</a></li>
<li class="chapter" data-level="13.4" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-notmatrix"><i class="fa fa-check"></i><b>13.4</b> 数据框与矩阵的区别</a></li>
<li class="chapter" data-level="13.5" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-gl-func"><i class="fa fa-check"></i><b>13.5</b> <code>tidyr::expand_grid()</code>函数</a></li>
<li class="chapter" data-level="13.6" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-tibble"><i class="fa fa-check"></i><b>13.6</b> <code>tibble</code>类型</a></li>
<li class="chapter" data-level="13.7" data-path="prog-type-df.html"><a href="prog-type-df.html#p-t-df-ex"><i class="fa fa-check"></i><b>13.7</b> 练习</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="prog-type-ws.html"><a href="prog-type-ws.html"><i class="fa fa-check"></i><b>14</b> 工作空间和变量赋值</a><ul>
<li class="chapter" data-level="14.1" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws"><i class="fa fa-check"></i><b>14.1</b> 工作空间</a></li>
<li class="chapter" data-level="14.2" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-nlvname"><i class="fa fa-check"></i><b>14.2</b> 非法变量名</a></li>
<li class="chapter" data-level="14.3" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws-asign"><i class="fa fa-check"></i><b>14.3</b> 变量赋值与绑定</a></li>
<li class="chapter" data-level="14.4" data-path="prog-type-ws.html"><a href="prog-type-ws.html#p-t-ws-env"><i class="fa fa-check"></i><b>14.4</b> 环境</a></li>
</ul></li>
<li class="part"><span><b>III 编程</b></span></li>
<li class="chapter" data-level="15" data-path="prog-io.html"><a href="prog-io.html"><i class="fa fa-check"></i><b>15</b> R输入输出</a><ul>
<li class="chapter" data-level="15.1" data-path="prog-io.html"><a href="prog-io.html#p-io-simple"><i class="fa fa-check"></i><b>15.1</b> 输入输出的简单方法</a><ul>
<li class="chapter" data-level="15.1.1" data-path="prog-io.html"><a href="prog-io.html#p-io-simple-out"><i class="fa fa-check"></i><b>15.1.1</b> 简单的输出</a></li>
<li class="chapter" data-level="15.1.2" data-path="prog-io.html"><a href="prog-io.html#p-io-simple-input"><i class="fa fa-check"></i><b>15.1.2</b> 简单的输入</a></li>
</ul></li>
<li class="chapter" data-level="15.2" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv"><i class="fa fa-check"></i><b>15.2</b> 读取CSV文件</a><ul>
<li class="chapter" data-level="15.2.1" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-format"><i class="fa fa-check"></i><b>15.2.1</b> CSV格式</a></li>
<li class="chapter" data-level="15.2.2" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-fromstr"><i class="fa fa-check"></i><b>15.2.2</b> 从字符串读入</a></li>
<li class="chapter" data-level="15.2.3" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-opt"><i class="fa fa-check"></i><b>15.2.3</b> <code>read_csv</code>选项</a></li>
<li class="chapter" data-level="15.2.4" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-enc"><i class="fa fa-check"></i><b>15.2.4</b> 编码设置</a></li>
<li class="chapter" data-level="15.2.5" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-na"><i class="fa fa-check"></i><b>15.2.5</b> 缺失值设置</a></li>
<li class="chapter" data-level="15.2.6" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-colt"><i class="fa fa-check"></i><b>15.2.6</b> 各列类型设置</a></li>
<li class="chapter" data-level="15.2.7" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-fact"><i class="fa fa-check"></i><b>15.2.7</b> 因子类型设置</a></li>
<li class="chapter" data-level="15.2.8" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-date"><i class="fa fa-check"></i><b>15.2.8</b> 读入日期</a></li>
<li class="chapter" data-level="15.2.9" data-path="prog-io.html"><a href="prog-io.html#p-io-read-csv-funcs"><i class="fa fa-check"></i><b>15.2.9</b> 其它函数</a></li>
</ul></li>
<li class="chapter" data-level="15.3" data-path="prog-io.html"><a href="prog-io.html#p-io-excel"><i class="fa fa-check"></i><b>15.3</b> Excel表访问</a><ul>
<li class="chapter" data-level="15.3.1" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-csv"><i class="fa fa-check"></i><b>15.3.1</b> 借助于文本格式</a></li>
<li class="chapter" data-level="15.3.2" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-clip"><i class="fa fa-check"></i><b>15.3.2</b> 使用剪贴板</a></li>
<li class="chapter" data-level="15.3.3" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-readxl"><i class="fa fa-check"></i><b>15.3.3</b> 利用readxl扩展包</a></li>
</ul></li>
<li class="chapter" data-level="15.4" data-path="prog-io.html"><a href="prog-io.html#p-io-file"><i class="fa fa-check"></i><b>15.4</b> 文件访问</a><ul>
<li class="chapter" data-level="15.4.1" data-path="prog-io.html"><a href="prog-io.html#p-io-file-conn"><i class="fa fa-check"></i><b>15.4.1</b> 连接</a></li>
<li class="chapter" data-level="15.4.2" data-path="prog-io.html"><a href="prog-io.html#p-io-file-text"><i class="fa fa-check"></i><b>15.4.2</b> 文本文件访问</a></li>
<li class="chapter" data-level="15.4.3" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-batch"><i class="fa fa-check"></i><b>15.4.3</b> 文本文件分批读写</a></li>
<li class="chapter" data-level="15.4.4" data-path="prog-io.html"><a href="prog-io.html#p-io-file-bin"><i class="fa fa-check"></i><b>15.4.4</b> 二进制文件访问</a></li>
<li class="chapter" data-level="15.4.5" data-path="prog-io.html"><a href="prog-io.html#p-io-file-textcon"><i class="fa fa-check"></i><b>15.4.5</b> 字符型连接</a></li>
</ul></li>
<li class="chapter" data-level="15.5" data-path="prog-io.html"><a href="prog-io.html#p-io-enc"><i class="fa fa-check"></i><b>15.5</b> 中文编码问题</a><ul>
<li class="chapter" data-level="15.5.1" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-base"><i class="fa fa-check"></i><b>15.5.1</b> 用基本R的读取函数读取</a></li>
<li class="chapter" data-level="15.5.2" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-readr"><i class="fa fa-check"></i><b>15.5.2</b> 用readr包读取</a></li>
<li class="chapter" data-level="15.5.3" data-path="prog-io.html"><a href="prog-io.html#p-io-enc-write"><i class="fa fa-check"></i><b>15.5.3</b> 输出文件的编码</a></li>
</ul></li>
<li class="chapter" data-level="15.6" data-path="prog-io.html"><a href="prog-io.html#p-io-dir"><i class="fa fa-check"></i><b>15.6</b> 目录和文件管理</a></li>
<li class="chapter" data-level="15.7" data-path="prog-io.html"><a href="prog-io.html#p-io-db"><i class="fa fa-check"></i><b>15.7</b> SQL数据库访问</a><ul>
<li class="chapter" data-level="15.7.1" data-path="prog-io.html"><a href="prog-io.html#p-io-db-intro"><i class="fa fa-check"></i><b>15.7.1</b> 介绍</a></li>
<li class="chapter" data-level="15.7.2" data-path="prog-io.html"><a href="prog-io.html#p-io-db-sqlite"><i class="fa fa-check"></i><b>15.7.2</b> SQLite数据库访问</a></li>
<li class="chapter" data-level="15.7.3" data-path="prog-io.html"><a href="prog-io.html#p-io-db-sql"><i class="fa fa-check"></i><b>15.7.3</b> SQL命令简介</a></li>
<li class="chapter" data-level="15.7.4" data-path="prog-io.html"><a href="prog-io.html#p-io-db-oracle"><i class="fa fa-check"></i><b>15.7.4</b> 访问Oracle数据库</a></li>
<li class="chapter" data-level="15.7.5" data-path="prog-io.html"><a href="prog-io.html#p-io-db-mysql"><i class="fa fa-check"></i><b>15.7.5</b> MySQL数据库访问</a></li>
<li class="chapter" data-level="15.7.6" data-path="prog-io.html"><a href="prog-io.html#p-io-excel-rodbc"><i class="fa fa-check"></i><b>15.7.6</b> 利用RODBC访问Access数据库</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="16" data-path="prog-control.html"><a href="prog-control.html"><i class="fa fa-check"></i><b>16</b> 程序控制结构</a><ul>
<li class="chapter" data-level="16.1" data-path="prog-control.html"><a href="prog-control.html#p-con-exp"><i class="fa fa-check"></i><b>16.1</b> 表达式</a></li>
<li class="chapter" data-level="16.2" data-path="prog-control.html"><a href="prog-control.html#p-con-if"><i class="fa fa-check"></i><b>16.2</b> 分支结构</a><ul>
<li class="chapter" data-level="16.2.1" data-path="prog-control.html"><a href="prog-control.html#p-con-logic-index"><i class="fa fa-check"></i><b>16.2.1</b> 用逻辑下标代替分支结构</a></li>
<li class="chapter" data-level="16.2.2" data-path="prog-control.html"><a href="prog-control.html#p-con-ifelsef"><i class="fa fa-check"></i><b>16.2.2</b> <code>ifelse</code>函数</a></li>
<li class="chapter" data-level="16.2.3" data-path="prog-control.html"><a href="prog-control.html#p-con-switch"><i class="fa fa-check"></i><b>16.2.3</b> <code>switch</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="16.3" data-path="prog-control.html"><a href="prog-control.html#p-con-loop"><i class="fa fa-check"></i><b>16.3</b> 循环结构</a><ul>
<li class="chapter" data-level="16.3.1" data-path="prog-control.html"><a href="prog-control.html#p-con-for"><i class="fa fa-check"></i><b>16.3.1</b> 计数循环</a></li>
<li class="chapter" data-level="16.3.2" data-path="prog-control.html"><a href="prog-control.html#p-con-while"><i class="fa fa-check"></i><b>16.3.2</b> <code>while</code>循环和<code>repeat</code>循环</a></li>
</ul></li>
<li class="chapter" data-level="16.4" data-path="prog-control.html"><a href="prog-control.html#p-con-cond"><i class="fa fa-check"></i><b>16.4</b> R中判断条件</a></li>
<li class="chapter" data-level="16.5" data-path="prog-control.html"><a href="prog-control.html#p-pipe"><i class="fa fa-check"></i><b>16.5</b> 管道控制</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="prog-func.html"><a href="prog-func.html"><i class="fa fa-check"></i><b>17</b> 函数</a><ul>
<li class="chapter" data-level="17.1" data-path="prog-func.html"><a href="prog-func.html#p-func"><i class="fa fa-check"></i><b>17.1</b> 函数基础</a><ul>
<li class="chapter" data-level="17.1.1" data-path="prog-func.html"><a href="prog-func.html#p-func-intro"><i class="fa fa-check"></i><b>17.1.1</b> 介绍</a></li>
<li class="chapter" data-level="17.1.2" data-path="prog-func.html"><a href="prog-func.html#p-func-def"><i class="fa fa-check"></i><b>17.1.2</b> 函数定义</a></li>
<li class="chapter" data-level="17.1.3" data-path="prog-func.html"><a href="prog-func.html#p-func-call"><i class="fa fa-check"></i><b>17.1.3</b> 函数调用</a></li>
<li class="chapter" data-level="17.1.4" data-path="prog-func.html"><a href="prog-func.html#p-func-recursive"><i class="fa fa-check"></i><b>17.1.4</b> 递归调用</a></li>
<li class="chapter" data-level="17.1.5" data-path="prog-func.html"><a href="prog-func.html#p-func-vr"><i class="fa fa-check"></i><b>17.1.5</b> 向量化</a></li>
<li class="chapter" data-level="17.1.6" data-path="prog-func.html"><a href="prog-func.html#p-func-anonymf"><i class="fa fa-check"></i><b>17.1.6</b> 无名函数</a></li>
</ul></li>
<li class="chapter" data-level="17.2" data-path="prog-func.html"><a href="prog-func.html#p-func-space"><i class="fa fa-check"></i><b>17.2</b> 变量作用域</a><ul>
<li class="chapter" data-level="17.2.1" data-path="prog-func.html"><a href="prog-func.html#p-func-global"><i class="fa fa-check"></i><b>17.2.1</b> 全局变量和工作空间</a></li>
<li class="chapter" data-level="17.2.2" data-path="prog-func.html"><a href="prog-func.html#p-func-local"><i class="fa fa-check"></i><b>17.2.2</b> 局部变量</a></li>
<li class="chapter" data-level="17.2.3" data-path="prog-func.html"><a href="prog-func.html#p-func-global-access"><i class="fa fa-check"></i><b>17.2.3</b> 在函数内访问全局变量</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="18" data-path="prog-prof.html"><a href="prog-prof.html"><i class="fa fa-check"></i><b>18</b> R程序效率</a><ul>
<li class="chapter" data-level="18.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-effic"><i class="fa fa-check"></i><b>18.1</b> R的运行效率</a></li>
<li class="chapter" data-level="18.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect"><i class="fa fa-check"></i><b>18.2</b> 向量化编程</a><ul>
<li class="chapter" data-level="18.2.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex1"><i class="fa fa-check"></i><b>18.2.1</b> 示例1</a></li>
<li class="chapter" data-level="18.2.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex2"><i class="fa fa-check"></i><b>18.2.2</b> 示例2</a></li>
<li class="chapter" data-level="18.2.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-vect-ex3"><i class="fa fa-check"></i><b>18.2.3</b> 示例3</a></li>
</ul></li>
<li class="chapter" data-level="18.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-loop"><i class="fa fa-check"></i><b>18.3</b> 减少显式循环</a><ul>
<li class="chapter" data-level="18.3.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-replicate"><i class="fa fa-check"></i><b>18.3.1</b> <code>replicate()</code>函数</a></li>
</ul></li>
<li class="chapter" data-level="18.4" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-copy"><i class="fa fa-check"></i><b>18.4</b> 避免制作副本</a></li>
<li class="chapter" data-level="18.5" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun"><i class="fa fa-check"></i><b>18.5</b> R的计算函数</a><ul>
<li class="chapter" data-level="18.5.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-math"><i class="fa fa-check"></i><b>18.5.1</b> 数学函数</a></li>
<li class="chapter" data-level="18.5.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-sum"><i class="fa fa-check"></i><b>18.5.2</b> 概括函数</a></li>
<li class="chapter" data-level="18.5.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-max"><i class="fa fa-check"></i><b>18.5.3</b> 最值</a></li>
<li class="chapter" data-level="18.5.4" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-sort"><i class="fa fa-check"></i><b>18.5.4</b> 排序</a></li>
<li class="chapter" data-level="18.5.5" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-integrate"><i class="fa fa-check"></i><b>18.5.5</b> 一元定积分<code>integrate</code></a></li>
<li class="chapter" data-level="18.5.6" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-uniroot"><i class="fa fa-check"></i><b>18.5.6</b> 一元函数求根<code>uniroot</code></a></li>
<li class="chapter" data-level="18.5.7" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-fft"><i class="fa fa-check"></i><b>18.5.7</b> 离散傅立叶变换<code>fft</code></a></li>
<li class="chapter" data-level="18.5.8" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mathfun-filter"><i class="fa fa-check"></i><b>18.5.8</b> 用<code>filter</code>函数作迭代</a></li>
</ul></li>
<li class="chapter" data-level="18.6" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu"><i class="fa fa-check"></i><b>18.6</b> 并行计算</a><ul>
<li class="chapter" data-level="18.6.1" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex1"><i class="fa fa-check"></i><b>18.6.1</b> 例1：完全不互相依赖的并行运算</a></li>
<li class="chapter" data-level="18.6.2" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex2"><i class="fa fa-check"></i><b>18.6.2</b> 例2：使用相同随机数序列的并行计算</a></li>
<li class="chapter" data-level="18.6.3" data-path="prog-prof.html"><a href="prog-prof.html#p-prof-mcpu-ex3"><i class="fa fa-check"></i><b>18.6.3</b> 例3：使用独立随机数序列的并行计算</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="19" data-path="p-advfunc.html"><a href="p-advfunc.html"><i class="fa fa-check"></i><b>19</b> 函数进阶</a><ul>
<li class="chapter" data-level="19.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-callspe"><i class="fa fa-check"></i><b>19.1</b> 函数调用的各种形式</a></li>
<li class="chapter" data-level="19.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-lex"><i class="fa fa-check"></i><b>19.2</b> 嵌套定义与句法作用域(lexical scoping)</a></li>
<li class="chapter" data-level="19.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-inner"><i class="fa fa-check"></i><b>19.3</b> 辅助嵌套函数</a></li>
<li class="chapter" data-level="19.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-lazy"><i class="fa fa-check"></i><b>19.4</b> 懒惰求值</a></li>
<li class="chapter" data-level="19.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug"><i class="fa fa-check"></i><b>19.5</b> 程序调试</a><ul>
<li class="chapter" data-level="19.5.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-intro"><i class="fa fa-check"></i><b>19.5.1</b> 基本调试策略</a></li>
<li class="chapter" data-level="19.5.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-findfunc"><i class="fa fa-check"></i><b>19.5.2</b> 找到出错的函数</a></li>
<li class="chapter" data-level="19.5.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-browser"><i class="fa fa-check"></i><b>19.5.3</b> 跟踪调试</a></li>
<li class="chapter" data-level="19.5.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-cond"><i class="fa fa-check"></i><b>19.5.4</b> 条件断点</a></li>
<li class="chapter" data-level="19.5.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-debugf"><i class="fa fa-check"></i><b>19.5.5</b> 开启对一个函数的调试</a></li>
<li class="chapter" data-level="19.5.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-opt"><i class="fa fa-check"></i><b>19.5.6</b> 出错调试选项</a></li>
<li class="chapter" data-level="19.5.7" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-stop"><i class="fa fa-check"></i><b>19.5.7</b> <code>stop()</code>、<code>warning()</code>、<code>message()</code></a></li>
<li class="chapter" data-level="19.5.8" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-preventive"><i class="fa fa-check"></i><b>19.5.8</b> 预防性设计</a></li>
<li class="chapter" data-level="19.5.9" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-debug-try"><i class="fa fa-check"></i><b>19.5.9</b> 出错处理机制</a></li>
</ul></li>
<li class="chapter" data-level="19.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-funcprog"><i class="fa fa-check"></i><b>19.6</b> 函数式编程介绍</a><ul>
<li class="chapter" data-level="19.6.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-pure"><i class="fa fa-check"></i><b>19.6.1</b> 纯函数</a></li>
<li class="chapter" data-level="19.6.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-rec"><i class="fa fa-check"></i><b>19.6.2</b> 副作用和运行环境恢复</a></li>
<li class="chapter" data-level="19.6.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-rsupp"><i class="fa fa-check"></i><b>19.6.3</b> R的函数式编程功能</a></li>
</ul></li>
<li class="chapter" data-level="19.7" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-functional"><i class="fa fa-check"></i><b>19.7</b> 泛函</a><ul>
<li class="chapter" data-level="19.7.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-map"><i class="fa fa-check"></i><b>19.7.1</b> <code>purrr::map</code>函数</a></li>
<li class="chapter" data-level="19.7.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-mapv"><i class="fa fa-check"></i><b>19.7.2</b> purrr包中<code>map</code>函数的变种</a></li>
<li class="chapter" data-level="19.7.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-reduce"><i class="fa fa-check"></i><b>19.7.3</b> purrr包中<code>reduce</code>类函数</a></li>
<li class="chapter" data-level="19.7.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-pred"><i class="fa fa-check"></i><b>19.7.4</b> purrr包中使用示性函数的泛函</a></li>
<li class="chapter" data-level="19.7.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-lapp"><i class="fa fa-check"></i><b>19.7.5</b> 基本R的函数式编程支持</a></li>
<li class="chapter" data-level="19.7.6" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-fnctnl-udef"><i class="fa fa-check"></i><b>19.7.6</b> 自定义泛函</a></li>
</ul></li>
<li class="chapter" data-level="19.8" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory"><i class="fa fa-check"></i><b>19.8</b> 函数工厂</a><ul>
<li class="chapter" data-level="19.8.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-clex"><i class="fa fa-check"></i><b>19.8.1</b> 闭包例子</a></li>
<li class="chapter" data-level="19.8.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-lazy"><i class="fa fa-check"></i><b>19.8.2</b> 动态查找和懒惰求值引起的问题</a></li>
<li class="chapter" data-level="19.8.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-factory-mem"><i class="fa fa-check"></i><b>19.8.3</b> 函数工厂的内存负担</a></li>
<li class="chapter" data-level="19.8.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-operator"><i class="fa fa-check"></i><b>19.8.4</b> 函数算子</a></li>
</ul></li>
<li class="chapter" data-level="19.9" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env"><i class="fa fa-check"></i><b>19.9</b> 环境</a><ul>
<li class="chapter" data-level="19.9.1" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-def"><i class="fa fa-check"></i><b>19.9.1</b> 基本概念</a></li>
<li class="chapter" data-level="19.9.2" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-recurs"><i class="fa fa-check"></i><b>19.9.2</b> 逐层向上访问环境</a></li>
<li class="chapter" data-level="19.9.3" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-spec"><i class="fa fa-check"></i><b>19.9.3</b> 特殊环境</a></li>
<li class="chapter" data-level="19.9.4" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-callst"><i class="fa fa-check"></i><b>19.9.4</b> 调用栈</a></li>
<li class="chapter" data-level="19.9.5" data-path="p-advfunc.html"><a href="p-advfunc.html#p-advfunc-env-usedt"><i class="fa fa-check"></i><b>19.9.5</b> 将环境用作一般数据结构</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>IV 制作研究报告和图书</b></span></li>
<li class="chapter" data-level="20" data-path="knitr.html"><a href="knitr.html"><i class="fa fa-check"></i><b>20</b> 用R制作研究报告</a></li>
<li class="chapter" data-level="21" data-path="markdown.html"><a href="markdown.html"><i class="fa fa-check"></i><b>21</b> Markdown格式</a><ul>
<li class="chapter" data-level="21.1" data-path="markdown.html"><a href="markdown.html#markdown-intro"><i class="fa fa-check"></i><b>21.1</b> 介绍</a></li>
<li class="chapter" data-level="21.2" data-path="markdown.html"><a href="markdown.html#markdown-app"><i class="fa fa-check"></i><b>21.2</b> Markdown格式文件的应用</a></li>
<li class="chapter" data-level="21.3" data-path="markdown.html"><a href="markdown.html#markdown-format"><i class="fa fa-check"></i><b>21.3</b> markdown格式说明</a><ul>
<li class="chapter" data-level="21.3.1" data-path="markdown.html"><a href="markdown.html#markdown-format-intro"><i class="fa fa-check"></i><b>21.3.1</b> 概述</a></li>
<li class="chapter" data-level="21.3.2" data-path="markdown.html"><a href="markdown.html#markdown-format-paragraph"><i class="fa fa-check"></i><b>21.3.2</b> 段落</a></li>
<li class="chapter" data-level="21.3.3" data-path="markdown.html"><a href="markdown.html#markdown-format-inline"><i class="fa fa-check"></i><b>21.3.3</b> 段内文字格式</a></li>
<li class="chapter" data-level="21.3.4" data-path="markdown.html"><a href="markdown.html#markdown-format-header"><i class="fa fa-check"></i><b>21.3.4</b> 标题和分隔线</a></li>
<li class="chapter" data-level="21.3.5" data-path="markdown.html"><a href="markdown.html#markdown-format-cite"><i class="fa fa-check"></i><b>21.3.5</b> 引用段落</a></li>
<li class="chapter" data-level="21.3.6" data-path="markdown.html"><a href="markdown.html#markdown-format-list"><i class="fa fa-check"></i><b>21.3.6</b> 列表</a></li>
<li class="chapter" data-level="21.3.7" data-path="markdown.html"><a href="markdown.html#markdown-format-code"><i class="fa fa-check"></i><b>21.3.7</b> 源程序</a></li>
<li class="chapter" data-level="21.3.8" data-path="markdown.html"><a href="markdown.html#markdown-format-link"><i class="fa fa-check"></i><b>21.3.8</b> 链接</a></li>
<li class="chapter" data-level="21.3.9" data-path="markdown.html"><a href="markdown.html#markdown-format-fig"><i class="fa fa-check"></i><b>21.3.9</b> 插入图形</a></li>
<li class="chapter" data-level="21.3.10" data-path="markdown.html"><a href="markdown.html#markdown-format-table"><i class="fa fa-check"></i><b>21.3.10</b> 表格</a></li>
</ul></li>
<li class="chapter" data-level="21.4" data-path="markdown.html"><a href="markdown.html#markdown-pandoc"><i class="fa fa-check"></i><b>21.4</b> 附录：pandoc软件介绍</a></li>
</ul></li>
<li class="chapter" data-level="22" data-path="rmarkdown.html"><a href="rmarkdown.html"><i class="fa fa-check"></i><b>22</b> R Markdown文件格式</a><ul>
<li class="chapter" data-level="22.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-intro"><i class="fa fa-check"></i><b>22.1</b> R Markdown文件</a></li>
<li class="chapter" data-level="22.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-compile"><i class="fa fa-check"></i><b>22.2</b> R Markdown文件的编译</a><ul>
<li class="chapter" data-level="22.2.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-compile-proc"><i class="fa fa-check"></i><b>22.2.1</b> 编译的实际过程</a></li>
</ul></li>
<li class="chapter" data-level="22.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode"><i class="fa fa-check"></i><b>22.3</b> 在R Markdown文件中插入R代码</a></li>
<li class="chapter" data-level="22.4" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-kable"><i class="fa fa-check"></i><b>22.4</b> 输出表格</a></li>
<li class="chapter" data-level="22.5" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-graph"><i class="fa fa-check"></i><b>22.5</b> 利用R程序插图</a></li>
<li class="chapter" data-level="22.6" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-opt"><i class="fa fa-check"></i><b>22.6</b> 代码段选项</a><ul>
<li class="chapter" data-level="22.6.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-outformat"><i class="fa fa-check"></i><b>22.6.1</b> 代码和文本输出结果格式</a></li>
<li class="chapter" data-level="22.6.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-figopt"><i class="fa fa-check"></i><b>22.6.2</b> 图形选项</a></li>
<li class="chapter" data-level="22.6.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-rcode-cache"><i class="fa fa-check"></i><b>22.6.3</b> 缓存(cache)选项</a></li>
</ul></li>
<li class="chapter" data-level="22.7" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd--sectionlink"><i class="fa fa-check"></i><b>22.7</b> 章节目录链接问题</a></li>
<li class="chapter" data-level="22.8" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula"><i class="fa fa-check"></i><b>22.8</b> 数学公式</a><ul>
<li class="chapter" data-level="22.8.1" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-intro"><i class="fa fa-check"></i><b>22.8.1</b> 在Markdown中输入数学公式</a></li>
<li class="chapter" data-level="22.8.2" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-type"><i class="fa fa-check"></i><b>22.8.2</b> 数学公式类别</a></li>
<li class="chapter" data-level="22.8.3" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-basic"><i class="fa fa-check"></i><b>22.8.3</b> 基本功能</a></li>
<li class="chapter" data-level="22.8.4" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-accent"><i class="fa fa-check"></i><b>22.8.4</b> 修饰符</a></li>
<li class="chapter" data-level="22.8.5" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-align"><i class="fa fa-check"></i><b>22.8.5</b> 对齐与矩阵</a></li>
<li class="chapter" data-level="22.8.6" data-path="rmarkdown.html"><a href="rmarkdown.html#markdown-formula-fonts"><i class="fa fa-check"></i><b>22.8.6</b> 特殊字体</a></li>
</ul></li>
<li class="chapter" data-level="22.9" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-engines"><i class="fa fa-check"></i><b>22.9</b> 其它编程语言引擎</a></li>
<li class="chapter" data-level="22.10" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-interact"><i class="fa fa-check"></i><b>22.10</b> 交互内容</a></li>
<li class="chapter" data-level="22.11" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-attryaml"><i class="fa fa-check"></i><b>22.11</b> 属性设置</a><ul>
<li class="chapter" data-level="22.11.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-yaml"><i class="fa fa-check"></i><b>22.11.1</b> YAML元数据</a></li>
<li class="chapter" data-level="22.11.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-types"><i class="fa fa-check"></i><b>22.11.2</b> 输出格式</a></li>
<li class="chapter" data-level="22.11.3" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr"><i class="fa fa-check"></i><b>22.11.3</b> 输出格式设置</a></li>
<li class="chapter" data-level="22.11.4" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-toc"><i class="fa fa-check"></i><b>22.11.4</b> 目录设置</a></li>
<li class="chapter" data-level="22.11.5" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-numsec"><i class="fa fa-check"></i><b>22.11.5</b> 章节自动编号</a></li>
<li class="chapter" data-level="22.11.6" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-attr-wordnumsec"><i class="fa fa-check"></i><b>22.11.6</b> Word输出章节自动编号及模板功能</a></li>
<li class="chapter" data-level="22.11.7" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-htmlspecific"><i class="fa fa-check"></i><b>22.11.7</b> HTML特有输出格式设置</a></li>
<li class="chapter" data-level="22.11.8" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-mathjax"><i class="fa fa-check"></i><b>22.11.8</b> 关于数学公式支持的设置</a></li>
<li class="chapter" data-level="22.11.9" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-output-yml"><i class="fa fa-check"></i><b>22.11.9</b> 输出设置文件</a></li>
</ul></li>
<li class="chapter" data-level="22.12" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex"><i class="fa fa-check"></i><b>22.12</b> LaTeX和PDF输出</a><ul>
<li class="chapter" data-level="22.12.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex-tinytex"><i class="fa fa-check"></i><b>22.12.1</b> TinyTex的安装使用</a></li>
<li class="chapter" data-level="22.12.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmd-latex-yaml"><i class="fa fa-check"></i><b>22.12.2</b> Rmd中Latex设置</a></li>
</ul></li>
<li class="chapter" data-level="22.13" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-rticles"><i class="fa fa-check"></i><b>22.13</b> 生成期刊文章</a></li>
<li class="chapter" data-level="22.14" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1"><i class="fa fa-check"></i><b>22.14</b> 附录：经验与问题</a><ul>
<li class="chapter" data-level="22.14.1" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1-wordtemplate"><i class="fa fa-check"></i><b>22.14.1</b> Word模板制作</a></li>
<li class="chapter" data-level="22.14.2" data-path="rmarkdown.html"><a href="rmarkdown.html#rmarkdown-app1-math"><i class="fa fa-check"></i><b>22.14.2</b> 数学公式设置补充</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="23" data-path="bookdown.html"><a href="bookdown.html"><i class="fa fa-check"></i><b>23</b> 用bookdown制作图书</a><ul>
<li class="chapter" data-level="23.1" data-path="bookdown.html"><a href="bookdown.html#bookdown-intro"><i class="fa fa-check"></i><b>23.1</b> 介绍</a></li>
<li class="chapter" data-level="23.2" data-path="bookdown.html"><a href="bookdown.html#bookdown-settings"><i class="fa fa-check"></i><b>23.2</b> 一本书的设置</a></li>
<li class="chapter" data-level="23.3" data-path="bookdown.html"><a href="bookdown.html#bookdown-sectioning"><i class="fa fa-check"></i><b>23.3</b> 章节结构</a></li>
<li class="chapter" data-level="23.4" data-path="bookdown.html"><a href="bookdown.html#bookdown-compile"><i class="fa fa-check"></i><b>23.4</b> 书的编译</a></li>
<li class="chapter" data-level="23.5" data-path="bookdown.html"><a href="bookdown.html#bookdown-cref"><i class="fa fa-check"></i><b>23.5</b> 交叉引用</a></li>
<li class="chapter" data-level="23.6" data-path="bookdown.html"><a href="bookdown.html#bookdown-formula"><i class="fa fa-check"></i><b>23.6</b> 数学公式和公式编号</a></li>
<li class="chapter" data-level="23.7" data-path="bookdown.html"><a href="bookdown.html#bookdown-theorem"><i class="fa fa-check"></i><b>23.7</b> 定理类编号</a></li>
<li class="chapter" data-level="23.8" data-path="bookdown.html"><a href="bookdown.html#bookdown-bib"><i class="fa fa-check"></i><b>23.8</b> 文献引用</a></li>
<li class="chapter" data-level="23.9" data-path="bookdown.html"><a href="bookdown.html#bookdown-graph"><i class="fa fa-check"></i><b>23.9</b> 插图</a></li>
<li class="chapter" data-level="23.10" data-path="bookdown.html"><a href="bookdown.html#bookdown-table"><i class="fa fa-check"></i><b>23.10</b> 表格</a><ul>
<li class="chapter" data-level="23.10.1" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-md"><i class="fa fa-check"></i><b>23.10.1</b> Markdown表格</a></li>
<li class="chapter" data-level="23.10.2" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-kable"><i class="fa fa-check"></i><b>23.10.2</b> 用<code>kable()</code>函数制作表格</a></li>
<li class="chapter" data-level="23.10.3" data-path="bookdown.html"><a href="bookdown.html#bookdown-table-kable"><i class="fa fa-check"></i><b>23.10.3</b> R中其它制作表格的包</a></li>
</ul></li>
<li class="chapter" data-level="23.11" data-path="bookdown.html"><a href="bookdown.html#bookdown-mathjax"><i class="fa fa-check"></i><b>23.11</b> 数学公式的设置</a></li>
<li class="chapter" data-level="23.12" data-path="bookdown.html"><a href="bookdown.html#bookdown-exp"><i class="fa fa-check"></i><b>23.12</b> 使用经验</a></li>
<li class="chapter" data-level="23.13" data-path="bookdown.html"><a href="bookdown.html#bookdown-bugs"><i class="fa fa-check"></i><b>23.13</b> bookdown的一些使用问题</a></li>
</ul></li>
<li class="chapter" data-level="24" data-path="rmdsite.html"><a href="rmdsite.html"><i class="fa fa-check"></i><b>24</b> 用R Markdown制作简易网站</a><ul>
<li class="chapter" data-level="24.1" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-intro"><i class="fa fa-check"></i><b>24.1</b> 介绍</a></li>
<li class="chapter" data-level="24.2" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown"><i class="fa fa-check"></i><b>24.2</b> 简易网站制作</a><ul>
<li class="chapter" data-level="24.2.1" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-struct"><i class="fa fa-check"></i><b>24.2.1</b> 网站结构</a></li>
<li class="chapter" data-level="24.2.2" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-build"><i class="fa fa-check"></i><b>24.2.2</b> 编译</a></li>
<li class="chapter" data-level="24.2.3" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-pages"><i class="fa fa-check"></i><b>24.2.3</b> 内容文件</a></li>
<li class="chapter" data-level="24.2.4" data-path="rmdsite.html"><a href="rmdsite.html#rmdsite-rmarkdown-config"><i class="fa fa-check"></i><b>24.2.4</b> 网站设置</a></li>
</ul></li>
<li class="chapter" data-level="24.3" data-path="rmdsite.html"><a href="rmdsite.html#blogdown"><i class="fa fa-check"></i><b>24.3</b> 用blogdown制作网站</a><ul>
<li class="chapter" data-level="24.3.1" data-path="rmdsite.html"><a href="rmdsite.html#blogd-new"><i class="fa fa-check"></i><b>24.3.1</b> 生成新网站的框架</a></li>
<li class="chapter" data-level="24.3.2" data-path="rmdsite.html"><a href="rmdsite.html#blogd-page"><i class="fa fa-check"></i><b>24.3.2</b> 网页内容文件及其设置</a></li>
<li class="chapter" data-level="24.3.3" data-path="rmdsite.html"><a href="rmdsite.html#blogd-workflow"><i class="fa fa-check"></i><b>24.3.3</b> 初学者的工作流程</a></li>
<li class="chapter" data-level="24.3.4" data-path="rmdsite.html"><a href="rmdsite.html#blogd-config"><i class="fa fa-check"></i><b>24.3.4</b> 网站设置文件</a></li>
<li class="chapter" data-level="24.3.5" data-path="rmdsite.html"><a href="rmdsite.html#blogd-static"><i class="fa fa-check"></i><b>24.3.5</b> 静态文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="25" data-path="slides.html"><a href="slides.html"><i class="fa fa-check"></i><b>25</b> 制作幻灯片</a><ul>
<li class="chapter" data-level="25.1" data-path="slides.html"><a href="slides.html#rmd-slides-intro"><i class="fa fa-check"></i><b>25.1</b> 介绍</a></li>
<li class="chapter" data-level="25.2" data-path="slides.html"><a href="slides.html#rmd-slidy"><i class="fa fa-check"></i><b>25.2</b> Slidy幻灯片</a><ul>
<li class="chapter" data-level="25.2.1" data-path="slides.html"><a href="slides.html#rmd-slidy-format"><i class="fa fa-check"></i><b>25.2.1</b> 文件格式</a></li>
<li class="chapter" data-level="25.2.2" data-path="slides.html"><a href="slides.html#rmd-slidy-compile"><i class="fa fa-check"></i><b>25.2.2</b> 幻灯片编译</a></li>
<li class="chapter" data-level="25.2.3" data-path="slides.html"><a href="slides.html#rmd-slidy-play"><i class="fa fa-check"></i><b>25.2.3</b> 播放控制</a></li>
<li class="chapter" data-level="25.2.4" data-path="slides.html"><a href="slides.html#rmd-slidy-handout"><i class="fa fa-check"></i><b>25.2.4</b> 生成单页HTML</a></li>
<li class="chapter" data-level="25.2.5" data-path="slides.html"><a href="slides.html#rmd-slidy-mathjax"><i class="fa fa-check"></i><b>25.2.5</b> 数学公式处理与输出设置文件</a></li>
<li class="chapter" data-level="25.2.6" data-path="slides.html"><a href="slides.html#rmd-slidy-options"><i class="fa fa-check"></i><b>25.2.6</b> 其它选项</a></li>
<li class="chapter" data-level="25.2.7" data-path="slides.html"><a href="slides.html#rmd-slidy-laser"><i class="fa fa-check"></i><b>25.2.7</b> slidy幻灯片激光笔失效问题的修改</a></li>
</ul></li>
<li class="chapter" data-level="25.3" data-path="slides.html"><a href="slides.html#rmdslides-pp"><i class="fa fa-check"></i><b>25.3</b> MS PowerPoint幻灯片</a></li>
<li class="chapter" data-level="25.4" data-path="slides.html"><a href="slides.html#rmdslides-beamer"><i class="fa fa-check"></i><b>25.4</b> Bearmer幻灯片格式</a></li>
<li class="chapter" data-level="25.5" data-path="slides.html"><a href="slides.html#rmdslides-rpres"><i class="fa fa-check"></i><b>25.5</b> R Presentation格式</a></li>
</ul></li>
<li class="part"><span><b>V 数据整理与汇总</b></span></li>
<li class="chapter" data-level="26" data-path="summary-manip.html"><a href="summary-manip.html"><i class="fa fa-check"></i><b>26</b> 数据整理</a><ul>
<li class="chapter" data-level="26.1" data-path="summary-manip.html"><a href="summary-manip.html#summm-tidyv"><i class="fa fa-check"></i><b>26.1</b> tidyverse系统</a></li>
<li class="chapter" data-level="26.2" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-filter"><i class="fa fa-check"></i><b>26.2</b> 用<code>filter()</code>选择行子集</a></li>
<li class="chapter" data-level="26.3" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-head"><i class="fa fa-check"></i><b>26.3</b> 按行序号选择行子集</a></li>
<li class="chapter" data-level="26.4" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-samplen"><i class="fa fa-check"></i><b>26.4</b> 用<code>sample_n()</code>对观测随机抽样</a></li>
<li class="chapter" data-level="26.5" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-distinct"><i class="fa fa-check"></i><b>26.5</b> 用<code>distinct()</code>去除重复行</a></li>
<li class="chapter" data-level="26.6" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-dropna"><i class="fa fa-check"></i><b>26.6</b> 用<code>drop_na()</code>去除指定的变量有缺失值的行</a></li>
<li class="chapter" data-level="26.7" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-select"><i class="fa fa-check"></i><b>26.7</b> 用<code>select()</code>选择列子集</a></li>
<li class="chapter" data-level="26.8" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-pull"><i class="fa fa-check"></i><b>26.8</b> 取出单个变量为向量</a></li>
<li class="chapter" data-level="26.9" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-arrange"><i class="fa fa-check"></i><b>26.9</b> 用<code>arrange()</code>排序</a></li>
<li class="chapter" data-level="26.10" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-rename"><i class="fa fa-check"></i><b>26.10</b> 用<code>rename()</code>修改变量名</a></li>
<li class="chapter" data-level="26.11" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-mutate"><i class="fa fa-check"></i><b>26.11</b> 用<code>mutate()</code>计算新变量</a></li>
<li class="chapter" data-level="26.12" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-transmute"><i class="fa fa-check"></i><b>26.12</b> 用<code>tranmute()</code>生成新变量的数据框</a></li>
<li class="chapter" data-level="26.13" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-pipe"><i class="fa fa-check"></i><b>26.13</b> 用管道连接多次操作</a></li>
<li class="chapter" data-level="26.14" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer"><i class="fa fa-check"></i><b>26.14</b> 宽表转换为长表</a><ul>
<li class="chapter" data-level="26.14.1" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-pl"><i class="fa fa-check"></i><b>26.14.1</b> <code>pivot_longer</code>函数</a></li>
<li class="chapter" data-level="26.14.2" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-prefixvalue"><i class="fa fa-check"></i><b>26.14.2</b> 从列名中提取数值</a></li>
<li class="chapter" data-level="26.14.3" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-colnamemultclassv"><i class="fa fa-check"></i><b>26.14.3</b> 从列名中提取多个分类变量值</a></li>
<li class="chapter" data-level="26.14.4" data-path="summary-manip.html"><a href="summary-manip.html#tidyr-longer-multvarsmultclassv"><i class="fa fa-check"></i><b>26.14.4</b> 一行中有多个属性的多次观测的情形</a></li>
</ul></li>
<li class="chapter" data-level="26.15" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider"><i class="fa fa-check"></i><b>26.15</b> 长表转换为宽表</a><ul>
<li class="chapter" data-level="26.15.1" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-sepvars"><i class="fa fa-check"></i><b>26.15.1</b> 将多个混在一起的变量拆开</a></li>
<li class="chapter" data-level="26.15.2" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-combtimes"><i class="fa fa-check"></i><b>26.15.2</b> 将多个类别合并到一个观测</a></li>
<li class="chapter" data-level="26.15.3" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-combcross"><i class="fa fa-check"></i><b>26.15.3</b> 将交叉类别合并到一个观测</a></li>
<li class="chapter" data-level="26.15.4" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-mvmest"><i class="fa fa-check"></i><b>26.15.4</b> 多个变量的多种值</a></li>
<li class="chapter" data-level="26.15.5" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-wider-mixed"><i class="fa fa-check"></i><b>26.15.5</b> 长宽转换混合使用</a></li>
</ul></li>
<li class="chapter" data-level="26.16" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-spearate"><i class="fa fa-check"></i><b>26.16</b> 拆分数据列</a></li>
<li class="chapter" data-level="26.17" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-unite"><i class="fa fa-check"></i><b>26.17</b> 合并数据列</a></li>
<li class="chapter" data-level="26.18" data-path="summary-manip.html"><a href="summary-manip.html#summ-trans-combv"><i class="fa fa-check"></i><b>26.18</b> 数据框纵向合并</a></li>
<li class="chapter" data-level="26.19" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-join"><i class="fa fa-check"></i><b>26.19</b> 横向合并</a></li>
<li class="chapter" data-level="26.20" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-semi"><i class="fa fa-check"></i><b>26.20</b> 利用第二个数据集筛选</a></li>
<li class="chapter" data-level="26.21" data-path="summary-manip.html"><a href="summary-manip.html#dplyr-set"><i class="fa fa-check"></i><b>26.21</b> 数据集的集合操作</a></li>
<li class="chapter" data-level="26.22" data-path="summary-manip.html"><a href="summary-manip.html#summ-trans-standard"><i class="fa fa-check"></i><b>26.22</b> 标准化</a></li>
</ul></li>
<li class="chapter" data-level="27" data-path="summary-summ.html"><a href="summary-summ.html"><i class="fa fa-check"></i><b>27</b> 数据汇总</a><ul>
<li class="chapter" data-level="27.1" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-summ"><i class="fa fa-check"></i><b>27.1</b> 用dplyr作数据汇总</a></li>
<li class="chapter" data-level="27.2" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-summat"><i class="fa fa-check"></i><b>27.2</b> 多个变量的汇总</a></li>
<li class="chapter" data-level="27.3" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-groupby"><i class="fa fa-check"></i><b>27.3</b> 用dplyr作数据分组汇总</a></li>
<li class="chapter" data-level="27.4" data-path="summary-summ.html"><a href="summary-summ.html#dplyr-crossgroup"><i class="fa fa-check"></i><b>27.4</b> 交叉分类的汇总</a></li>
<li class="chapter" data-level="27.5" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest"><i class="fa fa-check"></i><b>27.5</b> tibble中的列表列</a><ul>
<li class="chapter" data-level="27.5.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-intro"><i class="fa fa-check"></i><b>27.5.1</b> <code>nest</code>和<code>unnest</code></a></li>
<li class="chapter" data-level="27.5.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-groupby"><i class="fa fa-check"></i><b>27.5.2</b> <code>group_by</code>与<code>nest</code>配合</a></li>
<li class="chapter" data-level="27.5.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-summarise"><i class="fa fa-check"></i><b>27.5.3</b> <code>summarise</code>统计量用列表表示</a></li>
<li class="chapter" data-level="27.5.4" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-unnest-grammar"><i class="fa fa-check"></i><b>27.5.4</b> <code>unnest</code>的语法格式</a></li>
<li class="chapter" data-level="27.5.5" data-path="summary-summ.html"><a href="summary-summ.html#summ-nest-direct"><i class="fa fa-check"></i><b>27.5.5</b> 直接生成列表类型的列</a></li>
</ul></li>
<li class="chapter" data-level="27.6" data-path="summary-summ.html"><a href="summary-summ.html#summ-base"><i class="fa fa-check"></i><b>27.6</b> 基本R的汇总功能</a><ul>
<li class="chapter" data-level="27.6.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-base-summary"><i class="fa fa-check"></i><b>27.6.1</b> <code>summary()</code>函数</a></li>
<li class="chapter" data-level="27.6.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-cont"><i class="fa fa-check"></i><b>27.6.2</b> 连续型变量概括函数</a></li>
<li class="chapter" data-level="27.6.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-fact"><i class="fa fa-check"></i><b>27.6.3</b> 分类变量概括</a></li>
<li class="chapter" data-level="27.6.4" data-path="summary-summ.html"><a href="summary-summ.html#summ-df"><i class="fa fa-check"></i><b>27.6.4</b> 数据框概括</a></li>
</ul></li>
<li class="chapter" data-level="27.7" data-path="summary-summ.html"><a href="summary-summ.html#summ-by"><i class="fa fa-check"></i><b>27.7</b> 用基本R作分类概括</a><ul>
<li class="chapter" data-level="27.7.1" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-tapply"><i class="fa fa-check"></i><b>27.7.1</b> 用<code>tapply()</code>分组概括向量</a></li>
<li class="chapter" data-level="27.7.2" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-aggregate"><i class="fa fa-check"></i><b>27.7.2</b> 用<code>aggregate()</code>分组概括数据框</a></li>
<li class="chapter" data-level="27.7.3" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-split"><i class="fa fa-check"></i><b>27.7.3</b> 用<code>split()</code>函数分组后概括</a></li>
</ul></li>
<li class="chapter" data-level="27.8" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-plyr"><i class="fa fa-check"></i><b>27.8</b> 用plyr包进行分类概括</a></li>
<li class="chapter" data-level="27.9" data-path="summary-summ.html"><a href="summary-summ.html#summ-by-exer"><i class="fa fa-check"></i><b>27.9</b> 练习</a></li>
</ul></li>
<li class="part"><span><b>VI 绘图</b></span></li>
<li class="chapter" data-level="28" data-path="graph.html"><a href="graph.html"><i class="fa fa-check"></i><b>28</b> 基本R绘图</a><ul>
<li class="chapter" data-level="28.1" data-path="graph.html"><a href="graph.html#graph-ph"><i class="fa fa-check"></i><b>28.1</b> 常用高级图形</a><ul>
<li class="chapter" data-level="28.1.1" data-path="graph.html"><a href="graph.html#graph-ph-barplot"><i class="fa fa-check"></i><b>28.1.1</b> 条形图</a></li>
<li class="chapter" data-level="28.1.2" data-path="graph.html"><a href="graph.html#graph-ph-hist"><i class="fa fa-check"></i><b>28.1.2</b> 直方图和密度估计图</a></li>
<li class="chapter" data-level="28.1.3" data-path="graph.html"><a href="graph.html#graph-ph-boxplot"><i class="fa fa-check"></i><b>28.1.3</b> 盒形图</a></li>
<li class="chapter" data-level="28.1.4" data-path="graph.html"><a href="graph.html#graph-pr-qq"><i class="fa fa-check"></i><b>28.1.4</b> 正态QQ图</a></li>
<li class="chapter" data-level="28.1.5" data-path="graph.html"><a href="graph.html#graph-ph-plot"><i class="fa fa-check"></i><b>28.1.5</b> 散点图</a></li>
<li class="chapter" data-level="28.1.6" data-path="graph.html"><a href="graph.html#graph-ph-curve"><i class="fa fa-check"></i><b>28.1.6</b> 曲线图</a></li>
<li class="chapter" data-level="28.1.7" data-path="graph.html"><a href="graph.html#graph-ph-3d"><i class="fa fa-check"></i><b>28.1.7</b> 三维图</a></li>
<li class="chapter" data-level="28.1.8" data-path="graph.html"><a href="graph.html#graph-ph-rgl"><i class="fa fa-check"></i><b>28.1.8</b> 动态三维图</a></li>
</ul></li>
<li class="chapter" data-level="28.2" data-path="graph.html"><a href="graph.html#graph-pl"><i class="fa fa-check"></i><b>28.2</b> 低级图形函数</a><ul>
<li class="chapter" data-level="28.2.1" data-path="graph.html"><a href="graph.html#graph-pl-abline"><i class="fa fa-check"></i><b>28.2.1</b> <code>abline()</code></a></li>
<li class="chapter" data-level="28.2.2" data-path="graph.html"><a href="graph.html#graph-pl-points"><i class="fa fa-check"></i><b>28.2.2</b> <code>points()</code></a></li>
<li class="chapter" data-level="28.2.3" data-path="graph.html"><a href="graph.html#graph-pl-lines"><i class="fa fa-check"></i><b>28.2.3</b> <code>lines()</code></a></li>
<li class="chapter" data-level="28.2.4" data-path="graph.html"><a href="graph.html#graph-pl-legend"><i class="fa fa-check"></i><b>28.2.4</b> 图例</a></li>
<li class="chapter" data-level="28.2.5" data-path="graph.html"><a href="graph.html#graph-pl-axis"><i class="fa fa-check"></i><b>28.2.5</b> <code>axis()</code></a></li>
<li class="chapter" data-level="28.2.6" data-path="graph.html"><a href="graph.html#graph-pl-text"><i class="fa fa-check"></i><b>28.2.6</b> <code>text()</code></a></li>
<li class="chapter" data-level="28.2.7" data-path="graph.html"><a href="graph.html#graph-pl-locator"><i class="fa fa-check"></i><b>28.2.7</b> <code>locator()</code>和<code>identify()</code></a></li>
</ul></li>
<li class="chapter" data-level="28.3" data-path="graph.html"><a href="graph.html#graph-par"><i class="fa fa-check"></i><b>28.3</b> 图形参数</a><ul>
<li class="chapter" data-level="28.3.1" data-path="graph.html"><a href="graph.html#graph-par-ex1"><i class="fa fa-check"></i><b>28.3.1</b> 例子：用图形参数解决barplot图形横坐标值过宽</a></li>
<li class="chapter" data-level="28.3.2" data-path="graph.html"><a href="graph.html#graph-par-elem"><i class="fa fa-check"></i><b>28.3.2</b> 图形元素控制</a></li>
<li class="chapter" data-level="28.3.3" data-path="graph.html"><a href="graph.html#graph-par-axis"><i class="fa fa-check"></i><b>28.3.3</b> 坐标轴与坐标刻度</a></li>
<li class="chapter" data-level="28.3.4" data-path="graph.html"><a href="graph.html#graph-par-mar"><i class="fa fa-check"></i><b>28.3.4</b> 图形边空</a></li>
<li class="chapter" data-level="28.3.5" data-path="graph.html"><a href="graph.html#graph-par-mfrow"><i class="fa fa-check"></i><b>28.3.5</b> 一页多图</a></li>
</ul></li>
<li class="chapter" data-level="28.4" data-path="graph.html"><a href="graph.html#graph-pout"><i class="fa fa-check"></i><b>28.4</b> 图形输出</a><ul>
<li class="chapter" data-level="28.4.1" data-path="graph.html"><a href="graph.html#graph-pout-pdf"><i class="fa fa-check"></i><b>28.4.1</b> PDF 输出</a></li>
<li class="chapter" data-level="28.4.2" data-path="graph.html"><a href="graph.html#graph-pout-png"><i class="fa fa-check"></i><b>28.4.2</b> PNG输出</a></li>
</ul></li>
<li class="chapter" data-level="28.5" data-path="graph.html"><a href="graph.html#graph-pzhn"><i class="fa fa-check"></i><b>28.5</b> 包含多种中文字体的图形</a></li>
<li class="chapter" data-level="28.6" data-path="graph.html"><a href="graph.html#graph-other"><i class="fa fa-check"></i><b>28.6</b> 其它图形</a><ul>
<li class="chapter" data-level="28.6.1" data-path="graph.html"><a href="graph.html#graph-other-corr"><i class="fa fa-check"></i><b>28.6.1</b> 相关系数图</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="29" data-path="ggplot2.html"><a href="ggplot2.html"><i class="fa fa-check"></i><b>29</b> ggplot作图入门</a><ul>
<li class="chapter" data-level="29.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-intro"><i class="fa fa-check"></i><b>29.1</b> 介绍</a></li>
<li class="chapter" data-level="29.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-principles"><i class="fa fa-check"></i><b>29.2</b> 作图的一般原则</a></li>
<li class="chapter" data-level="29.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point"><i class="fa fa-check"></i><b>29.3</b> 散点图：ggplot入门</a><ul>
<li class="chapter" data-level="29.3.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-base"><i class="fa fa-check"></i><b>29.3.1</b> 基本的散点图</a></li>
<li class="chapter" data-level="29.3.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-layers"><i class="fa fa-check"></i><b>29.3.2</b> 逐步改善</a></li>
<li class="chapter" data-level="29.3.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-otheraes"><i class="fa fa-check"></i><b>29.3.3</b> 颜色、符号、线型等映射</a></li>
<li class="chapter" data-level="29.3.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-geomaes"><i class="fa fa-check"></i><b>29.3.4</b> 在geom函数中映射变量</a></li>
<li class="chapter" data-level="29.3.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-contcolor"><i class="fa fa-check"></i><b>29.3.5</b> 连续变量的颜色映射</a></li>
<li class="chapter" data-level="29.3.6" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-point-save"><i class="fa fa-check"></i><b>29.3.6</b> 保存图像</a></li>
</ul></li>
<li class="chapter" data-level="29.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right"><i class="fa fa-check"></i><b>29.4</b> 折线图、分组、小图</a><ul>
<li class="chapter" data-level="29.4.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-group"><i class="fa fa-check"></i><b>29.4.1</b> 图形中的分组和折线图</a></li>
<li class="chapter" data-level="29.4.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-facet"><i class="fa fa-check"></i><b>29.4.2</b> 小图(facet)</a></li>
</ul></li>
<li class="chapter" data-level="29.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-bar-trans"><i class="fa fa-check"></i><b>29.5</b> 数据变换与条形图</a><ul>
<li class="chapter" data-level="29.5.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-right-morebar"><i class="fa fa-check"></i><b>29.5.1</b> 分段与并列条形图</a></li>
<li class="chapter" data-level="29.5.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-bar-morebar"><i class="fa fa-check"></i><b>29.5.2</b> 条形图的其它应用</a></li>
</ul></li>
<li class="chapter" data-level="29.6" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-hist"><i class="fa fa-check"></i><b>29.6</b> 直方图与密度估计</a></li>
<li class="chapter" data-level="29.7" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm"><i class="fa fa-check"></i><b>29.7</b> 绘图语法介绍</a><ul>
<li class="chapter" data-level="29.7.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm-gramm"><i class="fa fa-check"></i><b>29.7.1</b> 绘图语法</a></li>
<li class="chapter" data-level="29.7.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-gramm-geoms"><i class="fa fa-check"></i><b>29.7.2</b> 图形种类</a></li>
</ul></li>
<li class="chapter" data-level="29.8" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom"><i class="fa fa-check"></i><b>29.8</b> 更多图形种类</a><ul>
<li class="chapter" data-level="29.8.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-continuousvar"><i class="fa fa-check"></i><b>29.8.1</b> 连续变量的分组图形</a></li>
<li class="chapter" data-level="29.8.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-text"><i class="fa fa-check"></i><b>29.8.2</b> 坐标系中的文字</a></li>
<li class="chapter" data-level="29.8.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-textops"><i class="fa fa-check"></i><b>29.8.3</b> 文字选项</a></li>
<li class="chapter" data-level="29.8.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-moregeom-outliers"><i class="fa fa-check"></i><b>29.8.4</b> 标出特殊点</a></li>
</ul></li>
<li class="chapter" data-level="29.9" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-scale"><i class="fa fa-check"></i><b>29.9</b> 刻度(scale)</a></li>
<li class="chapter" data-level="29.10" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-color"><i class="fa fa-check"></i><b>29.10</b> 如何使用颜色</a><ul>
<li class="chapter" data-level="29.10.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-qual"><i class="fa fa-check"></i><b>29.10.1</b> 名义型变量的颜色</a></li>
<li class="chapter" data-level="29.10.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-tile"><i class="fa fa-check"></i><b>29.10.2</b> 色块图</a></li>
<li class="chapter" data-level="29.10.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-seq"><i class="fa fa-check"></i><b>29.10.3</b> 有序型变量的颜色</a></li>
<li class="chapter" data-level="29.10.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-div"><i class="fa fa-check"></i><b>29.10.4</b> 相异型变量的颜色</a></li>
<li class="chapter" data-level="29.10.5" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-num"><i class="fa fa-check"></i><b>29.10.5</b> 连续数值变量的颜色</a></li>
</ul></li>
<li class="chapter" data-level="29.11" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs"><i class="fa fa-check"></i><b>29.11</b> 标题、标注、指南、拼接</a><ul>
<li class="chapter" data-level="29.11.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-labs"><i class="fa fa-check"></i><b>29.11.1</b> 标题</a></li>
<li class="chapter" data-level="29.11.2" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-anno"><i class="fa fa-check"></i><b>29.11.2</b> 标注功能</a></li>
<li class="chapter" data-level="29.11.3" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-guides"><i class="fa fa-check"></i><b>29.11.3</b> 指南(guides)</a></li>
<li class="chapter" data-level="29.11.4" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-auxfuncs-compfig"><i class="fa fa-check"></i><b>29.11.4</b> 拼接图形</a></li>
</ul></li>
<li class="chapter" data-level="29.12" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine"><i class="fa fa-check"></i><b>29.12</b> 图形定制调整</a><ul>
<li class="chapter" data-level="29.12.1" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-refine-asasec"><i class="fa fa-check"></i><b>29.12.1</b> 图形逐步调整例子</a></li>
</ul></li>
<li class="chapter" data-level="29.13" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-theme"><i class="fa fa-check"></i><b>29.13</b> 主题</a></li>
<li class="chapter" data-level="29.14" data-path="ggplot2.html"><a href="ggplot2.html#ggplot2-ref"><i class="fa fa-check"></i><b>29.14</b> 参考文献</a></li>
</ul></li>
<li class="chapter" data-level="30" data-path="ggplotvis.html"><a href="ggplotvis.html"><i class="fa fa-check"></i><b>30</b> ggplot的各种图形</a><ul>
<li class="chapter" data-level="30.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-intro"><i class="fa fa-check"></i><b>30.1</b> 介绍</a></li>
<li class="chapter" data-level="30.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount"><i class="fa fa-check"></i><b>30.2</b> 表现数量</a><ul>
<li class="chapter" data-level="30.2.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-bar"><i class="fa fa-check"></i><b>30.2.1</b> 条形图</a></li>
<li class="chapter" data-level="30.2.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-point"><i class="fa fa-check"></i><b>30.2.2</b> 点图</a></li>
<li class="chapter" data-level="30.2.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-amount-heatmap"><i class="fa fa-check"></i><b>30.2.3</b> 热力图</a></li>
</ul></li>
<li class="chapter" data-level="30.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist"><i class="fa fa-check"></i><b>30.3</b> 表现分布</a><ul>
<li class="chapter" data-level="30.3.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-suni-hist"><i class="fa fa-check"></i><b>30.3.1</b> 单个一元分布的直方图与密度估计图</a></li>
<li class="chapter" data-level="30.3.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-muni"><i class="fa fa-check"></i><b>30.3.2</b> 多个一元分布的直方图和密度图形</a></li>
<li class="chapter" data-level="30.3.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-cdf"><i class="fa fa-check"></i><b>30.3.3</b> 经验分布函数图</a></li>
<li class="chapter" data-level="30.3.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-qqplot"><i class="fa fa-check"></i><b>30.3.4</b> QQ图</a></li>
<li class="chapter" data-level="30.3.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-boxplot"><i class="fa fa-check"></i><b>30.3.5</b> 盒形图</a></li>
<li class="chapter" data-level="30.3.6" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-violin"><i class="fa fa-check"></i><b>30.3.6</b> 小提琴图</a></li>
<li class="chapter" data-level="30.3.7" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-mdens"><i class="fa fa-check"></i><b>30.3.7</b> 多个密度的其它画法</a></li>
<li class="chapter" data-level="30.3.8" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-dist-2d"><i class="fa fa-check"></i><b>30.3.8</b> 二元分布直方图和等值线图</a></li>
</ul></li>
<li class="chapter" data-level="30.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop"><i class="fa fa-check"></i><b>30.4</b> 表现比例</a><ul>
<li class="chapter" data-level="30.4.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-uni"><i class="fa fa-check"></i><b>30.4.1</b> 单个分布</a></li>
<li class="chapter" data-level="30.4.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-mult"><i class="fa fa-check"></i><b>30.4.2</b> 组间的比例分布的比较</a></li>
<li class="chapter" data-level="30.4.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-prop-nest"><i class="fa fa-check"></i><b>30.4.3</b> 嵌套比例分布的比较</a></li>
</ul></li>
<li class="chapter" data-level="30.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar"><i class="fa fa-check"></i><b>30.5</b> 表现多个变量间的关系</a><ul>
<li class="chapter" data-level="30.5.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-scatter"><i class="fa fa-check"></i><b>30.5.1</b> 散点图</a></li>
<li class="chapter" data-level="30.5.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-scatmat"><i class="fa fa-check"></i><b>30.5.2</b> 散点图矩阵</a></li>
<li class="chapter" data-level="30.5.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-corrgram"><i class="fa fa-check"></i><b>30.5.3</b> 相关系数矩阵图</a></li>
<li class="chapter" data-level="30.5.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-dimreduct"><i class="fa fa-check"></i><b>30.5.4</b> 数据降维</a></li>
<li class="chapter" data-level="30.5.5" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-mulvar-paird"><i class="fa fa-check"></i><b>30.5.5</b> 成对数据</a></li>
</ul></li>
<li class="chapter" data-level="30.6" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts"><i class="fa fa-check"></i><b>30.6</b> 时间序列图</a><ul>
<li class="chapter" data-level="30.6.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-uni"><i class="fa fa-check"></i><b>30.6.1</b> 一元时间序列</a></li>
<li class="chapter" data-level="30.6.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-mul"><i class="fa fa-check"></i><b>30.6.2</b> 多元时间序列</a></li>
<li class="chapter" data-level="30.6.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-ts-het"><i class="fa fa-check"></i><b>30.6.3</b> 多个不同类型指标的时间序列</a></li>
</ul></li>
<li class="chapter" data-level="30.7" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit"><i class="fa fa-check"></i><b>30.7</b> 拟合曲线图</a><ul>
<li class="chapter" data-level="30.7.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit-smooth"><i class="fa fa-check"></i><b>30.7.1</b> 平滑方法</a></li>
<li class="chapter" data-level="30.7.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-fit-param"><i class="fa fa-check"></i><b>30.7.2</b> 参数模型方法</a></li>
</ul></li>
<li class="chapter" data-level="30.8" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert"><i class="fa fa-check"></i><b>30.8</b> 表现不确定性</a><ul>
<li class="chapter" data-level="30.8.1" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-prob"><i class="fa fa-check"></i><b>30.8.1</b> 表现概率</a></li>
<li class="chapter" data-level="30.8.2" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-se"><i class="fa fa-check"></i><b>30.8.2</b> 表现点估计精度</a></li>
<li class="chapter" data-level="30.8.3" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-cband"><i class="fa fa-check"></i><b>30.8.3</b> 拟合曲线的置信带</a></li>
<li class="chapter" data-level="30.8.4" data-path="ggplotvis.html"><a href="ggplotvis.html#ggplotvis-uncert-dyn"><i class="fa fa-check"></i><b>30.8.4</b> 随机结果动态演示</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>VII 统计模型</b></span></li>
<li class="chapter" data-level="31" data-path="stat-basics.html"><a href="stat-basics.html"><i class="fa fa-check"></i><b>31</b> R初等统计分析</a><ul>
<li class="chapter" data-level="31.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-distr"><i class="fa fa-check"></i><b>31.1</b> 概率分布</a></li>
<li class="chapter" data-level="31.2" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-mle"><i class="fa fa-check"></i><b>31.2</b> 最大似然估计</a><ul>
<li class="chapter" data-level="31.2.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-mle-norm1"><i class="fa fa-check"></i><b>31.2.1</b> 一元正态分布参数最大似然估计</a></li>
</ul></li>
<li class="chapter" data-level="31.3" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest"><i class="fa fa-check"></i><b>31.3</b> 假设检验和置信区间</a><ul>
<li class="chapter" data-level="31.3.1" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-mu"><i class="fa fa-check"></i><b>31.3.1</b> 均值的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.2" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-prop"><i class="fa fa-check"></i><b>31.3.2</b> 比例的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.3" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-sigma"><i class="fa fa-check"></i><b>31.3.3</b> 方差的假设检验和置信区间</a></li>
<li class="chapter" data-level="31.3.4" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-gof"><i class="fa fa-check"></i><b>31.3.4</b> 拟合优度检验</a></li>
<li class="chapter" data-level="31.3.5" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-gof-vcd"><i class="fa fa-check"></i><b>31.3.5</b> 检验分布类型</a></li>
<li class="chapter" data-level="31.3.6" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-indepcont"><i class="fa fa-check"></i><b>31.3.6</b> 列联表独立性卡方检验</a></li>
<li class="chapter" data-level="31.3.7" data-path="stat-basics.html"><a href="stat-basics.html#stat-base-hyptest-npar"><i class="fa fa-check"></i><b>31.3.7</b> 非参数检验</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="32" data-path="stat-reg.html"><a href="stat-reg.html"><i class="fa fa-check"></i><b>32</b> R相关与回归</a><ul>
<li class="chapter" data-level="32.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor"><i class="fa fa-check"></i><b>32.1</b> 相关分析</a><ul>
<li class="chapter" data-level="32.1.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-prop"><i class="fa fa-check"></i><b>32.1.1</b> 相关系数的性质</a></li>
<li class="chapter" data-level="32.1.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-caus"><i class="fa fa-check"></i><b>32.1.2</b> 相关与因果</a></li>
<li class="chapter" data-level="32.1.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-magn"><i class="fa fa-check"></i><b>32.1.3</b> 相关系数大小</a></li>
<li class="chapter" data-level="32.1.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-test"><i class="fa fa-check"></i><b>32.1.4</b> 相关系数的检验</a></li>
<li class="chapter" data-level="32.1.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cor-vcorr"><i class="fa fa-check"></i><b>32.1.5</b> 相关阵</a></li>
</ul></li>
<li class="chapter" data-level="32.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp"><i class="fa fa-check"></i><b>32.2</b> 一元回归分析</a><ul>
<li class="chapter" data-level="32.2.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-model"><i class="fa fa-check"></i><b>32.2.1</b> 模型</a></li>
<li class="chapter" data-level="32.2.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-ls"><i class="fa fa-check"></i><b>32.2.2</b> 最小二乘法</a></li>
<li class="chapter" data-level="32.2.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-test"><i class="fa fa-check"></i><b>32.2.3</b> 回归有效性</a></li>
<li class="chapter" data-level="32.2.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-prog"><i class="fa fa-check"></i><b>32.2.4</b> R程序</a></li>
<li class="chapter" data-level="32.2.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-diag"><i class="fa fa-check"></i><b>32.2.5</b> 回归诊断</a></li>
<li class="chapter" data-level="32.2.6" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-ci"><i class="fa fa-check"></i><b>32.2.6</b> 预测区间</a></li>
<li class="chapter" data-level="32.2.7" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regsimp-control"><i class="fa fa-check"></i><b>32.2.7</b> 控制</a></li>
</ul></li>
<li class="chapter" data-level="32.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu"><i class="fa fa-check"></i><b>32.3</b> 多元线性回归</a><ul>
<li class="chapter" data-level="32.3.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-mod"><i class="fa fa-check"></i><b>32.3.1</b> 模型</a></li>
<li class="chapter" data-level="32.3.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-est"><i class="fa fa-check"></i><b>32.3.2</b> 参数估计</a></li>
<li class="chapter" data-level="32.3.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-rcode"><i class="fa fa-check"></i><b>32.3.3</b> R的多元回归程序</a></li>
<li class="chapter" data-level="32.3.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-test"><i class="fa fa-check"></i><b>32.3.4</b> 模型的检验</a></li>
<li class="chapter" data-level="32.3.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-subset"><i class="fa fa-check"></i><b>32.3.5</b> 回归自变量筛选</a></li>
<li class="chapter" data-level="32.3.6" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-dum"><i class="fa fa-check"></i><b>32.3.6</b> 哑变量与变截距项的模型</a></li>
<li class="chapter" data-level="32.3.7" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-resid"><i class="fa fa-check"></i><b>32.3.7</b> 残差诊断</a></li>
<li class="chapter" data-level="32.3.8" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-colin"><i class="fa fa-check"></i><b>32.3.8</b> 多重共线性</a></li>
<li class="chapter" data-level="32.3.9" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-lev"><i class="fa fa-check"></i><b>32.3.9</b> 强影响点分析</a></li>
<li class="chapter" data-level="32.3.10" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-overfit"><i class="fa fa-check"></i><b>32.3.10</b> 过度拟合示例</a></li>
<li class="chapter" data-level="32.3.11" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-comp-inset"><i class="fa fa-check"></i><b>32.3.11</b> 嵌套模型的比较</a></li>
<li class="chapter" data-level="32.3.12" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-pred"><i class="fa fa-check"></i><b>32.3.12</b> 拟合与预测</a></li>
<li class="chapter" data-level="32.3.13" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-curve"><i class="fa fa-check"></i><b>32.3.13</b> 利用线性回归模型做曲线拟合</a></li>
<li class="chapter" data-level="32.3.14" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-regmu-group"><i class="fa fa-check"></i><b>32.3.14</b> 分组建立多个模型</a></li>
</ul></li>
<li class="chapter" data-level="32.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-npar"><i class="fa fa-check"></i><b>32.4</b> 非参数回归</a><ul>
<li class="chapter" data-level="32.4.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-npar-mod"><i class="fa fa-check"></i><b>32.4.1</b> 模型</a></li>
<li class="chapter" data-level="32.4.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-spl1d"><i class="fa fa-check"></i><b>32.4.2</b> 样条平滑</a></li>
<li class="chapter" data-level="32.4.3" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-loess"><i class="fa fa-check"></i><b>32.4.3</b> 局部多项式曲线平滑</a></li>
<li class="chapter" data-level="32.4.4" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-bs"><i class="fa fa-check"></i><b>32.4.4</b> 样条函数变换</a></li>
<li class="chapter" data-level="32.4.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-cfit-gam"><i class="fa fa-check"></i><b>32.4.5</b> 线性可加模型</a></li>
</ul></li>
<li class="chapter" data-level="32.5" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog"><i class="fa fa-check"></i><b>32.5</b> Logistic回归</a><ul>
<li class="chapter" data-level="32.5.1" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog-mod"><i class="fa fa-check"></i><b>32.5.1</b> 模型</a></li>
<li class="chapter" data-level="32.5.2" data-path="stat-reg.html"><a href="stat-reg.html#stat-base-reg-reglog-rcode"><i class="fa fa-check"></i><b>32.5.2</b> R程序</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="33" data-path="stat-tsa.html"><a href="stat-tsa.html"><i class="fa fa-check"></i><b>33</b> R时间序列分析</a><ul>
<li class="chapter" data-level="33.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-defs"><i class="fa fa-check"></i><b>33.1</b> 基本概念</a></li>
<li class="chapter" data-level="33.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype"><i class="fa fa-check"></i><b>33.2</b> 时间序列数据类型</a><ul>
<li class="chapter" data-level="33.2.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype-ts"><i class="fa fa-check"></i><b>33.2.1</b> ts类型</a></li>
<li class="chapter" data-level="33.2.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-dtype-xts"><i class="fa fa-check"></i><b>33.2.2</b> xts类型与常用函数</a></li>
</ul></li>
<li class="chapter" data-level="33.3" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-basicstat"><i class="fa fa-check"></i><b>33.3</b> 基本分析与作图</a></li>
<li class="chapter" data-level="33.4" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima"><i class="fa fa-check"></i><b>33.4</b> ARIMA建模和模拟</a><ul>
<li class="chapter" data-level="33.4.1" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-def"><i class="fa fa-check"></i><b>33.4.1</b> 模型公式</a></li>
<li class="chapter" data-level="33.4.2" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-sim"><i class="fa fa-check"></i><b>33.4.2</b> 模拟</a></li>
<li class="chapter" data-level="33.4.3" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-armod"><i class="fa fa-check"></i><b>33.4.3</b> AR建模</a></li>
<li class="chapter" data-level="33.4.4" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-armamod"><i class="fa fa-check"></i><b>33.4.4</b> ARMA建模</a></li>
<li class="chapter" data-level="33.4.5" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-diag"><i class="fa fa-check"></i><b>33.4.5</b> 模型诊断</a></li>
<li class="chapter" data-level="33.4.6" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-lbtest"><i class="fa fa-check"></i><b>33.4.6</b> 白噪声检验</a></li>
<li class="chapter" data-level="33.4.7" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-sparse"><i class="fa fa-check"></i><b>33.4.7</b> 稀疏系数估计</a></li>
<li class="chapter" data-level="33.4.8" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-adftest"><i class="fa fa-check"></i><b>33.4.8</b> 单位根检验</a></li>
<li class="chapter" data-level="33.4.9" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-arima-cfuncs"><i class="fa fa-check"></i><b>33.4.9</b> ARMA模型的一些自定义函数</a></li>
</ul></li>
<li class="chapter" data-level="33.5" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-spectra"><i class="fa fa-check"></i><b>33.5</b> 谱密度估计</a></li>
<li class="chapter" data-level="33.6" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-garch"><i class="fa fa-check"></i><b>33.6</b> GARCH类模型</a></li>
<li class="chapter" data-level="33.7" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-mtsa"><i class="fa fa-check"></i><b>33.7</b> 多元时间序列基础统计</a></li>
<li class="chapter" data-level="33.8" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-var"><i class="fa fa-check"></i><b>33.8</b> VAR模型</a></li>
<li class="chapter" data-level="33.9" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-coint"><i class="fa fa-check"></i><b>33.9</b> 协整分析</a></li>
<li class="chapter" data-level="33.10" data-path="stat-tsa.html"><a href="stat-tsa.html#stat-tsa-causal"><i class="fa fa-check"></i><b>33.10</b> 因果性检验</a></li>
</ul></li>
<li class="chapter" data-level="34" data-path="stat-learning.html"><a href="stat-learning.html"><i class="fa fa-check"></i><b>34</b> 统计学习介绍</a><ul>
<li class="chapter" data-level="34.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro"><i class="fa fa-check"></i><b>34.1</b> 统计学习的基本概念和一般步骤</a><ul>
<li class="chapter" data-level="34.1.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro-basic"><i class="fa fa-check"></i><b>34.1.1</b> 统计学习的基本概念和方法</a></li>
<li class="chapter" data-level="34.1.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-intro-biasvar"><i class="fa fa-check"></i><b>34.1.2</b> 偏差与方差折衷</a></li>
<li class="chapter" data-level="34.1.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-cv"><i class="fa fa-check"></i><b>34.1.3</b> 交叉验证</a></li>
<li class="chapter" data-level="34.1.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-steps"><i class="fa fa-check"></i><b>34.1.4</b> 一般步骤</a></li>
</ul></li>
<li class="chapter" data-level="34.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters"><i class="fa fa-check"></i><b>34.2</b> Hitters数据分析</a><ul>
<li class="chapter" data-level="34.2.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-subset"><i class="fa fa-check"></i><b>34.2.1</b> 回归自变量选择</a></li>
<li class="chapter" data-level="34.2.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-ridge"><i class="fa fa-check"></i><b>34.2.2</b> 岭回归</a></li>
<li class="chapter" data-level="34.2.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-lasso"><i class="fa fa-check"></i><b>34.2.3</b> Lasso回归</a></li>
<li class="chapter" data-level="34.2.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-simpt"><i class="fa fa-check"></i><b>34.2.4</b> 树回归的简单演示</a></li>
<li class="chapter" data-level="34.2.5" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-tree"><i class="fa fa-check"></i><b>34.2.5</b> 树回归</a></li>
<li class="chapter" data-level="34.2.6" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-bag"><i class="fa fa-check"></i><b>34.2.6</b> 装袋法</a></li>
<li class="chapter" data-level="34.2.7" data-path="stat-learning.html"><a href="stat-learning.html#statl-hitters-rf"><i class="fa fa-check"></i><b>34.2.7</b> 随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart"><i class="fa fa-check"></i><b>34.3</b> Heart数据分析</a><ul>
<li class="chapter" data-level="34.3.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-tree"><i class="fa fa-check"></i><b>34.3.1</b> 树回归</a></li>
<li class="chapter" data-level="34.3.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-bag"><i class="fa fa-check"></i><b>34.3.2</b> 用装袋法</a></li>
<li class="chapter" data-level="34.3.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-heart-rf"><i class="fa fa-check"></i><b>34.3.3</b> 用随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-car"><i class="fa fa-check"></i><b>34.4</b> 汽车销量数据分析</a><ul>
<li class="chapter" data-level="34.4.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-car-tree"><i class="fa fa-check"></i><b>34.4.1</b> 判别树</a></li>
<li class="chapter" data-level="34.4.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-car-rf"><i class="fa fa-check"></i><b>34.4.2</b> 随机森林</a></li>
</ul></li>
<li class="chapter" data-level="34.5" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston"><i class="fa fa-check"></i><b>34.5</b> 波士顿郊区房价数据</a><ul>
<li class="chapter" data-level="34.5.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-tree"><i class="fa fa-check"></i><b>34.5.1</b> 回归树</a></li>
<li class="chapter" data-level="34.5.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-bag"><i class="fa fa-check"></i><b>34.5.2</b> 装袋法</a></li>
<li class="chapter" data-level="34.5.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-rf"><i class="fa fa-check"></i><b>34.5.3</b> 随机森林</a></li>
<li class="chapter" data-level="34.5.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-boston-boost"><i class="fa fa-check"></i><b>34.5.4</b> 提升法</a></li>
</ul></li>
<li class="chapter" data-level="34.6" data-path="stat-learning.html"><a href="stat-learning.html#statl-svm"><i class="fa fa-check"></i><b>34.6</b> 支持向量机方法</a><ul>
<li class="chapter" data-level="34.6.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-svm-heart"><i class="fa fa-check"></i><b>34.6.1</b> 支持向量机用于Heart数据</a></li>
</ul></li>
<li class="chapter" data-level="34.7" data-path="stat-learning.html"><a href="stat-learning.html#statl-app"><i class="fa fa-check"></i><b>34.7</b> 附录</a><ul>
<li class="chapter" data-level="34.7.1" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-hitters"><i class="fa fa-check"></i><b>34.7.1</b> Hitters数据</a></li>
<li class="chapter" data-level="34.7.2" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-heart"><i class="fa fa-check"></i><b>34.7.2</b> Heart数据</a></li>
<li class="chapter" data-level="34.7.3" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-car"><i class="fa fa-check"></i><b>34.7.3</b> CarSeats数据</a></li>
<li class="chapter" data-level="34.7.4" data-path="stat-learning.html"><a href="stat-learning.html#statl-app-boston"><i class="fa fa-check"></i><b>34.7.4</b> Boston数据</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="35" data-path="simulation.html"><a href="simulation.html"><i class="fa fa-check"></i><b>35</b> 随机模拟</a><ul>
<li class="chapter" data-level="35.1" data-path="simulation.html"><a href="simulation.html#simint"><i class="fa fa-check"></i><b>35.1</b> 随机数</a></li>
<li class="chapter" data-level="35.2" data-path="simulation.html"><a href="simulation.html#simsamp"><i class="fa fa-check"></i><b>35.2</b> <code>sample()</code>函数</a></li>
<li class="chapter" data-level="35.3" data-path="simulation.html"><a href="simulation.html#simexamp"><i class="fa fa-check"></i><b>35.3</b> 随机模拟示例</a><ul>
<li class="chapter" data-level="35.3.1" data-path="simulation.html"><a href="simulation.html#simexamp-expect"><i class="fa fa-check"></i><b>35.3.1</b> 估计期望值</a></li>
<li class="chapter" data-level="35.3.2" data-path="simulation.html"><a href="simulation.html#simexamp-lm"><i class="fa fa-check"></i><b>35.3.2</b> 线性回归模拟</a></li>
<li class="chapter" data-level="35.3.3" data-path="simulation.html"><a href="simulation.html#simexamp-kde"><i class="fa fa-check"></i><b>35.3.3</b> 核密度的bootstrap置信区间</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>VIII 特殊应用</b></span></li>
<li class="chapter" data-level="36" data-path="text.html"><a href="text.html"><i class="fa fa-check"></i><b>36</b> R语言的文本处理</a><ul>
<li class="chapter" data-level="36.1" data-path="text.html"><a href="text.html#text-simple"><i class="fa fa-check"></i><b>36.1</b> 简单的文本处理</a><ul>
<li class="chapter" data-level="36.1.1" data-path="text.html"><a href="text.html#text-simple-const"><i class="fa fa-check"></i><b>36.1.1</b> 字符型常量与字符型向量</a></li>
<li class="chapter" data-level="36.1.2" data-path="text.html"><a href="text.html#text-paste"><i class="fa fa-check"></i><b>36.1.2</b> 字符串连接、重复</a></li>
<li class="chapter" data-level="36.1.3" data-path="text.html"><a href="text.html#text-formatout"><i class="fa fa-check"></i><b>36.1.3</b> 格式化输出</a></li>
<li class="chapter" data-level="36.1.4" data-path="text.html"><a href="text.html#text-length"><i class="fa fa-check"></i><b>36.1.4</b> 字符串长度</a></li>
<li class="chapter" data-level="36.1.5" data-path="text.html"><a href="text.html#text-substring"><i class="fa fa-check"></i><b>36.1.5</b> 取子串</a></li>
<li class="chapter" data-level="36.1.6" data-path="text.html"><a href="text.html#text-convert"><i class="fa fa-check"></i><b>36.1.6</b> 字符串变换</a></li>
<li class="chapter" data-level="36.1.7" data-path="text.html"><a href="text.html#text-simp-find"><i class="fa fa-check"></i><b>36.1.7</b> 简单匹配与查找</a></li>
<li class="chapter" data-level="36.1.8" data-path="text.html"><a href="text.html#text-simple-gsub"><i class="fa fa-check"></i><b>36.1.8</b> 字符串替换</a></li>
<li class="chapter" data-level="36.1.9" data-path="text.html"><a href="text.html#text-simple-strsplit"><i class="fa fa-check"></i><b>36.1.9</b> 字符串拆分</a></li>
</ul></li>
<li class="chapter" data-level="36.2" data-path="text.html"><a href="text.html#text-file"><i class="fa fa-check"></i><b>36.2</b> 文本文件读写</a></li>
<li class="chapter" data-level="36.3" data-path="text.html"><a href="text.html#text-regex"><i class="fa fa-check"></i><b>36.3</b> 正则表达式</a><ul>
<li class="chapter" data-level="36.3.1" data-path="text.html"><a href="text.html#text-regex-strview"><i class="fa fa-check"></i><b>36.3.1</b> 字面匹配与匹配显示</a></li>
<li class="chapter" data-level="36.3.2" data-path="text.html"><a href="text.html#text-regex-ignore"><i class="fa fa-check"></i><b>36.3.2</b> 不区分大小写匹配和<code>regex</code>函数</a></li>
<li class="chapter" data-level="36.3.3" data-path="text.html"><a href="text.html#text-regex-dot"><i class="fa fa-check"></i><b>36.3.3</b> 用句点匹配单个字符</a></li>
<li class="chapter" data-level="36.3.4" data-path="text.html"><a href="text.html#text-regex-set"><i class="fa fa-check"></i><b>36.3.4</b> 匹配一组字符中的某一个</a></li>
<li class="chapter" data-level="36.3.5" data-path="text.html"><a href="text.html#text-regex-metalit"><i class="fa fa-check"></i><b>36.3.5</b> 原样匹配元字符</a></li>
<li class="chapter" data-level="36.3.6" data-path="text.html"><a href="text.html#text-regex-space"><i class="fa fa-check"></i><b>36.3.6</b> 匹配空白</a></li>
<li class="chapter" data-level="36.3.7" data-path="text.html"><a href="text.html#text-regex-digit"><i class="fa fa-check"></i><b>36.3.7</b> 匹配数字</a></li>
<li class="chapter" data-level="36.3.8" data-path="text.html"><a href="text.html#text-regex-alnum"><i class="fa fa-check"></i><b>36.3.8</b> 匹配字母、数字、下划线</a></li>
<li class="chapter" data-level="36.3.9" data-path="text.html"><a href="text.html#text-regex-hex"><i class="fa fa-check"></i><b>36.3.9</b> 十六进制和八进制数</a></li>
<li class="chapter" data-level="36.3.10" data-path="text.html"><a href="text.html#text-regex-posix"><i class="fa fa-check"></i><b>36.3.10</b> POSIX字符类</a></li>
<li class="chapter" data-level="36.3.11" data-path="text.html"><a href="text.html#text-regex-start"><i class="fa fa-check"></i><b>36.3.11</b> 匹配开头和末尾</a></li>
<li class="chapter" data-level="36.3.12" data-path="text.html"><a href="text.html#text-regex-wordb"><i class="fa fa-check"></i><b>36.3.12</b> 单词边界</a></li>
<li class="chapter" data-level="36.3.13" data-path="text.html"><a href="text.html#text-regex-repeat"><i class="fa fa-check"></i><b>36.3.13</b> 重复匹配</a></li>
<li class="chapter" data-level="36.3.14" data-path="text.html"><a href="text.html#text-regex-lazy"><i class="fa fa-check"></i><b>36.3.14</b> 贪婪匹配和懒惰匹配</a></li>
<li class="chapter" data-level="36.3.15" data-path="text.html"><a href="text.html#text-regex-smlines"><i class="fa fa-check"></i><b>36.3.15</b> 句点全匹配与多行模式</a></li>
<li class="chapter" data-level="36.3.16" data-path="text.html"><a href="text.html#text-regex-alt"><i class="fa fa-check"></i><b>36.3.16</b> 备择模式</a></li>
<li class="chapter" data-level="36.3.17" data-path="text.html"><a href="text.html#text-regex-group"><i class="fa fa-check"></i><b>36.3.17</b> 分组与捕获</a></li>
</ul></li>
<li class="chapter" data-level="36.4" data-path="text.html"><a href="text.html#text-stringr-funcs"><i class="fa fa-check"></i><b>36.4</b> stringr包的正则表达式函数</a><ul>
<li class="chapter" data-level="36.4.1" data-path="text.html"><a href="text.html#text-stringr-funcs-strview"><i class="fa fa-check"></i><b>36.4.1</b> <code>str_view()</code>函数</a></li>
<li class="chapter" data-level="36.4.2" data-path="text.html"><a href="text.html#text-stringr-funcs-regex"><i class="fa fa-check"></i><b>36.4.2</b> <code>regex()</code>函数</a></li>
<li class="chapter" data-level="36.4.3" data-path="text.html"><a href="text.html#text-stringr-funcs-detect"><i class="fa fa-check"></i><b>36.4.3</b> 检查那些元素能够匹配</a></li>
<li class="chapter" data-level="36.4.4" data-path="text.html"><a href="text.html#text-stringr-funcs-replace"><i class="fa fa-check"></i><b>36.4.4</b> 替换</a></li>
<li class="chapter" data-level="36.4.5" data-path="text.html"><a href="text.html#text-stringr-funcs-subset"><i class="fa fa-check"></i><b>36.4.5</b> 返回匹配的元素</a></li>
<li class="chapter" data-level="36.4.6" data-path="text.html"><a href="text.html#text-stringr-funcs-extract"><i class="fa fa-check"></i><b>36.4.6</b> 提取匹配内容</a></li>
<li class="chapter" data-level="36.4.7" data-path="text.html"><a href="text.html#text-stringr-funcs-match"><i class="fa fa-check"></i><b>36.4.7</b> 提取分组捕获内容</a></li>
<li class="chapter" data-level="36.4.8" data-path="text.html"><a href="text.html#text-stringr-funcs-locate"><i class="fa fa-check"></i><b>36.4.8</b> 定位匹配位置</a></li>
</ul></li>
<li class="chapter" data-level="36.5" data-path="text.html"><a href="text.html#text-regex-bfuncs"><i class="fa fa-check"></i><b>36.5</b> 利用基本R函数进行正则表达式处理</a><ul>
<li class="chapter" data-level="36.5.1" data-path="text.html"><a href="text.html#text-regex-bfuncs-igcase"><i class="fa fa-check"></i><b>36.5.1</b> 不区分大小写匹配</a></li>
<li class="chapter" data-level="36.5.2" data-path="text.html"><a href="text.html#text-regex-bfuncs-dotp"><i class="fa fa-check"></i><b>36.5.2</b> 匹配单个字符</a></li>
<li class="chapter" data-level="36.5.3" data-path="text.html"><a href="text.html#text-regex-bfuncs-setp"><i class="fa fa-check"></i><b>36.5.3</b> 匹配一组字符中的某一个</a></li>
<li class="chapter" data-level="36.5.4" data-path="text.html"><a href="text.html#text-regex-bfuncs-metalit"><i class="fa fa-check"></i><b>36.5.4</b> 原样匹配元字符</a></li>
<li class="chapter" data-level="36.5.5" data-path="text.html"><a href="text.html#text-regex-bfuncs-digit"><i class="fa fa-check"></i><b>36.5.5</b> 匹配数字</a></li>
<li class="chapter" data-level="36.5.6" data-path="text.html"><a href="text.html#text-regex-bfuncs-start"><i class="fa fa-check"></i><b>36.5.6</b> 匹配开头和末尾</a></li>
<li class="chapter" data-level="36.5.7" data-path="text.html"><a href="text.html#text-regex-bfuncs-alnum"><i class="fa fa-check"></i><b>36.5.7</b> 匹配字母、数字、下划线</a></li>
<li class="chapter" data-level="36.5.8" data-path="text.html"><a href="text.html#text-regex-bfuncs-hex"><i class="fa fa-check"></i><b>36.5.8</b> 十六进制和八进制数</a></li>
<li class="chapter" data-level="36.5.9" data-path="text.html"><a href="text.html#text-regex-bfuncs-posix"><i class="fa fa-check"></i><b>36.5.9</b> POSIX字符类</a></li>
<li class="chapter" data-level="36.5.10" data-path="text.html"><a href="text.html#text-regex-bfuncs-plus"><i class="fa fa-check"></i><b>36.5.10</b> 加号重复匹配</a></li>
<li class="chapter" data-level="36.5.11" data-path="text.html"><a href="text.html#text-regex-bfuncs-ast"><i class="fa fa-check"></i><b>36.5.11</b> 星号和问号重复匹配</a></li>
<li class="chapter" data-level="36.5.12" data-path="text.html"><a href="text.html#text-regex-bfuncs-repnum"><i class="fa fa-check"></i><b>36.5.12</b> 计数重复</a></li>
<li class="chapter" data-level="36.5.13" data-path="text.html"><a href="text.html#text-regex-bfuncs-lazy"><i class="fa fa-check"></i><b>36.5.13</b> 贪婪匹配和懒惰匹配</a></li>
<li class="chapter" data-level="36.5.14" data-path="text.html"><a href="text.html#text-regex-bfuncs-wordb"><i class="fa fa-check"></i><b>36.5.14</b> 单词边界</a></li>
<li class="chapter" data-level="36.5.15" data-path="text.html"><a href="text.html#text-regex-bfuncs-sm"><i class="fa fa-check"></i><b>36.5.15</b> 句点全匹配与多行模式</a></li>
<li class="chapter" data-level="36.5.16" data-path="text.html"><a href="text.html#text-regex-bfuncs-alt"><i class="fa fa-check"></i><b>36.5.16</b> 备择模式</a></li>
<li class="chapter" data-level="36.5.17" data-path="text.html"><a href="text.html#text-regex-bfuncs-group"><i class="fa fa-check"></i><b>36.5.17</b> 分组与捕获</a></li>
</ul></li>
<li class="chapter" data-level="36.6" data-path="text.html"><a href="text.html#text-regexex"><i class="fa fa-check"></i><b>36.6</b> 正则表达式应用例子</a><ul>
<li class="chapter" data-level="36.6.1" data-path="text.html"><a href="text.html#text-regexex-pre"><i class="fa fa-check"></i><b>36.6.1</b> 数据预处理</a></li>
<li class="chapter" data-level="36.6.2" data-path="text.html"><a href="text.html#text-regexex-excelmore"><i class="fa fa-check"></i><b>36.6.2</b> 不规则Excel文件处理</a></li>
<li class="chapter" data-level="36.6.3" data-path="text.html"><a href="text.html#text-regexex-wordfreq"><i class="fa fa-check"></i><b>36.6.3</b> 字频统计</a></li>
<li class="chapter" data-level="36.6.4" data-path="text.html"><a href="text.html#text-regexex-digits"><i class="fa fa-check"></i><b>36.6.4</b> 数字验证</a></li>
<li class="chapter" data-level="36.6.5" data-path="text.html"><a href="text.html#text-regexex-digfn"><i class="fa fa-check"></i><b>36.6.5</b> 文件名中的数字提取</a></li>
</ul></li>
<li class="chapter" data-level="36.7" data-path="text.html"><a href="text.html#text-webscape"><i class="fa fa-check"></i><b>36.7</b> 网站数据获取</a></li>
<li class="chapter" data-level="36.8" data-path="text.html"><a href="text.html#text-jiebaR"><i class="fa fa-check"></i><b>36.8</b> 中文分词与词频</a></li>
</ul></li>
<li class="part"><span><b>IX 用Rcpp访问C++代码</b></span></li>
<li class="chapter" data-level="37" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>37</b> Rcpp介绍</a><ul>
<li class="chapter" data-level="37.1" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-use"><i class="fa fa-check"></i><b>37.1</b> Rcpp的用途</a></li>
<li class="chapter" data-level="37.2" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp"><i class="fa fa-check"></i><b>37.2</b> Rcpp入门样例</a><ul>
<li class="chapter" data-level="37.2.1" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex1"><i class="fa fa-check"></i><b>37.2.1</b> 用<code>cppFunction()</code>转换简单的C++函数—Fibnacci例子</a></li>
<li class="chapter" data-level="37.2.2" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex2"><i class="fa fa-check"></i><b>37.2.2</b> 用<code>sourceCpp()</code>转换C++程序—正负交替迭代例子</a></li>
<li class="chapter" data-level="37.2.3" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex3"><i class="fa fa-check"></i><b>37.2.3</b> 用<code>sourceCpp()</code>转换C++源文件中的程序—正负交替迭代例子</a></li>
<li class="chapter" data-level="37.2.4" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-ex4"><i class="fa fa-check"></i><b>37.2.4</b> 用<code>sourceCpp()</code>转换C++源程序文件—卷积例子</a></li>
<li class="chapter" data-level="37.2.5" data-path="rcpp.html"><a href="rcpp.html#rcpp-intro-examp-rmdconv"><i class="fa fa-check"></i><b>37.2.5</b> 在Rmd文件中使用C++源程序文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="38" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html"><i class="fa fa-check"></i><b>38</b> R与C++的类型转换</a><ul>
<li class="chapter" data-level="38.1" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-wrap"><i class="fa fa-check"></i><b>38.1</b> 用<code>wrap()</code>把C++变量返回到R中</a></li>
<li class="chapter" data-level="38.2" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-as"><i class="fa fa-check"></i><b>38.2</b> 用<code>as()</code>函数把R变量转换为C++类型</a></li>
<li class="chapter" data-level="38.3" data-path="rcpp-typeconv.html"><a href="rcpp-typeconv.html#rcpp-typeconv-implicit"><i class="fa fa-check"></i><b>38.3</b> <code>as()</code>和<code>wrap()</code>的隐含调用</a></li>
</ul></li>
<li class="chapter" data-level="39" data-path="rcpp-attr.html"><a href="rcpp-attr.html"><i class="fa fa-check"></i><b>39</b> Rcpp 属性</a><ul>
<li class="chapter" data-level="39.1" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-intro"><i class="fa fa-check"></i><b>39.1</b> Rcpp属性介绍</a></li>
<li class="chapter" data-level="39.2" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-export"><i class="fa fa-check"></i><b>39.2</b> 在C++源程序中指定要导出的C++函数</a></li>
<li class="chapter" data-level="39.3" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-sourcecpp"><i class="fa fa-check"></i><b>39.3</b> 在R中编译链接C++代码</a></li>
<li class="chapter" data-level="39.4" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc"><i class="fa fa-check"></i><b>39.4</b> Rcpp属性的其它功能</a><ul>
<li class="chapter" data-level="39.4.1" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-default"><i class="fa fa-check"></i><b>39.4.1</b> 自变量有缺省值的函数</a></li>
<li class="chapter" data-level="39.4.2" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-interrupt"><i class="fa fa-check"></i><b>39.4.2</b> 允许用户中断</a></li>
<li class="chapter" data-level="39.4.3" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-rinclude"><i class="fa fa-check"></i><b>39.4.3</b> 把R代码写在C++源文件中</a></li>
<li class="chapter" data-level="39.4.4" data-path="rcpp-attr.html"><a href="rcpp-attr.html#rcpp-attr-misc-rand"><i class="fa fa-check"></i><b>39.4.4</b> 在C++中调用R的随机数发生器</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="40" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html"><i class="fa fa-check"></i><b>40</b> Rcpp提供的C++数据类型</a><ul>
<li class="chapter" data-level="40.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-robject"><i class="fa fa-check"></i><b>40.1</b> RObject类</a></li>
<li class="chapter" data-level="40.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec"><i class="fa fa-check"></i><b>40.2</b> IntegerVector类</a><ul>
<li class="chapter" data-level="40.2.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec-ex1"><i class="fa fa-check"></i><b>40.2.1</b> IntegerVector示例1：返回完全数</a></li>
<li class="chapter" data-level="40.2.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-ivec-ex2"><i class="fa fa-check"></i><b>40.2.2</b> IntegerVector示例2：输入整数向量</a></li>
</ul></li>
<li class="chapter" data-level="40.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num"><i class="fa fa-check"></i><b>40.3</b> NumericVector类</a><ul>
<li class="chapter" data-level="40.3.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex1"><i class="fa fa-check"></i><b>40.3.1</b> 示例1：计算元素<span class="math inline">\(p\)</span>次方的和</a></li>
<li class="chapter" data-level="40.3.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex2"><i class="fa fa-check"></i><b>40.3.2</b> 示例2：<code>clone</code>函数</a></li>
<li class="chapter" data-level="40.3.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-num-ex3"><i class="fa fa-check"></i><b>40.3.3</b> 示例3：向量子集</a></li>
</ul></li>
<li class="chapter" data-level="40.4" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat"><i class="fa fa-check"></i><b>40.4</b> NumericMatrix类</a><ul>
<li class="chapter" data-level="40.4.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex1"><i class="fa fa-check"></i><b>40.4.1</b> 示例1：计算矩阵各列模的最大值</a></li>
<li class="chapter" data-level="40.4.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex2"><i class="fa fa-check"></i><b>40.4.2</b> 示例2：把输入矩阵制作副本计算元素平方根</a></li>
<li class="chapter" data-level="40.4.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-mat-ex3"><i class="fa fa-check"></i><b>40.4.3</b> 示例3：访问列子集</a></li>
</ul></li>
<li class="chapter" data-level="40.5" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-other"><i class="fa fa-check"></i><b>40.5</b> Rcpp的其它向量类</a><ul>
<li class="chapter" data-level="40.5.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-logic"><i class="fa fa-check"></i><b>40.5.1</b> Rcpp的LogicalVector类</a></li>
<li class="chapter" data-level="40.5.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-vectype-char"><i class="fa fa-check"></i><b>40.5.2</b> Rcpp的CharacterVector类型</a></li>
</ul></li>
<li class="chapter" data-level="40.6" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types"><i class="fa fa-check"></i><b>40.6</b> Rcpp提供的其它数据类型</a><ul>
<li class="chapter" data-level="40.6.1" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-named"><i class="fa fa-check"></i><b>40.6.1</b> Named类型</a></li>
<li class="chapter" data-level="40.6.2" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-list"><i class="fa fa-check"></i><b>40.6.2</b> List类型</a></li>
<li class="chapter" data-level="40.6.3" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-df"><i class="fa fa-check"></i><b>40.6.3</b> Rcpp的DataFrame类</a></li>
<li class="chapter" data-level="40.6.4" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-func"><i class="fa fa-check"></i><b>40.6.4</b> Rcpp的Function类</a></li>
<li class="chapter" data-level="40.6.5" data-path="rcpp-vectype.html"><a href="rcpp-vectype.html#rcpp-types-environ"><i class="fa fa-check"></i><b>40.6.5</b> Rcpp的Environment类</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="41" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html"><i class="fa fa-check"></i><b>41</b> Rcpp糖</a><ul>
<li class="chapter" data-level="41.1" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-examp"><i class="fa fa-check"></i><b>41.1</b> 简单示例</a></li>
<li class="chapter" data-level="41.2" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop"><i class="fa fa-check"></i><b>41.2</b> 向量化的运算符</a><ul>
<li class="chapter" data-level="41.2.1" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-arith"><i class="fa fa-check"></i><b>41.2.1</b> 向量化的四则运算</a></li>
<li class="chapter" data-level="41.2.2" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-binop"><i class="fa fa-check"></i><b>41.2.2</b> 向量化的二元逻辑运算</a></li>
<li class="chapter" data-level="41.2.3" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-vecop-uop"><i class="fa fa-check"></i><b>41.2.3</b> 向量化的一元运算符</a></li>
</ul></li>
<li class="chapter" data-level="41.3" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-mathfunc"><i class="fa fa-check"></i><b>41.3</b> 用Rcpp访问数学函数</a></li>
<li class="chapter" data-level="41.4" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-any"><i class="fa fa-check"></i><b>41.4</b> 返回单一逻辑值的函数</a></li>
<li class="chapter" data-level="41.5" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-expfunc"><i class="fa fa-check"></i><b>41.5</b> 返回糖表达式的函数</a></li>
<li class="chapter" data-level="41.6" data-path="rcpp-sugar.html"><a href="rcpp-sugar.html#rcpp-sugar-diff"><i class="fa fa-check"></i><b>41.6</b> R与Rcpp不同语法示例</a></li>
</ul></li>
<li class="chapter" data-level="42" data-path="rcpp-package.html"><a href="rcpp-package.html"><i class="fa fa-check"></i><b>42</b> 用Rcpp帮助制作R扩展包</a><ul>
<li class="chapter" data-level="42.1" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-wo"><i class="fa fa-check"></i><b>42.1</b> 不用扩展包共享C++代码的方法</a></li>
<li class="chapter" data-level="42.2" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen"><i class="fa fa-check"></i><b>42.2</b> 生成扩展包</a><ul>
<li class="chapter" data-level="42.2.1" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-exist"><i class="fa fa-check"></i><b>42.2.1</b> 利用已有基于Rcpp属性的源程序制作扩展包</a></li>
<li class="chapter" data-level="42.2.2" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-desc"><i class="fa fa-check"></i><b>42.2.2</b> DESCRIPTION文件</a></li>
<li class="chapter" data-level="42.2.3" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-gen-namespace"><i class="fa fa-check"></i><b>42.2.3</b> NAMESPACE文件</a></li>
</ul></li>
<li class="chapter" data-level="42.3" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-recomp"><i class="fa fa-check"></i><b>42.3</b> 重新编译</a></li>
<li class="chapter" data-level="42.4" data-path="rcpp-package.html"><a href="rcpp-package.html#rcpp-package-interface"><i class="fa fa-check"></i><b>42.4</b> 建立C++用的接口界面</a></li>
</ul></li>
<li class="part"><span><b>X 编程例子</b></span></li>
<li class="chapter" data-level="43" data-path="examples.html"><a href="examples.html"><i class="fa fa-check"></i><b>43</b> R编程例子</a><ul>
<li class="chapter" data-level="43.1" data-path="examples.html"><a href="examples.html#examples-rlang"><i class="fa fa-check"></i><b>43.1</b> R语言</a><ul>
<li class="chapter" data-level="43.1.1" data-path="examples.html"><a href="examples.html#examples-rlang-inverse"><i class="fa fa-check"></i><b>43.1.1</b> 用向量作逆变换</a></li>
<li class="chapter" data-level="43.1.2" data-path="examples.html"><a href="examples.html#examples-rlang-fibonacci"><i class="fa fa-check"></i><b>43.1.2</b> 斐波那契数列计算</a></li>
<li class="chapter" data-level="43.1.3" data-path="examples.html"><a href="examples.html#examples-rlang-permutation"><i class="fa fa-check"></i><b>43.1.3</b> 穷举所有排列</a></li>
<li class="chapter" data-level="43.1.4" data-path="examples.html"><a href="examples.html#examples-rlang-repgroup"><i class="fa fa-check"></i><b>43.1.4</b> 可重复分组方式穷举</a></li>
<li class="chapter" data-level="43.1.5" data-path="examples.html"><a href="examples.html#examples-rlang-runs"><i class="fa fa-check"></i><b>43.1.5</b> 升降连计数</a></li>
</ul></li>
<li class="chapter" data-level="43.2" data-path="examples.html"><a href="examples.html#examples-prob"><i class="fa fa-check"></i><b>43.2</b> 概率</a><ul>
<li class="chapter" data-level="43.2.1" data-path="examples.html"><a href="examples.html#examples-prob-thsage"><i class="fa fa-check"></i><b>43.2.1</b> 智者千虑必有一失</a></li>
<li class="chapter" data-level="43.2.2" data-path="examples.html"><a href="examples.html#examples-prob-coupleseats"><i class="fa fa-check"></i><b>43.2.2</b> 圆桌夫妇座位问题</a></li>
</ul></li>
<li class="chapter" data-level="43.3" data-path="examples.html"><a href="examples.html#examples-scicomp"><i class="fa fa-check"></i><b>43.3</b> 科学计算</a><ul>
<li class="chapter" data-level="43.3.1" data-path="examples.html"><a href="examples.html#examples-scicomp-citylink"><i class="fa fa-check"></i><b>43.3.1</b> 城市间最短路径</a></li>
<li class="chapter" data-level="43.3.2" data-path="examples.html"><a href="examples.html#examples-scicomp-daub"><i class="fa fa-check"></i><b>43.3.2</b> Daubechies小波函数计算</a></li>
<li class="chapter" data-level="43.3.3" data-path="examples.html"><a href="examples.html#examples-scicomp-heating"><i class="fa fa-check"></i><b>43.3.3</b> 房间加热温度变化</a></li>
</ul></li>
<li class="chapter" data-level="43.4" data-path="examples.html"><a href="examples.html#examples-statcomp"><i class="fa fa-check"></i><b>43.4</b> 统计计算</a><ul>
<li class="chapter" data-level="43.4.1" data-path="examples.html"><a href="examples.html#examples-statcomp-kernden"><i class="fa fa-check"></i><b>43.4.1</b> 核回归与核密度估计</a></li>
<li class="chapter" data-level="43.4.2" data-path="examples.html"><a href="examples.html#examples-statcomp-mcquad2d"><i class="fa fa-check"></i><b>43.4.2</b> 二维随机模拟积分</a></li>
<li class="chapter" data-level="43.4.3" data-path="examples.html"><a href="examples.html#examples-statcomp-hidfreq"><i class="fa fa-check"></i><b>43.4.3</b> 潜周期估计</a></li>
<li class="chapter" data-level="43.4.4" data-path="examples.html"><a href="examples.html#examples-statcomp-armaest"><i class="fa fa-check"></i><b>43.4.4</b> ARMA(1,1)模型估计</a></li>
<li class="chapter" data-level="43.4.5" data-path="examples.html"><a href="examples.html#examples-statcomp-varprop"><i class="fa fa-check"></i><b>43.4.5</b> VAR模型平稳性</a></li>
<li class="chapter" data-level="43.4.6" data-path="examples.html"><a href="examples.html#examples-statcomp-storereliab"><i class="fa fa-check"></i><b>43.4.6</b> 贮存可靠性评估</a></li>
</ul></li>
<li class="chapter" data-level="43.5" data-path="examples.html"><a href="examples.html#examples-datatreat"><i class="fa fa-check"></i><b>43.5</b> 数据处理</a><ul>
<li class="chapter" data-level="43.5.1" data-path="examples.html"><a href="examples.html#examples-datatreat-subscore"><i class="fa fa-check"></i><b>43.5.1</b> 小题分题型分数汇总</a></li>
<li class="chapter" data-level="43.5.2" data-path="examples.html"><a href="examples.html#examples-datatreat-cluslab"><i class="fa fa-check"></i><b>43.5.2</b> 类别编号重排</a></li>
</ul></li>
<li class="chapter" data-level="43.6" data-path="examples.html"><a href="examples.html#examples-texttr"><i class="fa fa-check"></i><b>43.6</b> 文本处理</a><ul>
<li class="chapter" data-level="43.6.1" data-path="examples.html"><a href="examples.html#examples-texttr-hongloument"><i class="fa fa-check"></i><b>43.6.1</b> 用R语言下载处理《红楼梦》htm文件</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="http://www.math.pku.edu.cn/teachers/lidf/" target="blank">编著：李东风</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">R语言教程</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="text" class="section level1">
<h1><span class="header-section-number">36</span> R语言的文本处理</h1>
<div id="text-simple" class="section level2">
<h2><span class="header-section-number">36.1</span> 简单的文本处理</h2>
<p>在信息爆炸性增长的今天， 大量的信息是文本型的，
如互联网上的大多数资源。
R具有基本的文本数据处理能力，
而且因为R的向量语言特点和强大的统计计算和图形功能，
用R处理文本数据是可行的。</p>
<div id="text-simple-const" class="section level3">
<h3><span class="header-section-number">36.1.1</span> 字符型常量与字符型向量</h3>
<p>字符串常量写在两个双撇号或者两个单撇号中间，
建议仅使用双撇号，
因为这是大多数常见程序语言的做法。
如果内容中有单撇号或者双撇号，
可以在前面加反斜杠<code>\</code>。
为了在字符串中写一个反斜杠，
需要写成两个，
比如路径<code>C:\work</code>写成R字符串，
要写成<code>"C:\\work"</code>。
注意，
这些规定都是针对程序中的字符串常量，
数据中的文本类型数据是不需要遵照这些规定的。</p>
<p>在用<code>print()</code>显示字符串变量时，
也会按照上述的办法显示，
比如字符串内的双撇号会被自动加上前导反斜杠，
但保存的实际内容中并没有反斜杠。</p>
<p>字符串中可以有一些特殊字符，
如<code>"\n"</code>表示换行符，
<code>"\t"</code>表示制表符，
<code>"\r"</code>表示回车符，等等。</p>
<p>R的字符型向量每个元素是一个字符串，
如：</p>
<div class="sourceCode" id="cb2717"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2717-1"><a href="text.html#cb2717-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;123&quot;</span>, <span class="st">&quot;abc&quot;</span>, <span class="st">&quot;张三李四&quot;</span>, <span class="st">&quot;@#$%^&amp;&quot;</span>)</span>
<span id="cb2717-2"><a href="text.html#cb2717-2"></a>s</span></code></pre></div>
<pre><code>## [1] &quot;123&quot;      &quot;abc&quot;      &quot;张三李四&quot; &quot;@#$%^&amp;&quot;</code></pre>
<p>R中处理文本型数据的函数有文件访问函数以及<code>readLines</code>，<code>nchar</code>,
<code>paste</code>，<code>sprintf</code>， <code>format</code>，<code>formatC</code>， <code>substring</code>等函数。</p>
<p>R支持正则表达式， 函数<code>grep</code>, <code>grepl</code>, <code>sub</code>, <code>gsub</code>, <code>regexpr</code>,
<code>gregexpr</code>, <code>strsplit</code>与正则表达式有关。</p>
<p>字符型函数一般都是向量化的，
对输入的一个字符型向量的每个元素操作。</p>
<p>R扩展包stringr和stringi提供了更方便、功能更强的字符串功能，
包括正则表达式功能。
其中stringr是常用功能，
stringi是更基本、更灵活的功能，
一般使用stringr就足够了。
stringr包的函数名大多都以<code>str_</code>开头。</p>
<p>下面先介绍常用的较简单的字符串函数，
包括stringr包的函数与基本R函数。</p>
<div class="sourceCode" id="cb2719"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2719-1"><a href="text.html#cb2719-1"></a><span class="kw">library</span>(stringr)</span></code></pre></div>
</div>
<div id="text-paste" class="section level3">
<h3><span class="header-section-number">36.1.2</span> 字符串连接、重复</h3>
<p><code>stringr::str_c()</code>用来把多个输入自变量按照元素对应组合为一个字符型向量，
用<code>sep</code>指定分隔符，默认为不分隔。
类似于R中向量间运算的一般规则，
各自变量长度不同时短的自动循环使用。
非字符串类型自动转换为字符型。
如</p>
<div class="sourceCode" id="cb2720"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2720-1"><a href="text.html#cb2720-1"></a><span class="kw">str_c</span>(<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="dt">sep=</span><span class="st">&quot;*&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;x*a&quot; &quot;y*b&quot;</code></pre>
<div class="sourceCode" id="cb2722"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2722-1"><a href="text.html#cb2722-1"></a><span class="kw">str_c</span>(<span class="st">&quot;data&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;.txt&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;data1.txt&quot; &quot;data2.txt&quot; &quot;data3.txt&quot;</code></pre>
<p>字符型缺失值参与连接时，
结果变成缺失值；
可以用<code>str_replace_na()</code>函数将待连接的字符型向量中的缺失值转换成字符串<code>"NA"</code>再连接。</p>
<p>用<code>collapse</code>选项要求将连接后的字符型向量的所有元素连接在一起，
<code>collapse</code>的值为将多个元素合并时的分隔符。
如</p>
<div class="sourceCode" id="cb2724"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2724-1"><a href="text.html#cb2724-1"></a><span class="kw">str_c</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>), <span class="dt">collapse=</span><span class="st">&quot;---&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;a---bc---def&quot;</code></pre>
<p>在使用了<code>collapse</code>时如果有多个要连接的部分，
<code>str_c()</code>函数先将各部分连接成为一个字符型向量，
然后再把结果的各个向量元素连接起来。
如</p>
<div class="sourceCode" id="cb2726"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2726-1"><a href="text.html#cb2726-1"></a><span class="kw">str_c</span>(<span class="st">&quot;data&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;.txt&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>, <span class="dt">collapse=</span><span class="st">&quot;;&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;data1.txt;data2.txt;data3.txt&quot;</code></pre>
<p><code>stringr::str_flatten()</code>类似于<code>stringr::str_c()</code>仅有<code>collapse</code>参数作用一样，
仅将一个字符型向量的各个元素按照<code>collapse</code>参数指定的分隔符连接成一个长字符串，
<code>collapse</code>默认值是空字符串，如：</p>
<div class="sourceCode" id="cb2728"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2728-1"><a href="text.html#cb2728-1"></a><span class="kw">str_flatten</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>), <span class="dt">collapse=</span><span class="st">&quot;---&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;a---bc---def&quot;</code></pre>
<div class="sourceCode" id="cb2730"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2730-1"><a href="text.html#cb2730-1"></a><span class="kw">str_flatten</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;abcdef&quot;</code></pre>
<p>基本R的<code>paste()</code>函数与<code>stringr::str_c()</code>函数有类似的用法，
但是参数<code>sep</code>的默认值是空格。
基本R的<code>paste0()</code>函数相当于<code>stringr::str_c()</code>函数固定<code>sep</code>参数为空字符串。
如：</p>
<div class="sourceCode" id="cb2732"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2732-1"><a href="text.html#cb2732-1"></a><span class="kw">paste</span>(<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="dt">sep=</span><span class="st">&quot;*&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;x*a&quot; &quot;y*b&quot;</code></pre>
<div class="sourceCode" id="cb2734"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2734-1"><a href="text.html#cb2734-1"></a><span class="kw">paste</span>(<span class="st">&quot;data&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;.txt&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;data1.txt&quot; &quot;data2.txt&quot; &quot;data3.txt&quot;</code></pre>
<div class="sourceCode" id="cb2736"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2736-1"><a href="text.html#cb2736-1"></a><span class="kw">paste0</span>(<span class="st">&quot;data&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;.txt&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;data1.txt&quot; &quot;data2.txt&quot; &quot;data3.txt&quot;</code></pre>
<div class="sourceCode" id="cb2738"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2738-1"><a href="text.html#cb2738-1"></a><span class="kw">paste</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>), <span class="dt">collapse=</span><span class="st">&quot;---&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;a---bc---def&quot;</code></pre>
<div class="sourceCode" id="cb2740"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2740-1"><a href="text.html#cb2740-1"></a><span class="kw">paste</span>(<span class="st">&quot;data&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="st">&quot;.txt&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>, <span class="dt">collapse=</span><span class="st">&quot;;&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;data1.txt;data2.txt;data3.txt&quot;</code></pre>
<p><code>stringr::str_dup(string, times)</code>类似于<code>rep()</code>函数，
可以将字符型向量的元素按照<code>times</code>指定的次数在同一字符串内重复，如：</p>
<div class="sourceCode" id="cb2742"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2742-1"><a href="text.html#cb2742-1"></a><span class="kw">str_dup</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;长江&quot;</span>), <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] &quot;abcabcabc&quot;    &quot;长江长江长江&quot;</code></pre>
<p>也可以针对每个元素指定不同重复次数，如</p>
<div class="sourceCode" id="cb2744"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2744-1"><a href="text.html#cb2744-1"></a><span class="kw">str_dup</span>(<span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;长江&quot;</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>))</span></code></pre></div>
<pre><code>## [1] &quot;abcabcabc&quot; &quot;长江长江&quot;</code></pre>
</div>
<div id="text-formatout" class="section level3">
<h3><span class="header-section-number">36.1.3</span> 格式化输出</h3>
<div id="text-formatout-format" class="section level4">
<h4><span class="header-section-number">36.1.3.1</span> <code>format()</code>函数</h4>
<p><code>format()</code>函数可以将一个数值型向量的各个元素按照统一格式转换为字符型，
如：</p>
<div class="sourceCode" id="cb2746"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2746-1"><a href="text.html#cb2746-1"></a><span class="kw">as.character</span>(<span class="fl">1.000</span>)</span></code></pre></div>
<pre><code>## [1] &quot;1&quot;</code></pre>
<div class="sourceCode" id="cb2748"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2748-1"><a href="text.html#cb2748-1"></a><span class="kw">as.character</span>(<span class="fl">1.2</span>)</span></code></pre></div>
<pre><code>## [1] &quot;1.2&quot;</code></pre>
<div class="sourceCode" id="cb2750"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2750-1"><a href="text.html#cb2750-1"></a><span class="kw">as.character</span>(<span class="fl">1.23</span>)</span></code></pre></div>
<pre><code>## [1] &quot;1.23&quot;</code></pre>
<div class="sourceCode" id="cb2752"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2752-1"><a href="text.html#cb2752-1"></a><span class="kw">format</span>(<span class="kw">c</span>(<span class="fl">1.000</span>, <span class="fl">1.2</span>, <span class="fl">1.23</span>))</span></code></pre></div>
<pre><code>## [1] &quot;1.00&quot; &quot;1.20&quot; &quot;1.23&quot;</code></pre>
<p>选项<code>digits</code>与<code>nsmall</code>共同控制输出的精度，
<code>nsmall</code>控制非科学记数法显示时小数点后的至少要有的位数，
<code>digits</code>控制至少要有的有效位数。
这使得输出的宽度是不可控的，
如：</p>
<div class="sourceCode" id="cb2754"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2754-1"><a href="text.html#cb2754-1"></a><span class="kw">format</span>(<span class="kw">c</span>(pi, pi<span class="op">*</span><span class="dv">10000</span>), <span class="dt">digits=</span><span class="dv">8</span>, <span class="dt">nsmall=</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] &quot;    3.1415927&quot; &quot;31415.9265359&quot;</code></pre>
<p><code>width</code>参数指定至少要有的输出宽度，
不足时默认在左侧用空格填充，如：</p>
<div class="sourceCode" id="cb2756"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2756-1"><a href="text.html#cb2756-1"></a><span class="kw">format</span>(<span class="fl">1.000</span>, <span class="dt">width=</span><span class="dv">6</span>, <span class="dt">nsmall=</span><span class="dv">2</span>)</span></code></pre></div>
<pre><code>## [1] &quot;  1.00&quot;</code></pre>
<p><code>format()</code>还有许多选项，
详见函数的帮助。</p>
</div>
<div id="text-formatout-sprintf" class="section level4">
<h4><span class="header-section-number">36.1.3.2</span> <code>sprintf()</code>函数</h4>
<p><code>format()</code>函数无法精确控制输出长度和格式。
<code>sprintf</code>是C语言中<code>sprintf</code>的向量化版本，
可以把一个元素或一个向量的各个元素按照C语言输出格式转换为字符型向量。
第一个自变量是C语言格式的输出格式字符串，
其中<code>%d</code>表示输出整数，<code>%f</code>表示输出实数，
<code>%02d</code>表示输出宽度为2、不够左填0的整数，
<code>%6.2f</code>表示输出宽度为6、宽度不足时左填空格、含两位小数的实数，
等等。</p>
<p>比如，标量转换</p>
<div class="sourceCode" id="cb2758"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2758-1"><a href="text.html#cb2758-1"></a><span class="kw">sprintf</span>(<span class="st">&quot;%6.2f&quot;</span>, pi)</span></code></pre></div>
<pre><code>## [1] &quot;  3.14&quot;</code></pre>
<p>又如，向量转换：</p>
<div class="sourceCode" id="cb2760"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2760-1"><a href="text.html#cb2760-1"></a><span class="kw">sprintf</span>(<span class="st">&quot;tour%03d.jpg&quot;</span>, <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">100</span>))</span></code></pre></div>
<pre><code>## [1] &quot;tour001.jpg&quot; &quot;tour005.jpg&quot; &quot;tour010.jpg&quot; &quot;tour015.jpg&quot; &quot;tour100.jpg&quot;</code></pre>
<p>还可以支持多个向量同时转换，如：</p>
<div class="sourceCode" id="cb2762"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2762-1"><a href="text.html#cb2762-1"></a><span class="kw">sprintf</span>(<span class="st">&quot;%1dx%1d=%2d&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>, <span class="dv">5</span><span class="op">:</span><span class="dv">1</span>, (<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>)<span class="op">*</span>(<span class="dv">5</span><span class="op">:</span><span class="dv">1</span>))</span></code></pre></div>
<pre><code>## [1] &quot;1x5= 5&quot; &quot;2x4= 8&quot; &quot;3x3= 9&quot; &quot;4x2= 8&quot; &quot;5x1= 5&quot;</code></pre>
</div>
<div id="text-formatout-glue" class="section level4">
<h4><span class="header-section-number">36.1.3.3</span> 字符串插值函数</h4>
<p>许多脚本型程序设计语言都有在字符串的内容中插入变量值的功能，
R本身不具有这样的功能，
<code>sprintf()</code>函数有类似作用但只是一个不方便使用的副作用。</p>
<p><code>stringr::str_glue()</code>和<code>stringr::str_glue_data()</code>提供了字符串插值的功能。
只要在字符串内用大括号写变量名，
则函数可以将字符串内容中的变量名替换成变量值，如：</p>
<div class="sourceCode" id="cb2764"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2764-1"><a href="text.html#cb2764-1"></a>name &lt;-<span class="st"> &quot;李明&quot;</span></span>
<span id="cb2764-2"><a href="text.html#cb2764-2"></a>tele &lt;-<span class="st"> &quot;13512345678&quot;</span></span>
<span id="cb2764-3"><a href="text.html#cb2764-3"></a><span class="kw">str_glue</span>(<span class="st">&quot;姓名: {name}</span><span class="ch">\n</span><span class="st">电话号码: {tele}</span><span class="ch">\n</span><span class="st">&quot;</span>)</span></code></pre></div>
<pre><code>## 姓名: 李明
## 电话号码: 13512345678</code></pre>
<p>上面的例子直接用了换行符<code>"\n"</code>来分开不同内容。
也可以输入多个字符串作为自变量，
内容自动连接在一起，可以用参数<code>.sep</code>指定分隔符：</p>
<div class="sourceCode" id="cb2766"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2766-1"><a href="text.html#cb2766-1"></a>name &lt;-<span class="st"> &quot;李明&quot;</span></span>
<span id="cb2766-2"><a href="text.html#cb2766-2"></a>tele &lt;-<span class="st"> &quot;13512345678&quot;</span></span>
<span id="cb2766-3"><a href="text.html#cb2766-3"></a><span class="kw">str_glue</span>(<span class="st">&quot;姓名: {name}, &quot;</span>, <span class="st">&quot;电话号码: {tele}&quot;</span>)</span></code></pre></div>
<pre><code>## 姓名: 李明, 电话号码: 13512345678</code></pre>
<div class="sourceCode" id="cb2768"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2768-1"><a href="text.html#cb2768-1"></a><span class="kw">str_glue</span>(<span class="st">&quot;姓名: {name}&quot;</span>, <span class="st">&quot;电话号码: {tele}&quot;</span>, <span class="dt">.sep=</span><span class="st">&quot;; &quot;</span>)</span></code></pre></div>
<pre><code>## 姓名: 李明; 电话号码: 13512345678</code></pre>
<p>也可以直接在<code>str_glue()</code>中指定变量值，如：</p>
<div class="sourceCode" id="cb2770"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2770-1"><a href="text.html#cb2770-1"></a><span class="kw">str_glue</span>(<span class="st">&quot;姓名: {name}&quot;</span>, <span class="st">&quot;电话号码: {tele}&quot;</span>, <span class="dt">.sep=</span><span class="st">&quot;; &quot;</span>,</span>
<span id="cb2770-2"><a href="text.html#cb2770-2"></a>         <span class="dt">name =</span> <span class="st">&quot;张三&quot;</span>, <span class="dt">tele =</span> <span class="st">&quot;13588888888&quot;</span>)</span></code></pre></div>
<pre><code>## 姓名: 张三; 电话号码: 13588888888</code></pre>
<p><code>stringr::str_glue_data()</code>则以一个包含变量定义的对象<code>.x</code>为第一自变量，
类型可以是环境、列表、数据框等。如：</p>
<div class="sourceCode" id="cb2772"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2772-1"><a href="text.html#cb2772-1"></a><span class="kw">str_glue_data</span>(<span class="kw">list</span>(<span class="dt">name =</span> <span class="st">&quot;王五&quot;</span>, <span class="dt">tele =</span> <span class="st">&quot;13500000000&quot;</span>),</span>
<span id="cb2772-2"><a href="text.html#cb2772-2"></a>              <span class="st">&quot;姓名: {name}&quot;</span>, <span class="st">&quot;电话号码: {tele}&quot;</span>, <span class="dt">.sep=</span><span class="st">&quot;; &quot;</span>)</span></code></pre></div>
<pre><code>## 姓名: 王五; 电话号码: 13500000000</code></pre>
</div>
</div>
<div id="text-length" class="section level3">
<h3><span class="header-section-number">36.1.4</span> 字符串长度</h3>
<p><code>stringr::str_length(string)</code>求字符型向量<code>string</code>每个元素的长度。
一个汉字长度为1。</p>
<div class="sourceCode" id="cb2774"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2774-1"><a href="text.html#cb2774-1"></a><span class="kw">str_length</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;北京&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1 2 3 2</code></pre>
<p>函数<code>nchar(text)</code>计算字符串长度，默认按照字符个数计算而不是按字节数计算，
如</p>
<div class="sourceCode" id="cb2776"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2776-1"><a href="text.html#cb2776-1"></a><span class="kw">nchar</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;北京&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1 2 3 2</code></pre>
<p>注意函数对输入的字符型向量每个元素计算长度。</p>
<p><code>nchar()</code>加选项<code>type="bytes"</code>可用按字符串占用的字节数计算，
这时一个汉字占用多个字节（具体占用多少与编码有关）。
如</p>
<div class="sourceCode" id="cb2778"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2778-1"><a href="text.html#cb2778-1"></a><span class="kw">nchar</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;bc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;北京&quot;</span>), <span class="dt">type=</span><span class="st">&quot;bytes&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 1 2 3 4</code></pre>
</div>
<div id="text-substring" class="section level3">
<h3><span class="header-section-number">36.1.5</span> 取子串</h3>
<p><code>stringr::str_sub(string, start, end)</code>字符串字串，
用开始字符位置<code>start</code>和结束字符位置<code>end</code>设定字串位置。
用负数表示倒数位置。
默认开始位置为1，
默认结束位置为最后一个字符。</p>
<p>如：</p>
<div class="sourceCode" id="cb2780"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2780-1"><a href="text.html#cb2780-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">5</span>, <span class="dv">8</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017&quot;</code></pre>
<div class="sourceCode" id="cb2782"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2782-1"><a href="text.html#cb2782-1"></a><span class="kw">str_sub</span>(<span class="kw">c</span>(<span class="st">&quot;term2017&quot;</span>, <span class="st">&quot;term2018&quot;</span>), <span class="dv">5</span>, <span class="dv">8</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017&quot; &quot;2018&quot;</code></pre>
<div class="sourceCode" id="cb2784"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2784-1"><a href="text.html#cb2784-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017&quot;</code></pre>
<div class="sourceCode" id="cb2786"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2786-1"><a href="text.html#cb2786-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">-4</span>, <span class="dv">-1</span>)</span></code></pre></div>
<pre><code>## [1] &quot;2017&quot;</code></pre>
<div class="sourceCode" id="cb2788"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2788-1"><a href="text.html#cb2788-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dt">end=</span><span class="dv">4</span>)</span></code></pre></div>
<pre><code>## [1] &quot;term&quot;</code></pre>
<p>取子串时，一般按照字符个数计算位置，如</p>
<div class="sourceCode" id="cb2790"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2790-1"><a href="text.html#cb2790-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;北京市海淀区颐和园路5号&quot;</span>, <span class="dv">4</span>, <span class="dv">6</span>)</span></code></pre></div>
<pre><code>## [1] &quot;海淀区&quot;</code></pre>
<p>当起始位置超过总长度或结束位置超过第一个字符时返回空字符串；
当起始位置超过结束位置是返回空字符串。
如：</p>
<div class="sourceCode" id="cb2792"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2792-1"><a href="text.html#cb2792-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">9</span>)</span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<div class="sourceCode" id="cb2794"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2794-1"><a href="text.html#cb2794-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">1</span>, <span class="dv">-9</span>)</span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<div class="sourceCode" id="cb2796"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2796-1"><a href="text.html#cb2796-1"></a><span class="kw">str_sub</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dv">8</span>, <span class="dv">5</span>)</span></code></pre></div>
<pre><code>## [1] &quot;&quot;</code></pre>
<p>可以对<code>str_sub()</code>结果赋值，表示修改子串内容，如：</p>
<div class="sourceCode" id="cb2798"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2798-1"><a href="text.html#cb2798-1"></a>s &lt;-<span class="st"> &quot;term2017&quot;</span></span>
<span id="cb2798-2"><a href="text.html#cb2798-2"></a><span class="kw">str_sub</span>(s, <span class="dv">5</span>, <span class="dv">8</span>) &lt;-<span class="st"> &quot;18&quot;</span></span>
<span id="cb2798-3"><a href="text.html#cb2798-3"></a>s</span></code></pre></div>
<pre><code>## [1] &quot;term18&quot;</code></pre>
<p>字符串替换一般还是应该使用专用的替换函数如<code>stringr::str_replace_all()</code>，
<code>gsub()</code>。</p>
<p>基本R的<code>substring(text, first, last)</code>函数与<code>stringr::str_sub()</code>功能相同，
但<code>first</code>和<code>last</code>参数不允许用负数,
<code>last</code>的默认值是一个很大的数，所以省略<code>last</code>时会取到字符串末尾。
<code>substring()</code>对三个参数<code>text</code>, <code>first</code>, <code>last</code>都是向量化的，
长度不一致时按照一般的不等长向量间运算规则处理。如：</p>
<div class="sourceCode" id="cb2800"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2800-1"><a href="text.html#cb2800-1"></a><span class="kw">substring</span>(<span class="kw">c</span>(<span class="st">&quot;term2017&quot;</span>, <span class="st">&quot;term2018&quot;</span>), <span class="dt">first=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="dt">last=</span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">8</span>))</span></code></pre></div>
<pre><code>## [1] &quot;term&quot; &quot;2018&quot;</code></pre>
<div class="sourceCode" id="cb2802"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2802-1"><a href="text.html#cb2802-1"></a><span class="kw">substring</span>(<span class="st">&quot;term2017&quot;</span>, <span class="dt">first=</span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="dt">last=</span><span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">8</span>))</span></code></pre></div>
<pre><code>## [1] &quot;term&quot; &quot;2017&quot;</code></pre>
<p><code>substring()</code>也允许修改某个字符串的指定子串的内容，如</p>
<div class="sourceCode" id="cb2804"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2804-1"><a href="text.html#cb2804-1"></a>s &lt;-<span class="st"> &quot;123456789&quot;</span></span>
<span id="cb2804-2"><a href="text.html#cb2804-2"></a><span class="kw">substring</span>(s, <span class="dv">3</span>, <span class="dv">5</span>) &lt;-<span class="st"> &quot;abc&quot;</span></span>
<span id="cb2804-3"><a href="text.html#cb2804-3"></a>s</span></code></pre></div>
<pre><code>## [1] &quot;12abc6789&quot;</code></pre>
<p>R的<code>substr(x, start, stop)</code>作用类似，
但是仅支持<code>x</code>为字符型向量，
<code>start</code>和<code>stop</code>是标量。</p>
</div>
<div id="text-convert" class="section level3">
<h3><span class="header-section-number">36.1.6</span> 字符串变换</h3>
<div id="text-convert-case" class="section level4">
<h4><span class="header-section-number">36.1.6.1</span> 大小写</h4>
<p><code>stringr::str_to_upper(string)</code>将字符型向量<code>string</code>中的英文字母都转换为大写。
类似函数有<code>stringr::str_to_lower(string)</code>转换为小写，
<code>stringr::str_to_title(string)</code>转换为标题需要的大小写，
<code>stringr::str_to_scentence(string)</code>转换为句子需要的大小写。
这都是针对英文的，
选项<code>locale</code>用来选语言，<code>locale="en"</code>为默认值。</p>
<p>基本R的<code>toupper()</code>将字符型向量的每个元素中的小写字母转换为大写,
<code>tolower()</code>转小写。</p>
</div>
<div id="text-convert-chartr" class="section level4">
<h4><span class="header-section-number">36.1.6.2</span> 字符变换表</h4>
<p>基本R的<code>chartr(old, new, x)</code>函数指定一个字符对应关系，
旧字符在<code>old</code>中，新字符在<code>new</code>中，<code>x</code>是一个要进行替换的字符型向量。
比如，下面的例子把所有<code>!</code>替换成<code>.</code>，把所有<code>;</code>替换成<code>,</code>：</p>
<div class="sourceCode" id="cb2806"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2806-1"><a href="text.html#cb2806-1"></a><span class="kw">chartr</span>(<span class="st">&quot;!;&quot;</span>, <span class="st">&quot;.,&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Hi; boy!&quot;</span>, <span class="st">&quot;How do you do!&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;Hi, boy.&quot;       &quot;How do you do.&quot;</code></pre>
<div class="sourceCode" id="cb2808"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2808-1"><a href="text.html#cb2808-1"></a><span class="kw">chartr</span>(<span class="st">&quot;。，；县&quot;</span>, <span class="st">&quot;.,;区&quot;</span>, <span class="st">&quot;昌平县，大兴县；固安县。&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;昌平区,大兴区;固安区.&quot;</code></pre>
<p>第二个例子中被替换的标点是中文标点，替换成了相应的英文标点。</p>
</div>
<div id="text-convert-trimw" class="section level4">
<h4><span class="header-section-number">36.1.6.3</span> 空白处理</h4>
<p><code>stringr::str_trim(string, side)</code>返回删去字符型向量<code>string</code>每个元素的首尾空格的结果，
可以用<code>side</code>指定删除首尾空格（<code>"both"</code>）、开头空格（<code>"left"</code>）、末尾空格（<code>"right"</code>）。
如：</p>
<div class="sourceCode" id="cb2810"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2810-1"><a href="text.html#cb2810-1"></a><span class="kw">str_trim</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot;   &quot;李明&quot;   &quot;李明&quot;   &quot;李  明&quot;</code></pre>
<div class="sourceCode" id="cb2812"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2812-1"><a href="text.html#cb2812-1"></a><span class="kw">str_trim</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>), <span class="dt">side=</span><span class="st">&quot;left&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot;   &quot;李明  &quot; &quot;李明  &quot; &quot;李  明&quot;</code></pre>
<div class="sourceCode" id="cb2814"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2814-1"><a href="text.html#cb2814-1"></a><span class="kw">str_trim</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>), <span class="dt">side=</span><span class="st">&quot;right&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;  李明&quot; &quot;李明&quot;   &quot;  李明&quot; &quot;李  明&quot;</code></pre>
<p><code>stringr::str_squish(string)</code>对字符型向量<code>string</code>每个元素，
删去首尾空格，将重复空格变成单个，返回变换后的结果。如：</p>
<div class="sourceCode" id="cb2816"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2816-1"><a href="text.html#cb2816-1"></a><span class="kw">str_squish</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot;  &quot;李明&quot;  &quot;李明&quot;  &quot;李 明&quot;</code></pre>
<p>基本R函数<code>trimws(x, which)</code>与<code>str_trim()</code>作用类似，
选项<code>which="left"</code>可以仅删去开头的空格，
选项<code>which="right"</code>可以仅删去结尾的空格。</p>
<div class="sourceCode" id="cb2818"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2818-1"><a href="text.html#cb2818-1"></a><span class="kw">trimws</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot;   &quot;李明&quot;   &quot;李明&quot;   &quot;李  明&quot;</code></pre>
<div class="sourceCode" id="cb2820"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2820-1"><a href="text.html#cb2820-1"></a><span class="kw">trimws</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>), <span class="dt">which=</span><span class="st">&quot;left&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot;   &quot;李明  &quot; &quot;李明  &quot; &quot;李  明&quot;</code></pre>
<div class="sourceCode" id="cb2822"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2822-1"><a href="text.html#cb2822-1"></a><span class="kw">trimws</span>(<span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>), <span class="dt">which=</span><span class="st">&quot;right&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;  李明&quot; &quot;李明&quot;   &quot;  李明&quot; &quot;李  明&quot;</code></pre>
<p>为了去掉输入字符串中所有空格，可以用<code>gsub()</code>替换功能，如：</p>
<div class="sourceCode" id="cb2824"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2824-1"><a href="text.html#cb2824-1"></a><span class="kw">gsub</span>(<span class="st">&quot; &quot;</span>, <span class="st">&quot;&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;  李明&quot;</span>, <span class="st">&quot;李明  &quot;</span>, <span class="st">&quot;  李明  &quot;</span>, <span class="st">&quot;李  明&quot;</span>), <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;李明&quot; &quot;李明&quot; &quot;李明&quot; &quot;李明&quot;</code></pre>
<p><code>stringr::str_pad(string, width)</code>可以将字符型向量<code>string</code>的每个元素加长到<code>width</code>个字符，
不足时左补空格，已经达到或超过<code>width</code>的则不变，如：</p>
<div class="sourceCode" id="cb2826"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2826-1"><a href="text.html#cb2826-1"></a><span class="kw">str_pad</span>(<span class="kw">c</span>(<span class="st">&quot;12&quot;</span>, <span class="st">&quot;1234&quot;</span>), <span class="dv">3</span>)</span></code></pre></div>
<pre><code>## [1] &quot; 12&quot;  &quot;1234&quot;</code></pre>
<p>可以用选项<code>side</code>选择在哪里填补空格，
默认为<code>"left"</code>，
还可选<code>"right"</code>，<code>"both"</code>。</p>
<p><code>stringr::str_wrap()</code>可以将作为字符型向量的长字符串拆分成近似等长的行，
行之间用换行符分隔。</p>
</div>
<div id="text-sort" class="section level4">
<h4><span class="header-section-number">36.1.6.4</span> 排序</h4>
<p>基本R函数<code>sort()</code>可以用来对字符型向量的各个元素按照字典序排序，
但是字符的先后顺序是按照操作系统的当前编码值次序，
见关于<code>locales</code>的帮助。</p>
<p><code>str_sort(x)</code>对字符型向量<code>x</code>排序。
可以用<code>locale</code>选项指定所依据的locale，
不同的locale下次序不同。
默认为<code>"en"</code>即英语，
中国大陆的GB编码(包括GBK和GB18030)对应的locale是<code>"zh"</code>。</p>
<p><code>str_order(x)</code>返回将<code>x</code>的各个元素从小到大排序的下标序列。</p>
</div>
</div>
<div id="text-simp-find" class="section level3">
<h3><span class="header-section-number">36.1.7</span> 简单匹配与查找</h3>
<div id="text-simp-find-starts" class="section level4">
<h4><span class="header-section-number">36.1.7.1</span> 开头和结尾匹配</h4>
<p>基本R的<code>startsWith(x, prefix)</code>可以判断字符型向量<code>x</code>的每个元素是否以<code>prefix</code>开头，
结果为一个与<code>x</code>长度相同的逻辑型向量。如</p>
<div class="sourceCode" id="cb2828"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2828-1"><a href="text.html#cb2828-1"></a><span class="kw">startsWith</span>(<span class="kw">c</span>(<span class="st">&quot;xyz123&quot;</span>, <span class="st">&quot;tu004&quot;</span>), <span class="st">&quot;tu&quot;</span>)</span></code></pre></div>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p><code>endsWith(x, suffix)</code>可以判断字符型向量<code>x</code>的每个元素是否以<code>suffix</code>结尾，
如</p>
<div class="sourceCode" id="cb2830"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2830-1"><a href="text.html#cb2830-1"></a><span class="kw">endsWith</span>(<span class="kw">c</span>(<span class="st">&quot;xyz123&quot;</span>, <span class="st">&quot;tu004&quot;</span>), <span class="st">&quot;123&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  TRUE FALSE</code></pre>
<p>stringr包的<code>str_starts(string, pattern)</code>判断<code>string</code>的每个元素是否以模式<code>pattern</code>开头，
加选项<code>negate=TRUE</code>表示输出反面结果。
<code>pattern</code>是正则表达式，
如果需要用非正则表达式，可以用<code>fixed()</code>或者<code>coll()</code>保护，如：</p>
<div class="sourceCode" id="cb2832"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2832-1"><a href="text.html#cb2832-1"></a><span class="kw">str_starts</span>(<span class="kw">c</span>(<span class="st">&quot;xyz123&quot;</span>, <span class="st">&quot;tu004&quot;</span>), <span class="kw">fixed</span>(<span class="st">&quot;tu&quot;</span>))</span></code></pre></div>
<pre><code>## [1] FALSE  TRUE</code></pre>
<div class="sourceCode" id="cb2834"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2834-1"><a href="text.html#cb2834-1"></a><span class="kw">str_starts</span>(<span class="kw">c</span>(<span class="st">&quot;xyz123&quot;</span>, <span class="st">&quot;tu004&quot;</span>), <span class="kw">coll</span>(<span class="st">&quot;tu&quot;</span>))</span></code></pre></div>
<pre><code>## [1] FALSE  TRUE</code></pre>
<p>stringr包的<code>str_ends(string, pattern)</code>判断是否以给定模式结尾。</p>
</div>
<div id="text-simp-find-grepl" class="section level4">
<h4><span class="header-section-number">36.1.7.2</span> 中间匹配</h4>
<p>函数<code>grep()</code>, <code>grepl()</code>等可以用于查找子字符串，
位置不限于开头和结尾，
详见“正则表达式”章节。</p>
<p>在<code>grepl()</code>函数中加<code>fixed=TRUE</code>选项表示查找一般文本内容（非正则表达式）。
比如，查找字符串中是否含有our:</p>
<div class="sourceCode" id="cb2836"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2836-1"><a href="text.html#cb2836-1"></a><span class="kw">grepl</span>(<span class="st">&quot;our&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;flavor&quot;</span>, <span class="st">&quot;tournament&quot;</span>), <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] FALSE  TRUE</code></pre>
</div>
</div>
<div id="text-simple-gsub" class="section level3">
<h3><span class="header-section-number">36.1.8</span> 字符串替换</h3>
<p>用<code>gsub(pattern, replacement, x, fixed=TRUE)</code>
把字符型向量<code>x</code>中每个元素中出现的子串
<code>pattern</code>都替换为<code>replacement</code>。
如</p>
<div class="sourceCode" id="cb2838"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2838-1"><a href="text.html#cb2838-1"></a><span class="kw">gsub</span>(<span class="st">&quot;the&quot;</span>, <span class="st">&quot;**&quot;</span>,</span>
<span id="cb2838-2"><a href="text.html#cb2838-2"></a>     <span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>),</span>
<span id="cb2838-3"><a href="text.html#cb2838-3"></a>     <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;New **me&quot;           &quot;Old times&quot;          &quot;In ** present **me&quot;</code></pre>
<p>设有些应用程序的输入要求使用逗号“<code>,</code>”分隔，
但是用户可能输入了中文逗号“，”，
就可以用<code>gsub()</code>来替换：</p>
<div class="sourceCode" id="cb2840"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2840-1"><a href="text.html#cb2840-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;15.34,14.11&quot;</span>, <span class="st">&quot;13.25，16.92&quot;</span>)</span>
<span id="cb2840-2"><a href="text.html#cb2840-2"></a>x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;，&quot;</span>, <span class="st">&quot;,&quot;</span>, x, <span class="dt">fixed=</span><span class="ot">TRUE</span>); x</span></code></pre></div>
<pre><code>## [1] &quot;15.34,14.11&quot; &quot;13.25,16.92&quot;</code></pre>
<p>例子中<code>x</code>的第二个元素中的逗号是中文逗号。</p>
<p>函数<code>sub()</code>与<code>gsub()</code>类似，但是仅替换第一次出现的<code>pattern</code>。</p>
</div>
<div id="text-simple-strsplit" class="section level3">
<h3><span class="header-section-number">36.1.9</span> 字符串拆分</h3>
<p><code>stringr::str_split(string, pattern)</code>对字符型向量<code>string</code>的每一个元素按分隔符<code>pattern</code>进行拆分，
每个元素拆分为一个字符型向量，结果是一个列表，列表元素为字符型向量。
其中<code>pattern</code>是正则表达式，
为了按照固定模式拆分，用<code>fixed()</code>进行保护。如</p>
<div class="sourceCode" id="cb2842"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2842-1"><a href="text.html#cb2842-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;11,12&quot;</span>, <span class="st">&quot;21,22,23&quot;</span>, <span class="st">&quot;31,32,33,34&quot;</span>)</span>
<span id="cb2842-2"><a href="text.html#cb2842-2"></a>res1 &lt;-<span class="st"> </span><span class="kw">str_split</span>(x, <span class="kw">fixed</span>(<span class="st">&quot;,&quot;</span>))</span>
<span id="cb2842-3"><a href="text.html#cb2842-3"></a>res1</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;11&quot; &quot;12&quot;
## 
## [[2]]
## [1] &quot;21&quot; &quot;22&quot; &quot;23&quot;
## 
## [[3]]
## [1] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot;</code></pre>
<p><code>str_split()</code>可以用选项<code>n</code>指定仅拆分出成几项，最后一项合并不拆分，如：</p>
<div class="sourceCode" id="cb2844"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2844-1"><a href="text.html#cb2844-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;11,12&quot;</span>, <span class="st">&quot;21,22,23&quot;</span>, <span class="st">&quot;31,32,33,34&quot;</span>)</span>
<span id="cb2844-2"><a href="text.html#cb2844-2"></a>res2 &lt;-<span class="st"> </span><span class="kw">str_split</span>(x, <span class="kw">fixed</span>(<span class="st">&quot;,&quot;</span>), <span class="dt">n=</span><span class="dv">2</span>)</span>
<span id="cb2844-3"><a href="text.html#cb2844-3"></a>res2</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;11&quot; &quot;12&quot;
## 
## [[2]]
## [1] &quot;21&quot;    &quot;22,23&quot;
## 
## [[3]]
## [1] &quot;31&quot;       &quot;32,33,34&quot;</code></pre>
<p>拆分的结果可以用<code>lapply()</code>, <code>sapply()</code>，<code>vapply()</code>等函数处理。
例如，
将每个元素的拆分结果转换成数值型：</p>
<div class="sourceCode" id="cb2846"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2846-1"><a href="text.html#cb2846-1"></a><span class="kw">lapply</span>(res1, as.numeric)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 11 12
## 
## [[2]]
## [1] 21 22 23
## 
## [[3]]
## [1] 31 32 33 34</code></pre>
<p>可以用<code>unlist()</code>函数将列表中的各个向量连接成一个长向量，如：</p>
<div class="sourceCode" id="cb2848"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2848-1"><a href="text.html#cb2848-1"></a><span class="kw">unlist</span>(res1)</span></code></pre></div>
<pre><code>## [1] &quot;11&quot; &quot;12&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot;</code></pre>
<p>注意，即使输入只有一个字符串，<code>str_split()</code>的结果也是列表，
所以输入只有一个字符串时我们应该取出结果列表的第一个元素，如</p>
<div class="sourceCode" id="cb2850"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2850-1"><a href="text.html#cb2850-1"></a><span class="kw">strsplit</span>(<span class="st">&quot;31,32,33,34&quot;</span>, <span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot;</code></pre>
<p>如果确知每个字符串拆分出来的字符串个数都相同，
可以用<code>stringr::str_split_fixed()</code>，
用参数<code>n</code>指定拆出来的项数，
这时结果为一个字符型矩阵，
原来的每个元素变成结果中的一行：</p>
<div class="sourceCode" id="cb2852"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2852-1"><a href="text.html#cb2852-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;11,12&quot;</span>, <span class="st">&quot;21,22&quot;</span>, <span class="st">&quot;31,32&quot;</span>)</span>
<span id="cb2852-2"><a href="text.html#cb2852-2"></a>res3 &lt;-<span class="st"> </span><span class="kw">str_split_fixed</span>(x, <span class="kw">fixed</span>(<span class="st">&quot;,&quot;</span>), <span class="dt">n=</span><span class="dv">2</span>)</span>
<span id="cb2852-3"><a href="text.html#cb2852-3"></a>res3</span></code></pre></div>
<pre><code>##      [,1] [,2]
## [1,] &quot;11&quot; &quot;12&quot;
## [2,] &quot;21&quot; &quot;22&quot;
## [3,] &quot;31&quot; &quot;32&quot;</code></pre>
<p>基本R的<code>strsplit(x,split,fixed=TRUE)</code>
可以把字符型向量<code>x</code>的每一个元素按分隔符<code>split</code>拆分为一个字符型向量，
<code>strsplit</code>的结果为一个列表，
每个列表元素对应于<code>x</code>的每个元素。</p>
<p>如</p>
<div class="sourceCode" id="cb2854"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2854-1"><a href="text.html#cb2854-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;11,12&quot;</span>, <span class="st">&quot;21,22,23&quot;</span>, <span class="st">&quot;31,32,33,34&quot;</span>)</span>
<span id="cb2854-2"><a href="text.html#cb2854-2"></a>res4 &lt;-<span class="st"> </span><span class="kw">strsplit</span>(x, <span class="dt">split=</span><span class="st">&quot;,&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span>
<span id="cb2854-3"><a href="text.html#cb2854-3"></a>res4</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;11&quot; &quot;12&quot;
## 
## [[2]]
## [1] &quot;21&quot; &quot;22&quot; &quot;23&quot;
## 
## [[3]]
## [1] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot;</code></pre>
</div>
</div>
<div id="text-file" class="section level2">
<h2><span class="header-section-number">36.2</span> 文本文件读写</h2>
<p>文本文件是内容为普通文字、用换行分隔成多行的文件，
与二进制文件有区别，
二进制文件中换行符没有特殊含义，
而且二进制文件的内容往往也不是文字内容。
二进制文件的代表有图片、声音，
以及各种专用软件的的私有格式文件，
如Word文件、Excel文件。</p>
<p>对于文本文件，可以用<code>readLines()</code>函数将其各行的内容读入为一个字符型数组，
字符型数组的每一个元素对应于文件中的一行，
读入的字符型数组元素不包含分隔行用的换行符。</p>
<p>最简单的用法是读入一个本地的文本文件，
一次性读入所有内容，用如</p>
<div class="sourceCode" id="cb2856"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2856-1"><a href="text.html#cb2856-1"></a>lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="st">&quot;filename.ext&quot;</span>)</span></code></pre></div>
<p>其中<code>filename.ext</code>是文件名，
也可以用全路径名或相对路径名。</p>
<p>当文本文件很大的时候，
整体读入有时存不下，
即使能存下处理速度也很慢，
可以一次读入部分行，逐批读入并且逐批处理，这样程序效率更高。
这样的程序要复杂一些，例如</p>
<div class="sourceCode" id="cb2857"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2857-1"><a href="text.html#cb2857-1"></a>infcon &lt;-<span class="st"> </span><span class="kw">file</span>(<span class="st">&quot;filename.ext&quot;</span>, <span class="dt">open=</span><span class="st">&quot;rt&quot;</span>)</span>
<span id="cb2857-2"><a href="text.html#cb2857-2"></a>batch &lt;-<span class="st"> </span><span class="dv">1000</span></span>
<span id="cb2857-3"><a href="text.html#cb2857-3"></a><span class="cf">repeat</span>{</span>
<span id="cb2857-4"><a href="text.html#cb2857-4"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(infcon, <span class="dt">n=</span>batch)</span>
<span id="cb2857-5"><a href="text.html#cb2857-5"></a>  <span class="cf">if</span>(<span class="kw">length</span>(lines)<span class="op">==</span><span class="dv">0</span>) <span class="cf">break</span></span>
<span id="cb2857-6"><a href="text.html#cb2857-6"></a>  <span class="co">## 处理读入的这些行</span></span>
<span id="cb2857-7"><a href="text.html#cb2857-7"></a>}</span>
<span id="cb2857-8"><a href="text.html#cb2857-8"></a><span class="kw">close</span>(infcon)</span></code></pre></div>
<p>以上程序先打开一个文件，<code>inffcon</code>是打开的文件的读写入口（称为一个“连接对象”）。
每次读入指定的行并处理读入的行，直到读入了0行为止，
最后关闭<code>infcon</code>连接。</p>
<p>对文本文件的典型处理是读入后作一些修改，
另外保存。
函数<code>writeLines(lines, con="outfilename.txt")</code>可以将字符型向量<code>lines</code>的各个元素变成输出文件的各行保存起来，
自动添加分隔行的换行符。
如果是分批读入分批处理的，
则写入也需要分批写入，
以上的分批处理程序变成：</p>
<div class="sourceCode" id="cb2858"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2858-1"><a href="text.html#cb2858-1"></a>infcon &lt;-<span class="st"> </span><span class="kw">file</span>(<span class="st">&quot;filename.ext&quot;</span>, <span class="dt">open=</span><span class="st">&quot;rt&quot;</span>)</span>
<span id="cb2858-2"><a href="text.html#cb2858-2"></a>outfcon &lt;-<span class="st"> </span><span class="kw">file</span>(<span class="st">&quot;outfilename.txt&quot;</span>, <span class="dt">open=</span><span class="st">&quot;wt&quot;</span>)</span>
<span id="cb2858-3"><a href="text.html#cb2858-3"></a>batch &lt;-<span class="st"> </span><span class="dv">1000</span></span>
<span id="cb2858-4"><a href="text.html#cb2858-4"></a><span class="cf">while</span>(<span class="ot">TRUE</span>){</span>
<span id="cb2858-5"><a href="text.html#cb2858-5"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(infcon, <span class="dt">n=</span>batch)</span>
<span id="cb2858-6"><a href="text.html#cb2858-6"></a>  <span class="cf">if</span>(<span class="kw">length</span>(lines)<span class="op">==</span><span class="dv">0</span>) <span class="cf">break</span></span>
<span id="cb2858-7"><a href="text.html#cb2858-7"></a>  <span class="co">## 处理读入的这些行, 变换成outlines</span></span>
<span id="cb2858-8"><a href="text.html#cb2858-8"></a>  <span class="kw">writeLines</span>(outlines, <span class="dt">con=</span>outfcon)</span>
<span id="cb2858-9"><a href="text.html#cb2858-9"></a>}</span>
<span id="cb2858-10"><a href="text.html#cb2858-10"></a><span class="kw">close</span>(outfcon)</span>
<span id="cb2858-11"><a href="text.html#cb2858-11"></a><span class="kw">close</span>(infcon)</span></code></pre></div>
<p><code>readLines()</code>也可以直接读取网站的网页文件，
如</p>
<div class="sourceCode" id="cb2859"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2859-1"><a href="text.html#cb2859-1"></a>lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="kw">url</span>(<span class="st">&quot;https://www.r-project.org/&quot;</span>))</span>
<span id="cb2859-2"><a href="text.html#cb2859-2"></a><span class="kw">length</span>(lines)</span>
<span id="cb2859-3"><a href="text.html#cb2859-3"></a><span class="co">## [1] 116</span></span>
<span id="cb2859-4"><a href="text.html#cb2859-4"></a><span class="kw">head</span>(lines)</span>
<span id="cb2859-5"><a href="text.html#cb2859-5"></a><span class="co">## [1] &quot;&lt;!DOCTYPE html&gt;&quot;                                                             </span></span>
<span id="cb2859-6"><a href="text.html#cb2859-6"></a><span class="co">## [2] &quot;&lt;html lang=\&quot;en\&quot;&gt;&quot;                                                          </span></span>
<span id="cb2859-7"><a href="text.html#cb2859-7"></a><span class="co">## [3] &quot;  &lt;head&gt;&quot;                                                                    </span></span>
<span id="cb2859-8"><a href="text.html#cb2859-8"></a><span class="co">## [4] &quot;    &lt;meta charset=\&quot;utf-8\&quot;&gt;&quot;                                                </span></span>
<span id="cb2859-9"><a href="text.html#cb2859-9"></a><span class="co">## [5] &quot;    &lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;IE=edge\&quot;&gt;&quot;               </span></span>
<span id="cb2859-10"><a href="text.html#cb2859-10"></a><span class="co">## [6] &quot;    &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1\&quot;&gt;&quot;</span></span></code></pre></div>
<p>readr包的<code>read_lines()</code>和<code>write_lines()</code>函数起到与基本R中
<code>readLines()</code>和<code>writeLines()</code>类似的作用，
<code>read_file()</code>和<code>read_file_raw()</code>可以将整个文件读入为一个字符串。</p>
<p>关于读写文件时的编码问题，
详见<a href="prog-io.html#p-io-enc">15.5</a>。</p>
</div>
<div id="text-regex" class="section level2">
<h2><span class="header-section-number">36.3</span> 正则表达式</h2>
<p>在对字符串进行查找或替换时，
有时要查找替换的不是固定的子串而是某种模式。
比如，要查找或替换连续的三个数字，正文中的电子邮件地址，
网址，电话号码，等等。
正则表达式(regular expressions)用于表示各种复杂模式。
基本R中的正则表达式规则可以用POSIX 1003.2标准或者Perl规则。
建议使用perl语言的正则表达式，
在基本R的有关函数中规定参数<code>perl=TRUE</code>。</p>
<p>stringr包提供了更方便的正则表达式功能，
其正则表达式规则是ICU正则表达式规则，
针对UTF-8编码的文本数据，
基本与perl规则兼容。</p>
<p>在正则表达式的模式(pattern)中，</p>
<pre><code>.*+?{}\[]^$()</code></pre>
<p>等字符是特殊字符，有特殊的解释。
除了<code>\</code>之外的其它12个都称为“<strong>元字符</strong>”（meta characters）。</p>
<p>在R语言中使用正则表达式时，
需要注意R字符型常量中一个<code>\</code>要写成两个。</p>
<div id="text-regex-strview" class="section level3">
<h3><span class="header-section-number">36.3.1</span> 字面匹配与匹配显示</h3>
<p>如果模式中不含特殊字符，匹配为原样的子串。也叫做字面(literal)匹配。
stringr包提供了定义正则表达式、匹配正则表达式、按正则表达式替换、抽取匹配结果、用富文本显示匹配结果等强大功能，
其中<code>str_view()</code>函数可以在HTML输出中或者在RStudio软件中用富文本显示匹配结果，
在源数据中加亮显示匹配。
注意，
如果你现在看的是PDF文件，
结果可能无法显示。</p>
<p>在使用rmarkdown、bookdown创作文章和书籍时，
因为同一源文件需要能同时支持HTML、LaTeX转换PDF，
但<code>str_view()</code>等函数仅支持HTML，
所以需要进行设置。
可以在Rmd源文件开头运行命令：</p>
<div class="sourceCode" id="cb2861"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2861-1"><a href="text.html#cb2861-1"></a>is_html &lt;-<span class="st"> </span>knitr<span class="op">::</span>opts_knit<span class="op">$</span><span class="kw">get</span>(<span class="st">&quot;rmarkdown.pandoc.to&quot;</span>) <span class="op">==</span><span class="st"> &quot;html&quot;</span></span></code></pre></div>
<p>这可以定义一个变量<code>is_html</code>，
仅在输出格式为HTML时才为<code>TRUE</code>，
然后在包含特殊HTML显示的代码段选项中，
加选项<code>eval = is_html</code>。</p>
<p>下面的程序在字符型向量<code>x</code>的三个字符串元素中原因查找子字符串<code>"the"</code>并加亮显示：</p>
<div class="sourceCode" id="cb2862"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2862-1"><a href="text.html#cb2862-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2862-2"><a href="text.html#cb2862-2"></a><span class="kw">str_view</span>(x, <span class="st">&quot;the&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-f0e357faf4233c99011a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f0e357faf4233c99011a">{"x":{"html":"<ul>\n  <li>New <span class='match'>the<\/span>me<\/li>\n  <li>Old times<\/li>\n  <li>In <span class='match'>the<\/span> present theme<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>在RStudio中会在Viewer窗格显示匹配结果，
匹配内容被高亮显示。</p>
<p>源数据中的第三项实际上有两处<code>"the"</code>出现但结果只显示了第一处。
用<code>str_view_all()</code>查看所有匹配，如：</p>
<div class="sourceCode" id="cb2863"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2863-1"><a href="text.html#cb2863-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2863-2"><a href="text.html#cb2863-2"></a><span class="kw">str_view_all</span>(x, <span class="st">&quot;the&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-35e0862ab96b8a522a85" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-35e0862ab96b8a522a85">{"x":{"html":"<ul>\n  <li>New <span class='match'>the<\/span>me<\/li>\n  <li>Old times<\/li>\n  <li>In <span class='match'>the<\/span> present <span class='match'>the<\/span>me<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-ignore" class="section level3">
<h3><span class="header-section-number">36.3.2</span> 不区分大小写匹配和<code>regex</code>函数</h3>
<p><code>str_view(string, pattern)</code>中的<code>pattern</code>应该为正则表达式类型，
如果输入了字符串，
会自动被函数<code>regex()</code>转换成正则表达式类型。
正则表达式的模式一般是区分大小写的，
通过在<code>regex()</code>函数中加选项<code>ignore_case=TRUE</code>可以进行不区分大小写的匹配；
在模式前面附加<code>(?i)</code>前缀式选项也可以实现不区分大小写匹配。
如</p>
<div class="sourceCode" id="cb2864"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2864-1"><a href="text.html#cb2864-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>), <span class="st">&quot;Dr&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-60d24ce22fb85f2e5002" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-60d24ce22fb85f2e5002">{"x":{"html":"<ul>\n  <li><span class='match'>Dr<\/span>. Wang<\/li>\n  <li>DR. WANG<\/li>\n  <li>dR. W.R.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2865"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2865-1"><a href="text.html#cb2865-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>), </span>
<span id="cb2865-2"><a href="text.html#cb2865-2"></a>             <span class="kw">regex</span>(<span class="st">&quot;Dr&quot;</span>, <span class="dt">ignore_case=</span><span class="ot">TRUE</span>))</span></code></pre></div>
<div id="htmlwidget-91ae02d8e93d6ab87671" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-91ae02d8e93d6ab87671">{"x":{"html":"<ul>\n  <li><span class='match'>Dr<\/span>. Wang<\/li>\n  <li><span class='match'>DR<\/span>. WANG<\/li>\n  <li><span class='match'>dR<\/span>. W.R.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2866"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2866-1"><a href="text.html#cb2866-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>), <span class="st">&quot;(?i)Dr&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-2bdaf046460d6d1092bf" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-2bdaf046460d6d1092bf">{"x":{"html":"<ul>\n  <li><span class='match'>Dr<\/span>. Wang<\/li>\n  <li><span class='match'>DR<\/span>. WANG<\/li>\n  <li><span class='match'>dR<\/span>. W.R.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-dot" class="section level3">
<h3><span class="header-section-number">36.3.3</span> 用句点匹配单个字符</h3>
<p>在模式中用“.”匹配任意一个字符（除了换行符<code>"\n"</code>，能否匹配此字符与选项有关）。
如</p>
<div class="sourceCode" id="cb2867"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2867-1"><a href="text.html#cb2867-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;cabs&quot;</span>, <span class="st">&quot;lab&quot;</span>)</span>
<span id="cb2867-2"><a href="text.html#cb2867-2"></a><span class="kw">str_view_all</span>(s, <span class="st">&quot;ab.&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-799f882c69a288c0e080" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-799f882c69a288c0e080">{"x":{"html":"<ul>\n  <li><span class='match'>abc<\/span><\/li>\n  <li>c<span class='match'>abs<\/span><\/li>\n  <li>lab<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>像句点这样的字符称为<strong>元字符</strong>（meta characters），
在正则表达式中有特殊作用。
如果需要匹配句点本身，用“<code>[.]</code>”或者“<code>\.</code>”表示。
比如，要匹配<code>a.txt</code>这个文件名，如下做法有错误：</p>
<div class="sourceCode" id="cb2868"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2868-1"><a href="text.html#cb2868-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="st">&quot;a.txt&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-c2c55c32fde79a0074be" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-c2c55c32fde79a0074be">{"x":{"html":"<ul>\n  <li><span class='match'>a.txt<\/span><\/li>\n  <li><span class='match'>a0txt<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
结果连<code>a0txt</code>也匹配了。用“[.]”表示句点则将句点不做特殊解释：</p>
<div class="sourceCode" id="cb2869"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2869-1"><a href="text.html#cb2869-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="st">&quot;a[.]txt&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-98556755820a06332800" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-98556755820a06332800">{"x":{"html":"<ul>\n  <li><span class='match'>a.txt<\/span><\/li>\n  <li>a0txt<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2870"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2870-1"><a href="text.html#cb2870-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="st">&quot;a</span><span class="ch">\\</span><span class="st">.txt&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-beba53c89bc66b0d1e31" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-beba53c89bc66b0d1e31">{"x":{"html":"<ul>\n  <li><span class='match'>a.txt<\/span><\/li>\n  <li>a0txt<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
注意在R语言字符型常量中一个<code>\</code>需要写成两个。</p>
<p>如果仅需按照原样进行查找，
也可以将<code>pattern</code>的字符串用<code>fixed()</code>函数保护，如：
如</p>
<div class="sourceCode" id="cb2871"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2871-1"><a href="text.html#cb2871-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="kw">fixed</span>(<span class="st">&quot;a.txt&quot;</span>))</span></code></pre></div>
<div id="htmlwidget-cd8966110a95a538f2e8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-cd8966110a95a538f2e8">{"x":{"html":"<ul>\n  <li><span class='match'>a.txt<\/span><\/li>\n  <li>a0txt<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-set" class="section level3">
<h3><span class="header-section-number">36.3.4</span> 匹配一组字符中的某一个</h3>
<p>模式中使用方括号给定一个字符类，
单个字符与字符类中任何一个字符相同都算是匹配成功。
比如，模式“<code>[ns]a.[.]xls</code>” 表示匹配的第一个字符是<code>n</code>或<code>s</code>，
第二个字符是<code>a</code>，第三个字符任意，第四个字符是句点，
然后是<code>xls</code>。
测试：</p>
<div class="sourceCode" id="cb2872"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2872-1"><a href="text.html#cb2872-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;sa1.xls&quot;</span>, <span class="st">&quot;dna2.xlss&quot;</span>, <span class="st">&quot;nat.xls&quot;</span>), <span class="st">&quot;[ns]a.[.]xls&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-6232a332e218fbd44f1e" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6232a332e218fbd44f1e">{"x":{"html":"<ul>\n  <li><span class='match'>sa1.xls<\/span><\/li>\n  <li>d<span class='match'>na2.xls<\/span>s<\/li>\n  <li><span class='match'>nat.xls<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>注意匹配并不需要从开头匹配到结尾，
中间匹配是允许的，类似于搜索符合某种规律的子串。
在上例中第二个元素是从第二个字符开始匹配的，也没有匹配到末尾。</p>
<p>例：模式<code>[Rr]eg[Ee]x</code>可以匹配<code>RegEx</code>或<code>Regex</code>或 <code>regex</code>或<code>regEx</code>。</p>
<p>如果希望完全忽略大小写进行匹配，
可以使用在<code>regex()</code>等函数中指定<code>ignore_case=TRUE</code>选项，
或在模式字符串的最前面添加<code>(?i)</code>选项。</p>
<p>在“<code>[]</code>”中允许用<code>-</code>表示一个范围。
如<code>[a-z]</code>匹配小写英文字母,
<code>[A-Z]</code>匹配大写英文字母,
<code>[a-zA-Z]</code>匹配大小写的英文字母,
<code>[a-zA-Z0-9]</code>匹配大小写的英文字母和数字。</p>
<p>为了匹配一个16进制数字，
可以用<code>[0-9A-Fa-f]</code>。</p>
<p>例：模式“<code>[ns]a[0-9][.]xls</code>”要求匹配的第三个字符为数字。</p>
<div class="sourceCode" id="cb2873"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2873-1"><a href="text.html#cb2873-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;sa1.xls&quot;</span>, <span class="st">&quot;dna2.xlss&quot;</span>, <span class="st">&quot;nat.xls&quot;</span>), <span class="st">&quot;[ns]a[0-9][.]xls&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-22676f2b22413b438639" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-22676f2b22413b438639">{"x":{"html":"<ul>\n  <li><span class='match'>sa1.xls<\/span><\/li>\n  <li>d<span class='match'>na2.xls<\/span>s<\/li>\n  <li>nat.xls<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>在方括号内第一个位置的<code>^</code>表示对指定的范围取余集。
例如，模式<code>[ns]a[^0-9][.]xls</code>要求匹配的第三个字符不能为数字:</p>
<div class="sourceCode" id="cb2874"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2874-1"><a href="text.html#cb2874-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;sa1.xls&quot;</span>, <span class="st">&quot;dna2.xlss&quot;</span>, <span class="st">&quot;nat.xls&quot;</span>), <span class="st">&quot;[ns]a[^0-9][.]xls&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-3c149761d01f93d2a417" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-3c149761d01f93d2a417">{"x":{"html":"<ul>\n  <li>sa1.xls<\/li>\n  <li>dna2.xlss<\/li>\n  <li><span class='match'>nat.xls<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-metalit" class="section level3">
<h3><span class="header-section-number">36.3.5</span> 原样匹配元字符</h3>
<p>元字符(meta characters)是在正则表达式中有特殊含义的字符。
比如句点可以匹配任意一个字符, 左方括号代表字符集合的开始。
所以元字符不能直接匹配自身， 可以用“<code>[.]</code>”匹配一个句点。
为匹配左方括号，在前面加上转义字符<code>\</code>变成<code>\[</code>，
但是在R字符串中一个<code>\</code>必须用<code>\\</code>表示，
所以模式“<code>\[</code>”在R中写成字符串常量，
必须写成<code>"\\["</code>。
其它的元字符如果要原样匹配也可以在前面加上转义字符<code>\</code>，
比如匹配<code>\</code>本身可以用<code>\\</code>，但是在R字符型常量中需要写成<code>"\\\\"</code>。</p>
<p>例，匹配<code>x[5]</code>，因为<code>[</code>是元字符，需要写成：</p>
<div class="sourceCode" id="cb2875"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2875-1"><a href="text.html#cb2875-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;int x;&quot;</span>, <span class="st">&quot;int x[5]&quot;</span>), <span class="st">&quot;int x</span><span class="ch">\\</span><span class="st">[5</span><span class="ch">\\</span><span class="st">]&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-4f7cb7dff8b37e4101c5" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-4f7cb7dff8b37e4101c5">{"x":{"html":"<ul>\n  <li>int x;<\/li>\n  <li><span class='match'>int x[5]<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>Perl中允许用“<code>[[]</code>”表示“<code>[</code>”， 用“<code>[]]</code>”表示“<code>]</code>”，
但stringr包不支持这种做法。</p>
</div>
<div id="text-regex-space" class="section level3">
<h3><span class="header-section-number">36.3.6</span> 匹配空白</h3>
<p>表示空白的元字符有:</p>
<pre><code>\f 换页符
\n 换行符
\r 回车符
\t 制表符
\v 垂直制表符</code></pre>
<p>不同操作系统的文本文件的行分隔符不同，
为了匹配Windows格式的文本文件中的空行，
用“<code>\r\n\r\n</code>”；
为了匹配Unix格式的文本文件中的空行则用“<code>\r\r</code>”。
写成R的字符型常量时，
这些表示本身也是R的相应字符的表示，
所以在R字符型常量中这些字符不需要用两个<code>\</code>表示一个<code>\</code>。</p>
<p>匹配任意一个空白字符用“<code>\s</code>”，
这等价于“<code>[ \f\n\r\t\v]</code>”。
大写的“<code>\S</code>”则匹配任意一个非空白的字符。</p>
</div>
<div id="text-regex-digit" class="section level3">
<h3><span class="header-section-number">36.3.7</span> 匹配数字</h3>
<p>用<code>\d</code>匹配一个数字，相当于<code>[0-9]</code>。
用<code>\D</code>匹配一个非数字。
如</p>
<div class="sourceCode" id="cb2877"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2877-1"><a href="text.html#cb2877-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>), <span class="st">&quot;n</span><span class="ch">\\</span><span class="st">d[.]xls&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-6980d93103e952aff284" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6980d93103e952aff284">{"x":{"html":"<ul>\n  <li><span class='match'>n1.xls<\/span><\/li>\n  <li>na.xls<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-alnum" class="section level3">
<h3><span class="header-section-number">36.3.8</span> 匹配字母、数字、下划线</h3>
<p>匹配字母、数字、下划线字符用<code>\w</code>（小写），
等价于<code>[a-zA-Z0-9_]</code>。
<code>\W</code>（大写）匹配这些字符以外的字符。
如</p>
<div class="sourceCode" id="cb2878"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2878-1"><a href="text.html#cb2878-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;file-s1.xls&quot;</span>, <span class="st">&quot;s#.xls&quot;</span>), <span class="st">&quot;s</span><span class="ch">\\</span><span class="st">w[.]&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-32ff6af0ce0a67b727f9" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-32ff6af0ce0a67b727f9">{"x":{"html":"<ul>\n  <li>file-<span class='match'>s1.<\/span>xls<\/li>\n  <li>s#.xls<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
可以看出，模式匹配了<code>s1.</code>而没有匹配<code>s#.</code>。</p>
</div>
<div id="text-regex-hex" class="section level3">
<h3><span class="header-section-number">36.3.9</span> 十六进制和八进制数</h3>
<p>在模式中可以用十六进制数和八进制数表示特殊的字符。
十六进制数用<code>\X</code>引入， 比如<code>\X0A</code>对应<code>\n</code>字符。
八进制数用<code>\0</code>引入， 比如<code>\011</code>表示<code>\t</code>字符。</p>
<p>例如，<code>str_view_all("abc\nefg\n", "\\x0A")</code>可以匹配两个换行符。</p>
</div>
<div id="text-regex-posix" class="section level3">
<h3><span class="header-section-number">36.3.10</span> POSIX字符类</h3>
<p><code>\d</code>, <code>\w</code>这样的字符类不方便用在方括号中组成字符集合，
而且也不容易记忆和认读。
在模式中方括号内可以用<code>[:alpha:]</code> 表示任意一个字母。
比如，<code>[[:alpha:]]</code>匹配任意一个字母（外层的方括号表示字符集合，
内层的方括号是POSIX字符类的固有界定符）。</p>
<p>这样的POSIX字符类有：</p>
<ul>
<li><code>[:alpha:]</code>表示任意一个字母；</li>
<li><code>[:lower:]</code>为小写字母；</li>
<li><code>[:upper:]</code>为大写字母；</li>
<li><code>[:digit:]</code>为数字；</li>
<li><code>[:xdigit:]</code>为十六进制数字。</li>
<li><code>[:alnum:]</code>为字母数字(不包括下划线)；</li>
<li><code>[:blank:]</code>为空格或制表符；</li>
<li><code>[:space:]</code>为任何一种空白字符，包括空格、制表符、换页符、换行符、回车符；</li>
<li><code>[:print:]</code>为可打印字符；</li>
<li><code>[:graph:]</code>和<code>[:print:]</code>一样但不包括空格；</li>
<li><code>[:punct:]</code>为<code>[:print:]</code>中除<code>[:alnum:]</code>和空白以外的所有字符；</li>
</ul>
<p>例如：</p>
<div class="sourceCode" id="cb2879"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2879-1"><a href="text.html#cb2879-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;x1&quot;</span>, <span class="st">&quot;_x&quot;</span>, <span class="st">&quot;.x&quot;</span>, <span class="st">&quot;.1&quot;</span>), <span class="st">&quot;[[:alpha:]_.][[:alnum:]_.]&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-d40fee2c152347bab468" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-d40fee2c152347bab468">{"x":{"html":"<ul>\n  <li><span class='match'>x1<\/span><\/li>\n  <li><span class='match'>_x<\/span><\/li>\n  <li><span class='match'>.x<\/span><\/li>\n  <li><span class='match'>.1<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
模式匹配长度为2的字符串，
第一个字符是字母、下划线或者小数点，
第二个字符是字母、数字、下划线或者小数点。
这个模式试图匹配由两个字符组成的合法R变量名，
但是最后一个非变量名<code>.1</code>也被匹配了。
解决这样的问题可以采用后面讲到的<code>|</code>备择模式。</p>
</div>
<div id="text-regex-start" class="section level3">
<h3><span class="header-section-number">36.3.11</span> 匹配开头和末尾</h3>
<p>模式匹配相当于在字符串内部搜索某种模式，
如果要从字符串开头匹配，
在模式中取第一个模式规定为<code>^</code>或<code>\A</code>。
如果模式中最后一个字符是<code>$</code>或<code>\Z</code>，
则需要匹配到字符串末尾。
用<code>\Z</code>匹配字符串末尾时如果末尾有一个换行符则匹配到换行符之前。</p>
<p>如</p>
<div class="sourceCode" id="cb2880"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2880-1"><a href="text.html#cb2880-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>, <span class="st">&quot;cn1.xls&quot;</span>, <span class="st">&quot;n1.xlsx&quot;</span>), <span class="st">&quot;^n</span><span class="ch">\\</span><span class="st">d[.]xls$&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-1046b0b86a1d3d373cc7" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-1046b0b86a1d3d373cc7">{"x":{"html":"<ul>\n  <li><span class='match'>n1.xls<\/span><\/li>\n  <li>na.xls<\/li>\n  <li>cn1.xls<\/li>\n  <li>n1.xlsx<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2881"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2881-1"><a href="text.html#cb2881-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>, <span class="st">&quot;cn1.xls&quot;</span>, <span class="st">&quot;n1.xlsx&quot;</span>), <span class="st">&quot;</span><span class="ch">\\</span><span class="st">An</span><span class="ch">\\</span><span class="st">d[.]xls</span><span class="ch">\\</span><span class="st">Z&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-c05ae12bcc222c007efe" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-c05ae12bcc222c007efe">{"x":{"html":"<ul>\n  <li><span class='match'>n1.xls<\/span><\/li>\n  <li>na.xls<\/li>\n  <li>cn1.xls<\/li>\n  <li>n1.xlsx<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
只匹配了第一个输入字符串。</p>
<p>有时候源文本的每个字符串保存了一个文本文件内容，
各行用<code>\n</code>分隔，
后面将给出匹配每行的行首与行尾的方法。</p>
</div>
<div id="text-regex-wordb" class="section level3">
<h3><span class="header-section-number">36.3.12</span> 单词边界</h3>
<p>用<code>\b</code>匹配单词边界，
这样可以查找作为单词而不是单词的一部分存在的内容。
<code>\B</code>匹配非单词边界。
如</p>
<div class="sourceCode" id="cb2882"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2882-1"><a href="text.html#cb2882-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;a cat meaos&quot;</span>, <span class="st">&quot;the category&quot;</span>), <span class="st">&quot;</span><span class="ch">\\</span><span class="st">bcat</span><span class="ch">\\</span><span class="st">b&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-46b0468019ee8043e709" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-46b0468019ee8043e709">{"x":{"html":"<ul>\n  <li>a <span class='match'>cat<\/span> meaos<\/li>\n  <li>the category<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-repeat" class="section level3">
<h3><span class="header-section-number">36.3.13</span> 重复匹配</h3>
<div id="text-regex-repeat-plus" class="section level4">
<h4><span class="header-section-number">36.3.13.1</span> 加号重复匹配</h4>
<p>模式中在一个字符或字符集合后加后缀<code>+</code>表示一个或多个前一字符。
比如</p>
<div class="sourceCode" id="cb2883"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2883-1"><a href="text.html#cb2883-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;sa1&quot;</span>, <span class="st">&quot;dsa123&quot;</span>), <span class="st">&quot;sa[[:digit:]]+&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-d45117115c360d8252d0" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-d45117115c360d8252d0">{"x":{"html":"<ul>\n  <li><span class='match'>sa1<\/span><\/li>\n  <li>d<span class='match'>sa123<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>例如，匹配电子邮件地址：</p>
<div class="sourceCode" id="cb2884"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2884-1"><a href="text.html#cb2884-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;abc123@efg.com&quot;</span>, </span>
<span id="cb2884-2"><a href="text.html#cb2884-2"></a>             <span class="st">&quot;^[[:alnum:]_]+@[[:alnum:]_]+[.][[:alnum:]_]+$&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-ab48c46a243015de227c" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ab48c46a243015de227c">{"x":{"html":"<ul>\n  <li><span class='match'>abc123@efg.com<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
匹配的电子邮件地址在<code>@</code>前面可以使用任意多个字母、数字、下划线，
在<code>@</code>后面由小数点分成两段，
每段可以使用任意多个字母、数字、下划线。
这里用了<code>^</code>和<code>$</code>表示全字符串匹配。</p>
</div>
<div id="text-regex-repeat-ast" class="section level4">
<h4><span class="header-section-number">36.3.13.2</span> 星号和问号重复匹配</h4>
<p>在一个字符或字符集合后加后缀<code>*</code>表示零个或多个前一字符，
后缀<code>?</code>表示零个或一个前一字符。</p>
<p>比如，
<code>^https?://[[:alnum:]./]+$</code>可以匹配http或https开始的网址。
如</p>
<div class="sourceCode" id="cb2885"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2885-1"><a href="text.html#cb2885-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;http://www.163.net&quot;</span>, <span class="st">&quot;https://123.456.&quot;</span>),</span>
<span id="cb2885-2"><a href="text.html#cb2885-2"></a>             <span class="st">&quot;^https?://[[:alnum:]_./]+$&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-708a3c0f8aceca177e68" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-708a3c0f8aceca177e68">{"x":{"html":"<ul>\n  <li><span class='match'>http://www.163.net<\/span><\/li>\n  <li><span class='match'>https://123.456.<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
(注意第二个字符串不是合法网址但是按这个正则表达式也能匹配)</p>
<p><code>x[[:digit:]]*</code>能匹配“x”, “x1”, “x123”这样的变量名，如：</p>
<div class="sourceCode" id="cb2886"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2886-1"><a href="text.html#cb2886-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;x1&quot;</span>, <span class="st">&quot;x123&quot;</span>), <span class="st">&quot;x[[:digit:]]*&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-6f55301478f27e1ca008" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6f55301478f27e1ca008">{"x":{"html":"<ul>\n  <li><span class='match'>x<\/span><\/li>\n  <li><span class='match'>x1<\/span><\/li>\n  <li><span class='match'>x123<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2887"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2887-1"><a href="text.html#cb2887-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;x&quot;</span>, <span class="st">&quot;x1&quot;</span>, <span class="st">&quot;x123&quot;</span>), <span class="st">&quot;x</span><span class="ch">\\</span><span class="st">d*&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-0bda53b514f72872fd66" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-0bda53b514f72872fd66">{"x":{"html":"<ul>\n  <li><span class='match'>x<\/span><\/li>\n  <li><span class='match'>x1<\/span><\/li>\n  <li><span class='match'>x123<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-repeat-repnum" class="section level4">
<h4><span class="header-section-number">36.3.13.3</span> 计数重复</h4>
<p>问号可以表示零个或一个，
而加号、星号重复不能控制重复次数。
在后缀大括号中写一个整数表示精确的重复次数。
如</p>
<div class="sourceCode" id="cb2888"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2888-1"><a href="text.html#cb2888-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;12&quot;</span>, <span class="st">&quot;123&quot;</span>, <span class="st">&quot;1234&quot;</span>), <span class="st">&quot;[[:digit:]]{3}&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-b96fea3808ef69fc1b29" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-b96fea3808ef69fc1b29">{"x":{"html":"<ul>\n  <li>1<\/li>\n  <li>12<\/li>\n  <li><span class='match'>123<\/span><\/li>\n  <li><span class='match'>123<\/span>4<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
模式匹配的是三位的数字。
因为没有要求从开头一直匹配到末尾，
所以三位以上数字也能匹配其中开始的三位。</p>
<p>可以在后缀大括号中指定重复的最小和最大次数，
中间用逗号分隔。
比如，
月日年的日期格式可以用</p>
<pre><code>[[:digit:]]{1,2}[-/][[:digit:]]{1,2}[-/][[:digit:]]{2,4}</code></pre>
<p>来匹配。
如 (注意这个模式还会匹配非日期)</p>
<div class="sourceCode" id="cb2890"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2890-1"><a href="text.html#cb2890-1"></a>pat &lt;-<span class="st"> </span><span class="kw">paste0</span>(</span>
<span id="cb2890-2"><a href="text.html#cb2890-2"></a>  <span class="st">&quot;[[:digit:]]{1,2}[-/]&quot;</span>,</span>
<span id="cb2890-3"><a href="text.html#cb2890-3"></a>  <span class="st">&quot;[[:digit:]]{1,2}[-/]&quot;</span>,</span>
<span id="cb2890-4"><a href="text.html#cb2890-4"></a>  <span class="st">&quot;[[:digit:]]{2,4}&quot;</span>)</span>
<span id="cb2890-5"><a href="text.html#cb2890-5"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;2/4/1998&quot;</span>, <span class="st">&quot;13/15/198&quot;</span>), pat)</span></code></pre></div>
<div id="htmlwidget-10e14d2a4f732ac8f4bd" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-10e14d2a4f732ac8f4bd">{"x":{"html":"<ul>\n  <li><span class='match'>2/4/1998<\/span><\/li>\n  <li><span class='match'>13/15/198<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>重复数允许指定为0。
重复数的逗号后面空置表示重复数没有上限。
例如，后缀<code>{3,}</code>表示前一模式必须至少重复3次。</p>
</div>
</div>
<div id="text-regex-lazy" class="section level3">
<h3><span class="header-section-number">36.3.14</span> 贪婪匹配和懒惰匹配</h3>
<p>无上限的重复匹配如<code>*</code>, <code>+</code>, <code>{3,}</code>等缺省是贪婪型的，
重复直到文本中能匹配的最长范围。
比如我们希望找出圆括号这样的结构，
很容易想到用<code>\(.+\)</code>这样的模式（注意圆括号是元字符，需要用反斜杠保护），
但是这不会恰好匹配一次，
模式会一直搜索到最后一个<code>)</code>为止。</p>
<p>例如：</p>
<div class="sourceCode" id="cb2891"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2891-1"><a href="text.html#cb2891-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1st) other (2nd)&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">(.+</span><span class="ch">\\</span><span class="st">)&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-51d48bc409569421fec1" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-51d48bc409569421fec1">{"x":{"html":"<ul>\n  <li><span class='match'>(1st) other (2nd)<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
我们本来期望的是提取两个“(1st)”和“(2nd)”组合，
不料整个地提取了“<code>(1st) other (2nd)</code>”。
这就是因为<code>.+</code>的贪婪匹配。</p>
<p>如果要求尽可能短的匹配，
使用<code>*?</code>, <code>+?</code>, <code>{3,}?</code>等“懒惰型”重复模式。
在无上限重复标志后面加问号表示懒惰性重复。</p>
<p>比如，上例中模式修改后得到了期望的结果：</p>
<div class="sourceCode" id="cb2892"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2892-1"><a href="text.html#cb2892-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1st) other (2nd)&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-b8161a51d711f03b4827" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-b8161a51d711f03b4827">{"x":{"html":"<ul>\n  <li><span class='match'>(1st)<\/span> other <span class='match'>(2nd)<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>懒惰匹配会造成搜索效率降低，
应仅在需要的时候使用。</p>
</div>
<div id="text-regex-smlines" class="section level3">
<h3><span class="header-section-number">36.3.15</span> 句点全匹配与多行模式</h3>
<p>句点通配符一般不能匹配换行，如</p>
<div class="sourceCode" id="cb2893"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2893-1"><a href="text.html#cb2893-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,</span><span class="ch">\n</span><span class="st">2)&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-60708cb494b3f26b5dde" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-60708cb494b3f26b5dde">{"x":{"html":"<ul>\n  <li>(1,\n2)<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
跨行匹配失败。
一种办法是预先用<code>str_replace_all()</code>或<code>gsub()</code>把所有换行符替换为空格。
但是这只能解决部分问题。</p>
<p>解决方法是在将模式用<code>regex()</code>保护并加选项<code>dotall=TRUE</code>，
或者在Perl正则表达式开头添加<code>(?s)</code>选项，
这样使得句点通配符可以匹配换行符，
称为句点全匹配模式。
如</p>
<div class="sourceCode" id="cb2894"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2894-1"><a href="text.html#cb2894-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,</span><span class="ch">\n</span><span class="st">2)&quot;</span>, <span class="kw">regex</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)&quot;</span>, <span class="dt">dotall=</span><span class="ot">TRUE</span>))</span></code></pre></div>
<div id="htmlwidget-e9eb872d988f51f20f0e" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-e9eb872d988f51f20f0e">{"x":{"html":"<ul>\n  <li><span class='match'>(1,\n2)<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2895"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2895-1"><a href="text.html#cb2895-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,</span><span class="ch">\n</span><span class="st">2)&quot;</span>, <span class="st">&quot;(?s)</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-5389f34eb0de01dbb311" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-5389f34eb0de01dbb311">{"x":{"html":"<ul>\n  <li><span class='match'>(1,\n2)<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>在<code>regex()</code>函数中加选项<code>multiline=TRUE</code>，
或者在正则表达式开头用<code>(?m)</code>表示把整个输入字符串看成用换行符分开的多行。
这时<code>^</code>和<code>$</code>匹配每行的开头和结尾，
“每行”是指字符串中用换行符分开的各个字符子串。
<code>(?s)</code>与<code>(?m)</code>可以同时使用。</p>
<p>例：</p>
<div class="sourceCode" id="cb2896"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2896-1"><a href="text.html#cb2896-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,2)</span><span class="ch">\n</span><span class="st">(3,4)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;^</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)$&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-6cf7ae0250d66611693c" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-6cf7ae0250d66611693c">{"x":{"html":"<ul>\n  <li>(1,2)\n(3,4)\n<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
元数据中包含两行内容，
结果没有能够匹配，
这是因为模式要求从整个字符串开头一直匹配到末尾。
增加<code>multiline=TRUE</code>或者<code>(?m)</code>选项则可以匹配两处：</p>
<div class="sourceCode" id="cb2897"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2897-1"><a href="text.html#cb2897-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,2)</span><span class="ch">\n</span><span class="st">(3,4)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="kw">regex</span>(<span class="st">&quot;^</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)$&quot;</span>, <span class="dt">multiline=</span><span class="ot">TRUE</span>))</span></code></pre></div>
<div id="htmlwidget-4ab9fce6104478a599c8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-4ab9fce6104478a599c8">{"x":{"html":"<ul>\n  <li><span class='match'>(1,2)<\/span>\n<span class='match'>(3,4)<\/span>\n<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2898"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2898-1"><a href="text.html#cb2898-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;(1,2)</span><span class="ch">\n</span><span class="st">(3,4)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;(?m)^</span><span class="ch">\\</span><span class="st">(.+?</span><span class="ch">\\</span><span class="st">)$&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-57c619ac1609e7b241f9" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-57c619ac1609e7b241f9">{"x":{"html":"<ul>\n  <li><span class='match'>(1,2)<\/span>\n<span class='match'>(3,4)<\/span>\n<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div id="text-regex-perline" class="section level4">
<h4><span class="header-section-number">36.3.15.1</span> 逐行处理</h4>
<p>虽然正则表达式有多行和跨行选项，
但是当源数据很长时，
匹配效率会很低。</p>
<p>R的<code>readLines()</code>函数可以把一整个文本文件读成一个字符型向量，
每个元素为一行，
元素中不包含换行符。
R的字符型函数可以对这样的字符型向量每个元素同时处理，
也就实现了逐行处理。</p>
<p>如果字符串<code>x</code>中包含了一整个文本文件内容，
其中以<code>\n</code>分隔各行，
为了实现逐行处理，
可以先用<code>str_split()</code>函数拆分成不同行：</p>
<div class="sourceCode" id="cb2899"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2899-1"><a href="text.html#cb2899-1"></a>cl &lt;-<span class="st"> </span><span class="kw">strs_plit</span>(x, <span class="st">&quot;</span><span class="ch">\r</span><span class="st">?</span><span class="ch">\n</span><span class="st">&quot;</span>)[[<span class="dv">1</span>]]</span></code></pre></div>
<p>结果将是一个字符型向量，
每个元素是原来的一行，最后一个元素是空字符串。
如</p>
<div class="sourceCode" id="cb2900"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2900-1"><a href="text.html#cb2900-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;This is first line.</span><span class="ch">\n</span><span class="st">This is second line.</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb2900-2"><a href="text.html#cb2900-2"></a>cl &lt;-<span class="st"> </span><span class="kw">str_split</span>(x, <span class="st">&quot;</span><span class="ch">\r</span><span class="st">?</span><span class="ch">\n</span><span class="st">&quot;</span>)[[<span class="dv">1</span>]]</span>
<span id="cb2900-3"><a href="text.html#cb2900-3"></a>cl</span></code></pre></div>
<pre><code>## [1] &quot;This is first line.&quot;  &quot;This is second line.&quot; &quot;&quot;</code></pre>
</div>
</div>
<div id="text-regex-alt" class="section level3">
<h3><span class="header-section-number">36.3.16</span> 备择模式</h3>
<p>如果有两种模式都算正确匹配，则用<code>|</code>连接这两个模式表示两者都可以。
例如，某个人的名字用James和Jim都可以，
表示为<code>James|Jim</code>, 如</p>
<div class="sourceCode" id="cb2902"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2902-1"><a href="text.html#cb2902-1"></a><span class="kw">str_view</span>(<span class="kw">c</span>(<span class="st">&quot;James, Bond&quot;</span>, <span class="st">&quot;Jim boy&quot;</span>), <span class="st">&quot;James|Jim&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-f24c290fa167b47d90c4" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f24c290fa167b47d90c4">{"x":{"html":"<ul>\n  <li><span class='match'>James<\/span>, Bond<\/li>\n  <li><span class='match'>Jim<\/span> boy<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>两个字符的合法R变量名的匹配：</p>
<div class="sourceCode" id="cb2903"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2903-1"><a href="text.html#cb2903-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;x1&quot;</span>, <span class="st">&quot;_x&quot;</span>, <span class="st">&quot;.x&quot;</span>, <span class="st">&quot;.1&quot;</span>), </span>
<span id="cb2903-2"><a href="text.html#cb2903-2"></a>             <span class="st">&quot;[[:alpha:]_][[:alnum:]_.]|[.][[:alpha:]_]&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-cfded356a3505eb981ad" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-cfded356a3505eb981ad">{"x":{"html":"<ul>\n  <li><span class='match'>x1<\/span><\/li>\n  <li><span class='match'>_x<\/span><\/li>\n  <li><span class='match'>.x<\/span><\/li>\n  <li>.1<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
</div>
<div id="text-regex-group" class="section level3">
<h3><span class="header-section-number">36.3.17</span> 分组与捕获</h3>
<p>在正则表达式中用圆括号来分出组，
作用是</p>
<ul>
<li>确定优先规则</li>
<li>组成一个整体</li>
<li>拆分出模式中的部分内容（称为捕获）</li>
<li>定义一段供后续引用或者替换。</li>
</ul>
<p>圆括号中的模式称为<strong>子模式</strong>，或者<strong>捕获</strong>。</p>
<p>在使用备择模式时，<code>James|Jim</code>是在单词James和Jim之间选择。
如果希望选择的是中间的ms和Ji怎么办？
可以将备择模式保护起来， 如<code>Jam(es|Ji)m</code>，
就可以确定备择模式的作用范围。</p>
<p>有时一个模式中部分内容仅用于定位，
而实际有用的内容是其中的一部分，
就可以将这部分有用的内容包在圆括号中作为一个捕获。</p>
<p>元字符问号、加号、星号、大括号等表示重复，
前面的例子中都是重复一个字符或者字符类。
如果需要重复由多个字符组成的模式，
如<code>x[[:digit:]]{2}</code>怎么办？
只要将该模式写在括号中，如：</p>
<div class="sourceCode" id="cb2904"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2904-1"><a href="text.html#cb2904-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;x01x02&quot;</span>, <span class="st">&quot;_x11x9&quot;</span>), </span>
<span id="cb2904-2"><a href="text.html#cb2904-2"></a>             <span class="st">&quot;(x[[:digit:]]{2})+&quot;</span>)</span></code></pre></div>
<p><div id="htmlwidget-ddf491beb45e53f7f9ab" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-ddf491beb45e53f7f9ab">{"x":{"html":"<ul>\n  <li><span class='match'>x01x02<\/span><\/li>\n  <li>_<span class='match'>x11<\/span>x9<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
上例的元数据中，
第一个元素重复了两次括号中的模式，
第二个元素仅有一次括号中的模式。</p>
<p><strong>注意</strong>：
用表示重复的元字符重复某个模式时，
从第二次开始，
并不是要重复前面的子字符串，
而是重复前面的模式。
比如上例中<code>x01x02</code>。</p>
<p>如果想严格重复前面的某个子字符串怎么办？</p>
<p>分组是自动编号的，
以左开括号的序号为准（除了作为选项、有名捕获等开扩号以外）。
在替换或者向后引用时，
可以用<code>\1</code>，<code>\2</code>等表示匹配中第一个开括号对应的分组，
第二个开扩号对应的分组，……。</p>
<p>在模式中可以用<code>\1</code>, <code>\2</code>等表示严格重复前面捕获的子字符串。
例如，<code>([a-z]{3})\1</code>这样的模式可以匹配如<code>abcabc</code>, <code>uxzuxz</code>这样的三字母重复：</p>
<div class="sourceCode" id="cb2905"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2905-1"><a href="text.html#cb2905-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;abcabc&quot;</span>, <span class="st">&quot;aabbcc&quot;</span>), </span>
<span id="cb2905-2"><a href="text.html#cb2905-2"></a>             <span class="st">&quot;([a-z]{3})</span><span class="ch">\\</span><span class="st">1&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-45e889569854f8c6c21e" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-45e889569854f8c6c21e">{"x":{"html":"<ul>\n  <li><span class='match'>abcabc<\/span><\/li>\n  <li>aabbcc<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>又例如，下面的程序找出了年（后两位）、月、日数字相同的日期：</p>
<div class="sourceCode" id="cb2906"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2906-1"><a href="text.html#cb2906-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;2008-08-08&quot;</span>, <span class="st">&quot;2017-01-18&quot;</span>), </span>
<span id="cb2906-2"><a href="text.html#cb2906-2"></a>             <span class="st">&quot;</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d)-</span><span class="ch">\\</span><span class="st">1-</span><span class="ch">\\</span><span class="st">1&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-5a12bcadb0e98004578b" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-5a12bcadb0e98004578b">{"x":{"html":"<ul>\n  <li><span class='match'>2008-08-08<\/span><\/li>\n  <li>2017-01-18<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<p>stringr的函数<code>str_replace_all(string, pattern, replacement)</code>可以指定一个查找模式<code>pattern</code>,
替换模式<code>replacement</code>，
对字符型向量<code>string</code>中的每个元素进行替换。
<code>replacement</code>中的元字符没有特殊解释，
但是<code>\1</code>, <code>\2</code>等代表匹配的子模式（捕获）。</p>
<p>例：希望把带有前导零的数字的前导零删除，可以用如</p>
<div class="sourceCode" id="cb2907"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2907-1"><a href="text.html#cb2907-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1204&quot;</span>, <span class="st">&quot;01204&quot;</span>, <span class="st">&quot;001204B&quot;</span>)</span>
<span id="cb2907-2"><a href="text.html#cb2907-2"></a>pat &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">b0+([1-9][0-9]*)</span><span class="ch">\\</span><span class="st">b&quot;</span></span>
<span id="cb2907-3"><a href="text.html#cb2907-3"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb2907-4"><a href="text.html#cb2907-4"></a><span class="kw">str_view_all</span>(x, pat)</span></code></pre></div>
<div id="htmlwidget-06cb3e3c46a478b00edc" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-06cb3e3c46a478b00edc">{"x":{"html":"<ul>\n  <li>1204<\/li>\n  <li><span class='match'>01204<\/span><\/li>\n  <li>001204B<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2908"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2908-1"><a href="text.html#cb2908-1"></a><span class="kw">str_replace_all</span>(x, pat, repl)</span></code></pre></div>
<pre><code>## [1] &quot;1204&quot;    &quot;1204&quot;    &quot;001204B&quot;</code></pre>
<p>上例的模式中的<code>\b</code>表示单词边界，
所以中间的0不会被当作前导零，
不是整个数字的也不会被修改。</p>
<p>上例中的<code>str_view_all()</code>仅用于调试目的，
在进行替换时不时必要步骤。</p>
<p>例：为了交换横纵坐标，可以用如下替换</p>
<div class="sourceCode" id="cb2910"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2910-1"><a href="text.html#cb2910-1"></a>x &lt;-<span class="st"> &quot;1st: (5,3.6), 2nd: (2.5, 1.1)&quot;</span></span>
<span id="cb2910-2"><a href="text.html#cb2910-2"></a>pat &lt;-<span class="st"> </span><span class="kw">paste0</span>(</span>
<span id="cb2910-3"><a href="text.html#cb2910-3"></a>  <span class="st">&quot;[(]([[:digit:].]+),&quot;</span>,</span>
<span id="cb2910-4"><a href="text.html#cb2910-4"></a>  <span class="st">&quot;[[:space:]]*([[:digit:].]+)[)]&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb2910-5"><a href="text.html#cb2910-5"></a>repl &lt;-<span class="st"> &quot;(</span><span class="ch">\\</span><span class="st">2, </span><span class="ch">\\</span><span class="st">1)&quot;</span></span>
<span id="cb2910-6"><a href="text.html#cb2910-6"></a><span class="kw">str_view_all</span>(x, pat)</span></code></pre></div>
<div id="htmlwidget-21850f989467f9dc40c8" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-21850f989467f9dc40c8">{"x":{"html":"<ul>\n  <li>1st: <span class='match'>(5,3.6)<\/span>, 2nd: <span class='match'>(2.5, 1.1)<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2911"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2911-1"><a href="text.html#cb2911-1"></a><span class="kw">str_replace_all</span>(x, pat, repl)</span></code></pre></div>
<pre><code>## [1] &quot;1st: (3.6, 5), 2nd: (1.1, 2.5)&quot;</code></pre>
<p>例: 要匹配<code>yyyy-mm-dd</code>这样的日期，
并将其改写为mm/dd/yyyy，
就可以用这样的替换模式：</p>
<div class="sourceCode" id="cb2913"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2913-1"><a href="text.html#cb2913-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1998-05-31&quot;</span>, <span class="st">&quot;2017-01-14&quot;</span>)</span>
<span id="cb2913-2"><a href="text.html#cb2913-2"></a>pat &lt;-<span class="st"> &quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;</span></span>
<span id="cb2913-3"><a href="text.html#cb2913-3"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">2/</span><span class="ch">\\</span><span class="st">3/</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb2913-4"><a href="text.html#cb2913-4"></a><span class="kw">str_view_all</span>(x, pat)</span></code></pre></div>
<div id="htmlwidget-66da6e61627569ef8649" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-66da6e61627569ef8649">{"x":{"html":"<ul>\n  <li><span class='match'>1998-05-31<\/span><\/li>\n  <li><span class='match'>2017-01-14<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2914"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2914-1"><a href="text.html#cb2914-1"></a><span class="kw">str_replace_all</span>(x, pat, repl)</span></code></pre></div>
<pre><code>## [1] &quot;05/31/1998&quot; &quot;01/14/2017&quot;</code></pre>
<p>如果某个分组仅想起到分组作用但是不会提取具体的匹配内容也不会用该组内容做替换，
可以将该组变成“非捕获分组”，
办法是把表示分组开始左圆括号变成<code>(?:</code>三个字符。
这在用分组表示优先级时比较有用，
如<code>"Jam(es|Ji)m"</code>可以写成<code>"Jam(?:es|Ji)m"</code>。
非捕获分组在向后引用和替换时不计入<code>\1</code>、<code>\2</code>这样的排列中。</p>
<p>比如，把1921-2020之间的世纪号删去，可以用</p>
<div class="sourceCode" id="cb2916"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2916-1"><a href="text.html#cb2916-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1978&quot;</span>, <span class="st">&quot;2017&quot;</span>, <span class="st">&quot;2035&quot;</span>)</span>
<span id="cb2916-2"><a href="text.html#cb2916-2"></a>pat &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A(?:19|20)([0-9]{2})</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb2916-3"><a href="text.html#cb2916-3"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb2916-4"><a href="text.html#cb2916-4"></a><span class="kw">str_view_all</span>(x, pat)</span></code></pre></div>
<div id="htmlwidget-4f902e4128354115c1d6" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-4f902e4128354115c1d6">{"x":{"html":"<ul>\n  <li><span class='match'>1978<\/span><\/li>\n  <li><span class='match'>2017<\/span><\/li>\n  <li><span class='match'>2035<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2917"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2917-1"><a href="text.html#cb2917-1"></a><span class="kw">str_replace_all</span>(x, pat, repl)</span></code></pre></div>
<pre><code>## [1] &quot;78&quot; &quot;17&quot; &quot;35&quot;</code></pre>
<p>其中用了非捕获分组使得备择模式<code>19|20</code>优先匹配。
注意模式并没有能保证日期在1921-2020之间。更周密的程序可以写成：</p>
<div class="sourceCode" id="cb2919"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2919-1"><a href="text.html#cb2919-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1978&quot;</span>, <span class="st">&quot;2017&quot;</span>, <span class="st">&quot;2035&quot;</span>)</span>
<span id="cb2919-2"><a href="text.html#cb2919-2"></a>pat1 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A19(2[1-9]|[3-9][0-9])</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb2919-3"><a href="text.html#cb2919-3"></a>pat2 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A20([01][0-9]|20)</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb2919-4"><a href="text.html#cb2919-4"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb2919-5"><a href="text.html#cb2919-5"></a><span class="kw">str_view_all</span>(x, pat1)</span></code></pre></div>
<div id="htmlwidget-0eca3efce5efbb8d7ef4" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-0eca3efce5efbb8d7ef4">{"x":{"html":"<ul>\n  <li><span class='match'>1978<\/span><\/li>\n  <li>2017<\/li>\n  <li>2035<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2920"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2920-1"><a href="text.html#cb2920-1"></a><span class="kw">str_view_all</span>(x, pat2)</span></code></pre></div>
<div id="htmlwidget-d454d96156be9387f87a" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-d454d96156be9387f87a">{"x":{"html":"<ul>\n  <li>1978<\/li>\n  <li><span class='match'>2017<\/span><\/li>\n  <li>2035<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2921"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2921-1"><a href="text.html#cb2921-1"></a>x <span class="op">%&gt;%</span></span>
<span id="cb2921-2"><a href="text.html#cb2921-2"></a><span class="st">  </span><span class="kw">str_replace_all</span>(pat1, repl) <span class="op">%&gt;%</span></span>
<span id="cb2921-3"><a href="text.html#cb2921-3"></a><span class="st">  </span><span class="kw">str_replace_all</span>(pat2, repl)</span></code></pre></div>
<pre><code>## [1] &quot;78&quot;   &quot;17&quot;   &quot;2035&quot;</code></pre>
<p>这里用了stringr包重新定义的管道运算，
与magrittr包定义的管道运算作用相同，
可以将函数的第一个自变量自动输入给管道的下一个处理层级。</p>
</div>
</div>
<div id="text-stringr-funcs" class="section level2">
<h2><span class="header-section-number">36.4</span> stringr包的正则表达式函数</h2>
<div id="text-stringr-funcs-strview" class="section level3">
<h3><span class="header-section-number">36.4.1</span> <code>str_view()</code>函数</h3>
<p><code>str_view(string, pattern)</code>在RStudio中打开Viewer窗格，
显示<code>pattern</code>给出的正则表达式模式在<code>string</code>中的首个匹配。
<code>string</code>是输入的字符型向量。
用<code>str_view_all()</code>显示所有匹配。</p>
<p>如果要匹配的是固定字符串，
写成<code>str_view(string, fixed(pattern))</code>。</p>
<p>如果要匹配的是单词等的边界，
模式用<code>boundary()</code>函数表示，如
<code>str_view("a brown fox", boundary("word"))</code>将匹配首个单词。</p>
</div>
<div id="text-stringr-funcs-regex" class="section level3">
<h3><span class="header-section-number">36.4.2</span> <code>regex()</code>函数</h3>
<p>stringr包用到正则表达式模式的地方，
实际上应该写成<code>regex(pattern)</code>，
只写模式本身是一种简写。
<code>regex()</code>函数可以指定<code>ignore_case=TRUE</code>要求不区分大小写，
指定<code>multi_line=TRUE</code>使得<code>^</code>和<code>$</code>匹配用换行符分开的每行的开头和结尾，
<code>dotall=TRUE</code>使得<code>.</code>能够匹配换行符。
<code>comment=TRUE</code>使得模式可以写成多行，
行尾的井号后面表示注释，
这时空格不再原样匹配，
为了匹配空格需要写在方括号内或者用反斜杠开头。</p>
<p>与<code>regex()</code>类似的表示模式的函数有<code>fixed()</code>，
<code>boundary()</code>，<code>coll()</code>。</p>
</div>
<div id="text-stringr-funcs-detect" class="section level3">
<h3><span class="header-section-number">36.4.3</span> 检查那些元素能够匹配</h3>
<p><code>str_detect(string, pattern)</code>返回字符型向量<code>string</code>的每个元素是否匹配<code>pattern</code>中的模式的逻辑型结果。
与基本R的<code>grepl()</code>作用类似。
如</p>
<div class="sourceCode" id="cb2923"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2923-1"><a href="text.html#cb2923-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2923-2"><a href="text.html#cb2923-2"></a><span class="kw">str_view</span>(x, <span class="st">&quot;the&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-f73284ee13dc98c0b845" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-f73284ee13dc98c0b845">{"x":{"html":"<ul>\n  <li>New <span class='match'>the<\/span>me<\/li>\n  <li>Old times<\/li>\n  <li>In <span class='match'>the<\/span> present theme<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2924"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2924-1"><a href="text.html#cb2924-1"></a><span class="kw">str_detect</span>(x, <span class="st">&quot;the&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
<p>上例中的<code>str_view()</code>仅用作调试目的。</p>
<p><code>str_which(string, pattern)</code>返回字符型向量<code>string</code>的元素当中能匹配<code>pattern</code>中的模式的元素序号。
与基本R的<code>grep()</code>作用类似。
如</p>
<div class="sourceCode" id="cb2926"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2926-1"><a href="text.html#cb2926-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2926-2"><a href="text.html#cb2926-2"></a><span class="kw">str_which</span>(x, <span class="st">&quot;the&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 1 3</code></pre>
<p><code>str_count()</code>则返回模式在每个元素中匹配的次数。
如</p>
<div class="sourceCode" id="cb2928"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2928-1"><a href="text.html#cb2928-1"></a><span class="kw">str_count</span>(<span class="kw">c</span>(<span class="st">&quot;123,456&quot;</span>, <span class="st">&quot;011&quot;</span>), <span class="st">&quot;[[:digit:]]&quot;</span>)</span></code></pre></div>
<pre><code>## [1] 6 3</code></pre>
</div>
<div id="text-stringr-funcs-replace" class="section level3">
<h3><span class="header-section-number">36.4.4</span> 替换</h3>
<p>stringr包的<code>str_replace_all(string, pattern, replacement)</code>在字符型向量<code>string</code>的每个元素中查找模式<code>pattern</code>，
并将所有匹配按照<code>replacement</code>进行替换。
在<code>replacement</code>可以用<code>\1</code>, <code>\2</code>中表示模式中的捕获，
除此之外元字符没有特殊作用。</p>
<p>基本R中<code>gsub()</code>有类似功能。</p>
<p>如：</p>
<div class="sourceCode" id="cb2930"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2930-1"><a href="text.html#cb2930-1"></a><span class="kw">str_replace_all</span>(<span class="kw">c</span>(<span class="st">&quot;123,456&quot;</span>, <span class="st">&quot;011&quot;</span>), <span class="st">&quot;,&quot;</span>, <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;123456&quot; &quot;011&quot;</code></pre>
<p>又如：</p>
<div class="sourceCode" id="cb2932"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2932-1"><a href="text.html#cb2932-1"></a><span class="kw">str_replace_all</span>(<span class="kw">c</span>(<span class="st">&quot;123,456&quot;</span>, <span class="st">&quot;011&quot;</span>), </span>
<span id="cb2932-2"><a href="text.html#cb2932-2"></a>                <span class="st">&quot;([[:digit:]]+),([[:digit:]]+)&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">2,</span><span class="ch">\\</span><span class="st">1&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;456,123&quot; &quot;011&quot;</code></pre>
<p>注意源数据中第二个元素因为不能匹配所以就原样返回了，
没有进行替换。</p>
<p><code>str_replace()</code>则仅对输入字符型向量的每个元素中模式的第一次出现进行替换，
不如<code>str_replace_all()</code>常用。</p>
</div>
<div id="text-stringr-funcs-subset" class="section level3">
<h3><span class="header-section-number">36.4.5</span> 返回匹配的元素</h3>
<p><code>str_subset(string, pattern)</code>返回字符型向量中能匹配<code>pattern</code>的那些元素组成的子集，
与基本R函数<code>grep(pattern, string, value=TRUE)</code>效果相同。
注意，返回的是整个元素而不是匹配的子串。</p>
<p>比如，查找人名中间有空格的：</p>
<div class="sourceCode" id="cb2934"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2934-1"><a href="text.html#cb2934-1"></a><span class="kw">str_view_all</span>(<span class="kw">c</span>(<span class="st">&quot;[马思聪]&quot;</span>, <span class="st">&quot;[李  明]&quot;</span>), </span>
<span id="cb2934-2"><a href="text.html#cb2934-2"></a>             <span class="st">&quot;[[:alpha:]]+[[:space:]]+[[:alpha:]]+&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-c8733ec34b28f6d91d09" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-c8733ec34b28f6d91d09">{"x":{"html":"<ul>\n  <li>[马思聪]<\/li>\n  <li>[<span class='match'>李  明<\/span>]<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2935"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2935-1"><a href="text.html#cb2935-1"></a><span class="kw">str_subset</span>(<span class="kw">c</span>(<span class="st">&quot;[马思聪]&quot;</span>, <span class="st">&quot;[李  明]&quot;</span>), </span>
<span id="cb2935-2"><a href="text.html#cb2935-2"></a>           <span class="st">&quot;[[:alpha:]]+[[:space:]]+[[:alpha:]]+&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;[李  明]&quot;</code></pre>
<p>注意上例中仅返回了有匹配的元素，
而且是匹配元素的整个字符串而不是匹配的部分。</p>
<p>当要查找的内容是tibble的一列时，
用<code>filter()</code>与<code>str_detct()</code>配合，
可以进行行子集选择。
比如，在数据框的人名中查找中间有空格的名字：</p>
<div class="sourceCode" id="cb2937"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2937-1"><a href="text.html#cb2937-1"></a><span class="kw">tibble</span>(<span class="dt">name=</span><span class="kw">c</span>(<span class="st">&quot;马思聪&quot;</span>, <span class="st">&quot;李  明&quot;</span>)) <span class="op">%&gt;%</span></span>
<span id="cb2937-2"><a href="text.html#cb2937-2"></a><span class="st">  </span><span class="kw">filter</span>(<span class="kw">str_detect</span>(name, <span class="st">&quot;[[:alpha:]]+[[:space:]]+[[:alpha:]]+&quot;</span>))</span></code></pre></div>
<pre><code>## # A tibble: 1 x 1
##   name  
##   &lt;chr&gt; 
## 1 李  明</code></pre>
</div>
<div id="text-stringr-funcs-extract" class="section level3">
<h3><span class="header-section-number">36.4.6</span> 提取匹配内容</h3>
<p><code>str_subset()</code>返回的是有匹配的源字符串，
而不是匹配的部分子字符串。
用<code>str_extract(string, pattern)</code>从源字符串中取出<strong>首次</strong>匹配的子串。</p>
<p>如</p>
<div class="sourceCode" id="cb2939"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2939-1"><a href="text.html#cb2939-1"></a><span class="kw">str_view_all</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-c737cde6d7c5e4e51a63" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-c737cde6d7c5e4e51a63">{"x":{"html":"<ul>\n  <li>A f<span class='match'>all<\/span>ing b<span class='match'>all<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2940"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2940-1"><a href="text.html#cb2940-1"></a><span class="kw">str_extract</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<pre><code>## [1] &quot;all&quot;</code></pre>
<p><code>str_extract_all(string, pattern)</code>取出所有匹配子串，
结果是一个列表，
列表的每个元素对应于字符型向量<code>string</code>的每个元素，
结果列表的每个元素是一个字符型数组，
存放所有匹配的子字符串。
如：</p>
<div class="sourceCode" id="cb2942"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2942-1"><a href="text.html#cb2942-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;Phone call.&quot;</span>)</span>
<span id="cb2942-2"><a href="text.html#cb2942-2"></a><span class="kw">str_view_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-e952432f7761817f6be5" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-e952432f7761817f6be5">{"x":{"html":"<ul>\n  <li>A f<span class='match'>all<\/span>ing b<span class='match'>all<\/span><\/li>\n  <li>Phone c<span class='match'>all<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2943"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2943-1"><a href="text.html#cb2943-1"></a><span class="kw">str_extract_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;all&quot; &quot;all&quot;
## 
## [[2]]
## [1] &quot;all&quot;</code></pre>
<p><code>str_extract_all()</code>可以加选项<code>simplyfy=TRUE</code>，
使得返回结果变成一个字符型矩阵，
每行是原来一个元素中取出的各个子串，
列数等于最大匹配次数，
没有那么多匹配次数的填以空字符串。
如果正常匹配结果不会出现空字符就可以用这种方法简化结果的保存和访问。
如</p>
<div class="sourceCode" id="cb2945"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2945-1"><a href="text.html#cb2945-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;Phone call.&quot;</span>)</span>
<span id="cb2945-2"><a href="text.html#cb2945-2"></a><span class="kw">str_view_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-a8fee4cddcc87bcdecfd" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-a8fee4cddcc87bcdecfd">{"x":{"html":"<ul>\n  <li>A f<span class='match'>all<\/span>ing b<span class='match'>all<\/span><\/li>\n  <li>Phone c<span class='match'>all<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2946"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2946-1"><a href="text.html#cb2946-1"></a><span class="kw">str_extract_all</span>(x, <span class="st">&quot;all&quot;</span>, <span class="dt">simplify=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>##      [,1]  [,2] 
## [1,] &quot;all&quot; &quot;all&quot;
## [2,] &quot;all&quot; &quot;&quot;</code></pre>
</div>
<div id="text-stringr-funcs-match" class="section level3">
<h3><span class="header-section-number">36.4.7</span> 提取分组捕获内容</h3>
<p><code>str_subset()</code>提取的是能匹配模式的元素子集，
而不是匹配的模式或者捕获；
<code>str_extract()</code>和<code>str_extract_all()</code>提取的是每个元素的首次或者所有匹配的子字符串，
而不是其中的捕获。</p>
<p><code>str_match(string, pattern)</code>提取每个元素的首次匹配内容以及其中各个捕获分组内容，
结果是一个矩阵，
每行对应于字符型向量<code>string</code>中的一个元素，
结果矩阵的每行的第一个元素是匹配内容，其它元素是各个捕获，
没有则为字符型缺失值（不是空字符串）。</p>
<p>比如，希望匹配中间有空格的人名并捕获空格前后部分：</p>
<div class="sourceCode" id="cb2948"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2948-1"><a href="text.html#cb2948-1"></a><span class="kw">str_match</span>(<span class="kw">c</span>(<span class="st">&quot;马思聪&quot;</span>, <span class="st">&quot;李  明&quot;</span>), </span>
<span id="cb2948-2"><a href="text.html#cb2948-2"></a>          <span class="st">&quot;([[:alpha:]]+)[[:space:]]+([[:alpha:]]+)&quot;</span>)</span></code></pre></div>
<pre><code>##      [,1]     [,2] [,3]
## [1,] NA       NA   NA  
## [2,] &quot;李  明&quot; &quot;李&quot; &quot;明&quot;</code></pre>
<p>上例中源数据第一个元素没有匹配，
所以结果都是缺失值<code>NA</code>，
第二个元素的结果在第二行，
首先是整个匹配的子字符串，
然后是捕获的两个部分。</p>
<p><code>stringr::str_match_all(string, pattern)</code>匹配每个字符串中所有出现位置，
结果是一个列表，
每个列表元素对应于输入的字符型向量<code>string</code>的每个元素，
结果中每个列表元素是一个字符型矩阵，
用来保存所有各个匹配以及匹配中的捕获，
每行是一个匹配的结果，首先是匹配结果，其次是各个捕获。
结果列表中每个作为列表元素的矩阵大小不一定相同。
当某个元素完全没有匹配时，
结果列表中对应元素是行数为0的矩阵。</p>
<p>比如，模式为19xx或者20xx的年份，
并将其分为前两位和后两位：</p>
<div class="sourceCode" id="cb2950"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2950-1"><a href="text.html#cb2950-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1978-2000&quot;</span>, <span class="st">&quot;2011-2020-2099&quot;</span>, <span class="st">&quot;2100-2199&quot;</span>)</span>
<span id="cb2950-2"><a href="text.html#cb2950-2"></a>pat &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">b(19|20)([0-9]{2})</span><span class="ch">\\</span><span class="st">b&quot;</span></span>
<span id="cb2950-3"><a href="text.html#cb2950-3"></a><span class="kw">str_view_all</span>(x, pat)</span></code></pre></div>
<div id="htmlwidget-9c01dbd37685d1db3494" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-9c01dbd37685d1db3494">{"x":{"html":"<ul>\n  <li><span class='match'>1978<\/span>-<span class='match'>2000<\/span><\/li>\n  <li><span class='match'>2011<\/span>-<span class='match'>2020<\/span>-<span class='match'>2099<\/span><\/li>\n  <li>2100-2199<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2951"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2951-1"><a href="text.html#cb2951-1"></a>mlist &lt;-<span class="st"> </span><span class="kw">str_match_all</span>(x,  pat); mlist</span></code></pre></div>
<pre><code>## [[1]]
##      [,1]   [,2] [,3]
## [1,] &quot;1978&quot; &quot;19&quot; &quot;78&quot;
## [2,] &quot;2000&quot; &quot;20&quot; &quot;00&quot;
## 
## [[2]]
##      [,1]   [,2] [,3]
## [1,] &quot;2011&quot; &quot;20&quot; &quot;11&quot;
## [2,] &quot;2020&quot; &quot;20&quot; &quot;20&quot;
## [3,] &quot;2099&quot; &quot;20&quot; &quot;99&quot;
## 
## [[3]]
##      [,1] [,2] [,3]</code></pre>
<p>下面的程序合并上面提取的年份后两位为一个字符型向量：</p>
<div class="sourceCode" id="cb2953"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2953-1"><a href="text.html#cb2953-1"></a>ml &lt;-<span class="st"> </span><span class="kw">Filter</span>(<span class="cf">function</span>(m) <span class="kw">nrow</span>(m)<span class="op">&gt;</span><span class="dv">0</span>, mlist)</span>
<span id="cb2953-2"><a href="text.html#cb2953-2"></a>ml &lt;-<span class="st"> </span><span class="kw">Map</span>(<span class="cf">function</span>(m) m[,<span class="dv">3</span>], ml)</span>
<span id="cb2953-3"><a href="text.html#cb2953-3"></a>ml &lt;-<span class="st"> </span><span class="kw">Reduce</span>(c, ml); ml</span></code></pre></div>
<pre><code>## [1] &quot;78&quot; &quot;00&quot; &quot;11&quot; &quot;20&quot; &quot;99&quot;</code></pre>
</div>
<div id="text-stringr-funcs-locate" class="section level3">
<h3><span class="header-section-number">36.4.8</span> 定位匹配位置</h3>
<p><code>str_locate(string, pattern)</code>对输入字符型向量<code>string</code>的每个元素返回首次匹配<code>pattern</code>的开始和结束位置。
输出结果是一个两列的矩阵，每行对应于输入的一个元素，
每行的两个元素分别是首次匹配的开始和结束字符序号（按字符计算）。如</p>
<div class="sourceCode" id="cb2955"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2955-1"><a href="text.html#cb2955-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;Phone call.&quot;</span>)</span>
<span id="cb2955-2"><a href="text.html#cb2955-2"></a><span class="kw">str_view_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-bc4eb7b84240b62c8905" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-bc4eb7b84240b62c8905">{"x":{"html":"<ul>\n  <li>A f<span class='match'>all<\/span>ing b<span class='match'>all<\/span><\/li>\n  <li>Phone c<span class='match'>all<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2956"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2956-1"><a href="text.html#cb2956-1"></a><span class="kw">str_locate</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<pre><code>##      start end
## [1,]     4   6
## [2,]     8  10</code></pre>
<p><code>str_locate_all(string, pattern)</code>则可以返回每个元素中所有匹配的开始和结束位置，
结果是一个列表，
每个列表元素对应于输入字符型向量的每个元素，
结果中每个列表元素是一个两列的数值型矩阵，
每行为一个匹配的开始和结束字符序号。如</p>
<div class="sourceCode" id="cb2958"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2958-1"><a href="text.html#cb2958-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;A falling ball&quot;</span>, <span class="st">&quot;Phone call.&quot;</span>)</span>
<span id="cb2958-2"><a href="text.html#cb2958-2"></a><span class="kw">str_view_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<div id="htmlwidget-642021b39f4914a5b2d9" style="width:960px;height:100%;" class="str_view html-widget"></div>
<script type="application/json" data-for="htmlwidget-642021b39f4914a5b2d9">{"x":{"html":"<ul>\n  <li>A f<span class='match'>all<\/span>ing b<span class='match'>all<\/span><\/li>\n  <li>Phone c<span class='match'>all<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<div class="sourceCode" id="cb2959"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2959-1"><a href="text.html#cb2959-1"></a><span class="kw">str_locate_all</span>(x, <span class="st">&quot;all&quot;</span>)</span></code></pre></div>
<pre><code>## [[1]]
##      start end
## [1,]     4   6
## [2,]    12  14
## 
## [[2]]
##      start end
## [1,]     8  10</code></pre>
<p>注意如果需要取出匹配的元素可以用<code>str_subset()</code>，
要取出匹配的子串可以用<code>str_extract()</code>和<code>str_extract_all()</code>，
取出匹配的子串以及分组捕获可以用<code>str_match()</code>和<code>str_match_all()</code>。</p>
</div>
</div>
<div id="text-regex-bfuncs" class="section level2">
<h2><span class="header-section-number">36.5</span> 利用基本R函数进行正则表达式处理</h2>
<p>基本R函数<code>grep</code>, <code>sub</code>, <code>gsub</code>, <code>regexpr</code>, <code>gregexpr</code>, <code>regexec</code>中的
<code>pattern</code>参数可以是正则表达式，
这时应设参数 <code>fixed=FALSE</code>。
<code>strsplit</code>函数中的参数<code>split</code>也可以是正则表达式。
<code>regmatches</code>函数从<code>regexpr</code>, <code>gregexpr</code>,
<code>regexec</code>的结果中提取匹配的字符串。</p>
<p>以原样匹配为例。</p>
<div class="sourceCode" id="cb2961"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2961-1"><a href="text.html#cb2961-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2961-2"><a href="text.html#cb2961-2"></a><span class="kw">regexpr</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1]  5 -1  4
## attr(,&quot;match.length&quot;)
## [1]  3 -1  3
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p>这里使用了<code>regexpr</code>函数。
<code>regexpr</code>函数的一般用法为：</p>
<div class="sourceCode" id="cb2963"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2963-1"><a href="text.html#cb2963-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2963-2"><a href="text.html#cb2963-2"></a><span class="kw">regexpr</span>(pattern, text, <span class="dt">ignore.case =</span> <span class="ot">FALSE</span>, <span class="dt">perl =</span> <span class="ot">FALSE</span>,</span>
<span id="cb2963-3"><a href="text.html#cb2963-3"></a>        <span class="dt">fixed =</span> <span class="ot">FALSE</span>, <span class="dt">useBytes =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<p>自变量为：</p>
<ul>
<li>pattern 是一个正则表达式，如果用了<code>fixed=TRUE</code>选项，则当作普通原样文本来匹配；</li>
<li>text 是源字符串向量，要从其每个元素中查找pattern模式出现的位置；</li>
<li>ignore.case：是否要忽略大小写匹配；</li>
<li>perl 选择是否采用perl格式，如果不把pattern当作普通原样文本，应该选<code>perl=TRUE</code>，perl语言的正则表达式是事实上的标准，所以这样兼容性更好；</li>
<li>fixed 当<code>fixed=TRUE</code>时<code>pattern</code>作为普通原样文本解释；</li>
<li>useBytes 为TRUE时逐字节进行匹配，否则逐字符进行匹配。之所以有这样的区别，是因为有些编码中一个字符由多个字节构成，BGK编码的汉字由两个字节组成，UTF-8编码的汉字也是由两个字节构成。</li>
</ul>
<p><code>regexpr()</code>函数返回一个整数值的向量，
长度与<code>text</code>向量长度相同，
结果的每个元素是在<code>text</code>的对应元素中<code>pattern</code>的首次匹配位置；
没有匹配时结果元素取-1。
结果会有一个<code>match.length</code>属性，表示每个匹配的长度，
无匹配时取-1。</p>
<p>如果仅关心源字符串向量<code>text</code>中哪些元素能匹配<code>pattern</code>，
可以用<code>grep</code>函数，如</p>
<div class="sourceCode" id="cb2964"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2964-1"><a href="text.html#cb2964-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2964-2"><a href="text.html#cb2964-2"></a><span class="kw">grep</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1 3</code></pre>
<p>结果说明源字符串向量的三个元素中仅有第1、第3号元素能匹配。
如果都不匹配，返回<code>integer(0)</code>。</p>
<p><code>grep</code>可以使用与<code>regexpr</code>相同的自变量，
另外还可以加选项<code>invert=TRUE</code>，这时返回的是不匹配的元素的下标。</p>
<p><code>grep()</code>如果添加选项<code>value=TRUE</code>，
则结果不是返回有匹配的元素的下标而是返回有匹配的元素本身（不是匹配的子串），
如</p>
<div class="sourceCode" id="cb2966"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2966-1"><a href="text.html#cb2966-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2966-2"><a href="text.html#cb2966-2"></a><span class="kw">grep</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>, <span class="dt">value=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;New theme&quot;            &quot;In the present theme&quot;</code></pre>
<p><code>grepl</code>的作用与<code>grep</code>类似，
但是其返回值是一个长度与源字符串向量<code>text</code>等长的逻辑型向量，
每个元素的真假对应于源字符串向量中对应元素的匹配与否。如</p>
<div class="sourceCode" id="cb2968"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2968-1"><a href="text.html#cb2968-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2968-2"><a href="text.html#cb2968-2"></a><span class="kw">grepl</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
<p>就像<code>grep()</code>与<code>grepl()</code>本质上给出相同的结果，只是结果的表示方式不同，
<code>regexec()</code>与<code>regexpr()</code>也给出仅在表示方式上有区别的结果。
<code>regexpr()</code>主要的结果是每个元素的匹配位置，
用一个统一的属性返回各个匹配长度；
<code>regexec()</code>则返回一个与源字符串向量等长的列表，
列表的每个元素为匹配的位置，并且列表的每个元素有匹配长度作为属性。
所以，这两个函数只需要用其中一个就可以，下面仅使用<code>regexpr()</code>。
<code>regexec()</code>的使用效果如</p>
<div class="sourceCode" id="cb2970"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2970-1"><a href="text.html#cb2970-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2970-2"><a href="text.html#cb2970-2"></a><span class="kw">regexec</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 5
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,&quot;match.length&quot;)
## [1] -1
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[3]]
## [1] 4
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p><code>grep()</code>, <code>grepl()</code>, <code>regexpr()</code>, <code>regexec()</code>都只能找到源字符串向量的每个元素中模式的首次匹配，
不能找到所有匹配。
<code>gregexpr()</code>函数可以找到所有匹配。
如</p>
<div class="sourceCode" id="cb2972"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2972-1"><a href="text.html#cb2972-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2972-2"><a href="text.html#cb2972-2"></a><span class="kw">gregexpr</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [[1]]
## [1] 5
## attr(,&quot;match.length&quot;)
## [1] 3
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[2]]
## [1] -1
## attr(,&quot;match.length&quot;)
## [1] -1
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE
## 
## [[3]]
## [1]  4 16
## attr(,&quot;match.length&quot;)
## [1] 3 3
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p>其结果是一个与源字符串向量等长的列表，
格式与<code>regexec()</code>的结果格式类似，
列表的每个元素对应于源字符串向量的相应元素，
列表元素值为匹配的位置，
并有属性<code>match.length</code>保存了匹配长度。
匹配位置和匹配长度包含了所有的匹配，
见上面例子中第三个元素的匹配结果。</p>
<p>函数<code>grep</code>, <code>grepl</code>结果仅给出每个元素能否匹配。
<code>regexpr()</code>, <code>regexec()</code>, <code>gregexpr()</code>则包含了匹配位置与匹配长度，
这时，可以用<code>regmatches()</code>函数取出具体的匹配字符串。
<code>regmatches()</code>一般格式为</p>
<div class="sourceCode" id="cb2974"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2974-1"><a href="text.html#cb2974-1"></a><span class="kw">regmatches</span>(x, m, <span class="dt">invert =</span> <span class="ot">FALSE</span>)</span></code></pre></div>
<p>其中<code>x</code>是源字符串向量，
<code>m</code>是<code>regexpr()</code>、<code>regexec()</code>或<code>gregexpr()</code>的匹配结果。
如</p>
<div class="sourceCode" id="cb2975"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2975-1"><a href="text.html#cb2975-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2975-2"><a href="text.html#cb2975-2"></a>m &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb2975-3"><a href="text.html#cb2975-3"></a><span class="kw">regmatches</span>(x, m)</span></code></pre></div>
<pre><code>## [1] &quot;the&quot; &quot;the&quot;</code></pre>
<p>可以看出，<code>regmatches()</code>仅取出有匹配时的匹配内容，
无匹配的内容被忽略。</p>
<p>取出多处匹配的例子如：</p>
<div class="sourceCode" id="cb2977"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2977-1"><a href="text.html#cb2977-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;New theme&quot;</span>, <span class="st">&quot;Old times&quot;</span>, <span class="st">&quot;In the present theme&quot;</span>)</span>
<span id="cb2977-2"><a href="text.html#cb2977-2"></a>m &lt;-<span class="st"> </span><span class="kw">gregexpr</span>(<span class="st">&quot;the&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb2977-3"><a href="text.html#cb2977-3"></a><span class="kw">regmatches</span>(x, m)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;the&quot;
## 
## [[2]]
## character(0)
## 
## [[3]]
## [1] &quot;the&quot; &quot;the&quot;</code></pre>
<p>当<code>regmatches()</code>第二个自变量是<code>gregexpr()</code>的结果时，
其输出结果变成一个列表，
并且不再忽略无匹配的元素，
无匹配元素对应的列表元素为<code>character(0)</code>，
即长度为零的字符型向量。
对有匹配的元素，
对应的列表元素为所有的匹配字符串组成的字符型向量。</p>
<p>实际上，
如果<code>pattern</code>中没有正则表达式，
<code>grep()</code>, <code>grepl()</code>, <code>regexpr()</code>, <code>gregexpr()</code>
中都可以用<code>fixed=TRUE</code>参数取代<code>perl=TRUE</code>参数，
这时匹配总是解释为原样匹配，
即使<code>pattern</code>中包含特殊字符也是进行原样匹配。</p>
<div id="text-regex-bfuncs-igcase" class="section level3">
<h3><span class="header-section-number">36.5.1</span> 不区分大小写匹配</h3>
<p>在基本R中，
为了不区分大小写匹配，
可以在<code>grep</code>等函数调用时加选项<code>ignore.case=TRUE</code>；
如</p>
<div class="sourceCode" id="cb2979"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2979-1"><a href="text.html#cb2979-1"></a><span class="kw">grep</span>(<span class="st">&quot;Dr&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb2981"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2981-1"><a href="text.html#cb2981-1"></a><span class="kw">grep</span>(<span class="st">&quot;dr&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>), <span class="dt">ignore.case=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1 2 3</code></pre>
<div class="sourceCode" id="cb2983"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2983-1"><a href="text.html#cb2983-1"></a><span class="kw">grep</span>(<span class="st">&quot;(?i)dr&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;Dr. Wang&quot;</span>, <span class="st">&quot;DR. WANG&quot;</span>, <span class="st">&quot;dR. W.R.&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1 2 3</code></pre>
</div>
<div id="text-regex-bfuncs-dotp" class="section level3">
<h3><span class="header-section-number">36.5.2</span> 匹配单个字符</h3>
<p>在模式中用“.”匹配任意一个字符（除了换行符<code>"\n"</code>，能否匹配此字符与选项有关）。如</p>
<div class="sourceCode" id="cb2985"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2985-1"><a href="text.html#cb2985-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;cabs&quot;</span>, <span class="st">&quot;lab&quot;</span>)</span>
<span id="cb2985-2"><a href="text.html#cb2985-2"></a>mres &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;ab.&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>); mres</span></code></pre></div>
<pre><code>## [1]  1  2 -1
## attr(,&quot;match.length&quot;)
## [1]  3  3 -1
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p><code>regexpr</code>仅给出每个元素中模式的首次匹配位置而不是给出匹配的内容。
<code>regmatches</code>函数以原始字符型向量和匹配结果为输入，
结果返回每个元素中匹配的各个子字符串(不是整个元素)，如:</p>
<div class="sourceCode" id="cb2987"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2987-1"><a href="text.html#cb2987-1"></a><span class="kw">regmatches</span>(s, mres)</span></code></pre></div>
<pre><code>## [1] &quot;abc&quot; &quot;abs&quot;</code></pre>
<p>注意返回结果和输入字符型向量元素不是一一对应的，仅返回有匹配的结果。</p>
<p>像句点这样的字符称为元字符（meta characters），
在正则表达式中有特殊函数。
如果需要匹配句点本身，用“<code>[.]</code>”或者“<code>\.</code>”表示。
比如，要匹配<code>a.txt</code>这个文件名，如下做法有错误：</p>
<div class="sourceCode" id="cb2989"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2989-1"><a href="text.html#cb2989-1"></a><span class="kw">grep</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1 2</code></pre>
<p>结果连<code>a0txt</code>也匹配了。用“[.]”表示句点则将句点不做特殊解释：</p>
<div class="sourceCode" id="cb2991"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2991-1"><a href="text.html#cb2991-1"></a><span class="kw">grep</span>(<span class="st">&quot;a[.]txt&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb2993"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2993-1"><a href="text.html#cb2993-1"></a><span class="kw">grep</span>(<span class="st">&quot;a</span><span class="ch">\\</span><span class="st">.txt&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>注意在R语言字符型常量中一个<code>\</code>需要写成两个。</p>
<p>如果仅需按照原样进行查找，
也可以在<code>grep()</code>, <code>grepl()</code>，<code>regexpr()</code>，<code>gregexpr()</code>等函数中加选项<code>fixed=TRUE</code>，
这时不要再用<code>perl=TRUE</code>选项。
如</p>
<div class="sourceCode" id="cb2995"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2995-1"><a href="text.html#cb2995-1"></a><span class="kw">grep</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a.txt&quot;</span>, <span class="st">&quot;a0txt&quot;</span>), <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
</div>
<div id="text-regex-bfuncs-setp" class="section level3">
<h3><span class="header-section-number">36.5.3</span> 匹配一组字符中的某一个</h3>
<p>模式“<code>[ns]a.[.]xls</code>” 表示匹配的第一个字符是<code>n</code>或<code>s</code>，
第二个字符是<code>a</code>，第三个字符任意，第四个字符是句点，
然后是<code>xls</code>。
例：</p>
<div class="sourceCode" id="cb2997"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2997-1"><a href="text.html#cb2997-1"></a><span class="kw">regexpr</span>(<span class="st">&quot;[ns]a.[.]xls&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;sa1.xls&quot;</span>, <span class="st">&quot;dna2.xlss&quot;</span>, <span class="st">&quot;na3.xls&quot;</span>), <span class="dt">perl=</span>T)</span></code></pre></div>
<pre><code>## [1] 1 2 1
## attr(,&quot;match.length&quot;)
## [1] 7 7 7
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
</div>
<div id="text-regex-bfuncs-metalit" class="section level3">
<h3><span class="header-section-number">36.5.4</span> 原样匹配元字符</h3>
<p>例：</p>
<div class="sourceCode" id="cb2999"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2999-1"><a href="text.html#cb2999-1"></a><span class="kw">grep</span>(<span class="st">&quot;int x</span><span class="ch">\\</span><span class="st">[5</span><span class="ch">\\</span><span class="st">]&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;int x;&quot;</span>, <span class="st">&quot;int x[5]&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>也可以用“<code>[[]</code>”表示“<code>[</code>”， 用“<code>[]]</code>”表示“<code>]</code>”，如</p>
<div class="sourceCode" id="cb3001"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3001-1"><a href="text.html#cb3001-1"></a><span class="kw">grep</span>(<span class="st">&quot;int x[[]5[]]&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;int x;&quot;</span>, <span class="st">&quot;int x[5]&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 2</code></pre>
</div>
<div id="text-regex-bfuncs-digit" class="section level3">
<h3><span class="header-section-number">36.5.5</span> 匹配数字</h3>
<p>例：</p>
<div class="sourceCode" id="cb3003"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3003-1"><a href="text.html#cb3003-1"></a><span class="kw">grep</span>(<span class="st">&quot;n</span><span class="ch">\\</span><span class="st">d[.]xls&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
</div>
<div id="text-regex-bfuncs-start" class="section level3">
<h3><span class="header-section-number">36.5.6</span> 匹配开头和末尾</h3>
<p>例:</p>
<div class="sourceCode" id="cb3005"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3005-1"><a href="text.html#cb3005-1"></a><span class="kw">grep</span>(<span class="st">&quot;^n</span><span class="ch">\\</span><span class="st">d[.]xls$&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>, <span class="st">&quot;cn1.xls&quot;</span>, <span class="st">&quot;n1.xlsx&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode" id="cb3007"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3007-1"><a href="text.html#cb3007-1"></a><span class="kw">grep</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">An</span><span class="ch">\\</span><span class="st">d[.]xls</span><span class="ch">\\</span><span class="st">Z&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;n1.xls&quot;</span>, <span class="st">&quot;na.xls&quot;</span>, <span class="st">&quot;cn1.xls&quot;</span>, <span class="st">&quot;n1.xlsx&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>只匹配了第一个输入字符串。</p>
</div>
<div id="text-regex-bfuncs-alnum" class="section level3">
<h3><span class="header-section-number">36.5.7</span> 匹配字母、数字、下划线</h3>
<p>例：</p>
<div class="sourceCode" id="cb3009"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3009-1"><a href="text.html#cb3009-1"></a>m &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;s</span><span class="ch">\\</span><span class="st">w[.]&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;file-s1.xls&quot;</span>, <span class="st">&quot;s#.xls&quot;</span>), <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3009-2"><a href="text.html#cb3009-2"></a><span class="kw">regmatches</span>(<span class="kw">c</span>(<span class="st">&quot;file-s1.xls&quot;</span>, <span class="st">&quot;s#.xls&quot;</span>), m)</span></code></pre></div>
<pre><code>## [1] &quot;s1.&quot;</code></pre>
<p>可以看出，模式匹配了<code>s1.</code>而没有匹配<code>s#.</code>。</p>
</div>
<div id="text-regex-bfuncs-hex" class="section level3">
<h3><span class="header-section-number">36.5.8</span> 十六进制和八进制数</h3>
<p>例如</p>
<div class="sourceCode" id="cb3011"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3011-1"><a href="text.html#cb3011-1"></a><span class="kw">gregexpr</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">x0A&quot;</span>, <span class="st">&quot;abc</span><span class="ch">\n</span><span class="st">efg</span><span class="ch">\n</span><span class="st">&quot;</span>)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] 4 8
## attr(,&quot;match.length&quot;)
## [1] 1 1
## attr(,&quot;index.type&quot;)
## [1] &quot;chars&quot;
## attr(,&quot;useBytes&quot;)
## [1] TRUE</code></pre>
<p>匹配了两个换行符。</p>
</div>
<div id="text-regex-bfuncs-posix" class="section level3">
<h3><span class="header-section-number">36.5.9</span> POSIX字符类</h3>
<p>例如：</p>
<div class="sourceCode" id="cb3013"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3013-1"><a href="text.html#cb3013-1"></a><span class="kw">grep</span>(<span class="st">&quot;[[:alpha:]_.][[:alnum:]_.]&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;x1&quot;</span>, <span class="st">&quot;_x&quot;</span>, <span class="st">&quot;.x&quot;</span>, <span class="st">&quot;.1&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1 2 3 4</code></pre>
</div>
<div id="text-regex-bfuncs-plus" class="section level3">
<h3><span class="header-section-number">36.5.10</span> 加号重复匹配</h3>
<p>例</p>
<div class="sourceCode" id="cb3015"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3015-1"><a href="text.html#cb3015-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;sa1&quot;</span>, <span class="st">&quot;dsa123&quot;</span>)</span>
<span id="cb3015-2"><a href="text.html#cb3015-2"></a>mres &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;sa[[:digit:]]+&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3015-3"><a href="text.html#cb3015-3"></a><span class="kw">regmatches</span>(s, mres)</span></code></pre></div>
<pre><code>## [1] &quot;sa1&quot;   &quot;sa123&quot;</code></pre>
<p>例如：</p>
<div class="sourceCode" id="cb3017"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3017-1"><a href="text.html#cb3017-1"></a>p &lt;-<span class="st"> &quot;^[[:alnum:]_]+@[[:alnum:]_]+[.][[:alnum:]_]+$&quot;</span></span>
<span id="cb3017-2"><a href="text.html#cb3017-2"></a>x &lt;-<span class="st"> &quot;abc123@efg.com&quot;</span></span>
<span id="cb3017-3"><a href="text.html#cb3017-3"></a>m &lt;-<span class="st"> </span><span class="kw">regexpr</span>(p, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3017-4"><a href="text.html#cb3017-4"></a><span class="kw">regmatches</span>(x, m)</span></code></pre></div>
<pre><code>## [1] &quot;abc123@efg.com&quot;</code></pre>
<p>匹配的电子邮件地址在<code>@</code>前面可以使用任意多个字母、数字、下划线，
在<code>@</code>后面由小数点分成两段，
每段可以使用任意多个字母、数字、下划线。
这里用了<code>^</code>和<code>$</code>表示全字符串匹配。</p>
</div>
<div id="text-regex-bfuncs-ast" class="section level3">
<h3><span class="header-section-number">36.5.11</span> 星号和问号重复匹配</h3>
<p><code>^https?://[[:alnum:]./]+$</code>可以匹配http或https开始的网址。
如</p>
<div class="sourceCode" id="cb3019"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3019-1"><a href="text.html#cb3019-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;http://www.163.net&quot;</span>, <span class="st">&quot;https://123.456.&quot;</span>)</span>
<span id="cb3019-2"><a href="text.html#cb3019-2"></a><span class="kw">grep</span>(<span class="st">&quot;^https?://[[:alnum:]_./]+$&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] 1 2</code></pre>
<p>(注意第二个字符串不是合法网址但是按这个正则表达式也能匹配)</p>
</div>
<div id="text-regex-bfuncs-repnum" class="section level3">
<h3><span class="header-section-number">36.5.12</span> 计数重复</h3>
<p>例：</p>
<div class="sourceCode" id="cb3021"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3021-1"><a href="text.html#cb3021-1"></a><span class="kw">grep</span>(<span class="st">&quot;[[:digit:]]{3}&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;12&quot;</span>, <span class="st">&quot;123&quot;</span>, <span class="st">&quot;1234&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 3 4</code></pre>
<p>模式匹配的是三位的数字。</p>
<p>日期匹配例：</p>
<div class="sourceCode" id="cb3023"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3023-1"><a href="text.html#cb3023-1"></a>pat &lt;-<span class="st"> </span><span class="kw">paste</span>(</span>
<span id="cb3023-2"><a href="text.html#cb3023-2"></a>  <span class="kw">c</span>(<span class="st">&quot;[[:digit:]]{1,2}[-/]&quot;</span>,</span>
<span id="cb3023-3"><a href="text.html#cb3023-3"></a>    <span class="st">&quot;[[:digit:]]{1,2}[-/]&quot;</span>,</span>
<span id="cb3023-4"><a href="text.html#cb3023-4"></a>    <span class="st">&quot;[[:digit:]]{2,4}&quot;</span>), <span class="dt">collapse=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb3023-5"><a href="text.html#cb3023-5"></a><span class="kw">grep</span>(pat, <span class="kw">c</span>(<span class="st">&quot;2/4/1998&quot;</span>, <span class="st">&quot;13/15/198&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1 2</code></pre>
</div>
<div id="text-regex-bfuncs-lazy" class="section level3">
<h3><span class="header-section-number">36.5.13</span> 贪婪匹配和懒惰匹配</h3>
<p>例如：</p>
<div class="sourceCode" id="cb3025"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3025-1"><a href="text.html#cb3025-1"></a>s &lt;-<span class="st"> &quot;&lt;B&gt;1st&lt;/B&gt; other &lt;B&gt;2nd&lt;/B&gt;&quot;</span></span>
<span id="cb3025-2"><a href="text.html#cb3025-2"></a>p1 &lt;-<span class="st"> &quot;&lt;[Bb]&gt;.*&lt;/[Bb]&gt;&quot;</span></span>
<span id="cb3025-3"><a href="text.html#cb3025-3"></a>m1 &lt;-<span class="st"> </span><span class="kw">regexpr</span>(p1, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3025-4"><a href="text.html#cb3025-4"></a><span class="kw">regmatches</span>(s, m1)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;&lt;B&gt;1st&lt;/B&gt; other &lt;B&gt;2nd&lt;/B&gt;&quot;</code></pre>
<p>我们本来期望的是提取第一个“<code>&lt;B&gt;</code>……<code>&lt;/B&gt;</code>”组合， 不料提取了两个“<code>&lt;B&gt;</code>……<code>&lt;/B&gt;</code>”组合以及中间的部分。</p>
<p>比如，上例中模式修改后得到了期望的结果：</p>
<div class="sourceCode" id="cb3027"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3027-1"><a href="text.html#cb3027-1"></a>s &lt;-<span class="st"> &quot;&lt;B&gt;1st&lt;/B&gt; other &lt;B&gt;2nd&lt;/B&gt;&quot;</span></span>
<span id="cb3027-2"><a href="text.html#cb3027-2"></a>p2 &lt;-<span class="st"> &quot;&lt;[Bb]&gt;.*?&lt;/[Bb]&gt;&quot;</span></span>
<span id="cb3027-3"><a href="text.html#cb3027-3"></a>m2 &lt;-<span class="st"> </span><span class="kw">regexpr</span>(p2, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3027-4"><a href="text.html#cb3027-4"></a><span class="kw">regmatches</span>(s, m2)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;&lt;B&gt;1st&lt;/B&gt;&quot;</code></pre>
</div>
<div id="text-regex-bfuncs-wordb" class="section level3">
<h3><span class="header-section-number">36.5.14</span> 单词边界</h3>
<p>例：</p>
<div class="sourceCode" id="cb3029"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3029-1"><a href="text.html#cb3029-1"></a><span class="kw">grep</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">bcat</span><span class="ch">\\</span><span class="st">b&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;a cat meaos&quot;</span>, <span class="st">&quot;the category&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
</div>
<div id="text-regex-bfuncs-sm" class="section level3">
<h3><span class="header-section-number">36.5.15</span> 句点全匹配与多行模式</h3>
<p>句点通配符一般不能匹配换行，如</p>
<div class="sourceCode" id="cb3031"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3031-1"><a href="text.html#cb3031-1"></a>s &lt;-<span class="st"> &quot;&lt;B&gt;1st</span><span class="ch">\n</span><span class="st">&lt;/B&gt;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb3031-2"><a href="text.html#cb3031-2"></a><span class="kw">grep</span>(<span class="st">&quot;&lt;[Bb]&gt;.*?&lt;/[Bb]&gt;&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## integer(0)</code></pre>
<p>跨行匹配失败。而在HTML的规范中换行是正常的。
一种办法是预先用<code>gsub</code>把所有换行符替换为空格。
但是这只能解决部分问题。</p>
<p>另一方法是在Perl正则表达式开头添加<code>(?s)</code>选项，
这个选项使得句点通配符可以匹配换行符。
如</p>
<div class="sourceCode" id="cb3033"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3033-1"><a href="text.html#cb3033-1"></a>s &lt;-<span class="st"> &quot;&lt;B&gt;1st</span><span class="ch">\n</span><span class="st">&lt;/B&gt;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb3033-2"><a href="text.html#cb3033-2"></a>mres &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;(?s)&lt;[Bb]&gt;.*?&lt;/[Bb]&gt;&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3033-3"><a href="text.html#cb3033-3"></a><span class="kw">regmatches</span>(s, mres)</span></code></pre></div>
<pre><code>## [1] &quot;&lt;B&gt;1st\n&lt;/B&gt;&quot;</code></pre>
<p>多行模式例：</p>
<div class="sourceCode" id="cb3035"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3035-1"><a href="text.html#cb3035-1"></a>s &lt;-<span class="st"> &quot;&lt;B&gt;1st</span><span class="ch">\n</span><span class="st">&lt;/B&gt;</span><span class="ch">\n</span><span class="st">&quot;</span></span>
<span id="cb3035-2"><a href="text.html#cb3035-2"></a>mres1 &lt;-<span class="st"> </span><span class="kw">gregexpr</span>(<span class="st">&quot;^&lt;.+?&gt;&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3035-3"><a href="text.html#cb3035-3"></a>mres2 &lt;-<span class="st"> </span><span class="kw">gregexpr</span>(<span class="st">&quot;(?m)^&lt;.+?&gt;&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3035-4"><a href="text.html#cb3035-4"></a><span class="kw">regmatches</span>(s, mres1)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;&lt;B&gt;&quot;</code></pre>
<div class="sourceCode" id="cb3037"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3037-1"><a href="text.html#cb3037-1"></a><span class="kw">regmatches</span>(s, mres2)[[<span class="dv">1</span>]]</span></code></pre></div>
<pre><code>## [1] &quot;&lt;B&gt;&quot;  &quot;&lt;/B&gt;&quot;</code></pre>
<p>字符串<code>s</code>包含两行内容，中间用<code>\n</code>分隔。
<code>mres1</code>的匹配模式没有打开多行选项，
所以模式中的<code>^</code>只能匹配<code>s</code>中整个字符串开头。
<code>mres2</code>的匹配模式打开了多行选项，
所以模式中的<code>^</code>可以匹配<code>s</code>中每行的开头。</p>
</div>
<div id="text-regex-bfuncs-alt" class="section level3">
<h3><span class="header-section-number">36.5.16</span> 备择模式</h3>
<p>例如，某个人的名字用James和Jim都可以，
表示为<code>James|Jim</code>, 如</p>
<div class="sourceCode" id="cb3039"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3039-1"><a href="text.html#cb3039-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;James, Bond&quot;</span>, <span class="st">&quot;Jim boy&quot;</span>)</span>
<span id="cb3039-2"><a href="text.html#cb3039-2"></a>pat &lt;-<span class="st"> &quot;James|Jim&quot;</span></span>
<span id="cb3039-3"><a href="text.html#cb3039-3"></a>mres &lt;-<span class="st"> </span><span class="kw">gregexpr</span>(pat, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3039-4"><a href="text.html#cb3039-4"></a><span class="kw">regmatches</span>(s, mres)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;James&quot;
## 
## [[2]]
## [1] &quot;Jim&quot;</code></pre>
</div>
<div id="text-regex-bfuncs-group" class="section level3">
<h3><span class="header-section-number">36.5.17</span> 分组与捕获</h3>
<p>例：
希望把“<code>&lt;B&gt;</code>……<code>&lt;/B</code>”两边的“<code>&lt;B&gt;</code>”和“<code>&lt;/B&gt;</code>”删除，
可以用如下的替换方法：</p>
<div class="sourceCode" id="cb3041"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3041-1"><a href="text.html#cb3041-1"></a>x &lt;-<span class="st"> &quot;&lt;B&gt;1st&lt;/B&gt; other &lt;B&gt;2nd&lt;/B&gt;&quot;</span></span>
<span id="cb3041-2"><a href="text.html#cb3041-2"></a>pat &lt;-<span class="st"> &quot;(?s)&lt;[Bb]&gt;(.+?)&lt;/[Bb]&gt;&quot;</span></span>
<span id="cb3041-3"><a href="text.html#cb3041-3"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb3041-4"><a href="text.html#cb3041-4"></a><span class="kw">gsub</span>(pat, repl, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;1st other 2nd&quot;</code></pre>
<p>替换模式中的<code>\1</code>(写成R字符型常量时<code>\</code>要写成<code>\\</code>)表示第一个圆括号匹配的内容，
但是表示选项的圆括号（<code>(?s)</code>）不算在内。</p>
<p>例：希望把带有前导零的数字的前导零删除，可以用如</p>
<div class="sourceCode" id="cb3043"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3043-1"><a href="text.html#cb3043-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;123&quot;</span>, <span class="st">&quot;0123&quot;</span>, <span class="st">&quot;00123&quot;</span>)</span>
<span id="cb3043-2"><a href="text.html#cb3043-2"></a>pat &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">b0+([1-9][0-9]*)</span><span class="ch">\\</span><span class="st">b&quot;</span></span>
<span id="cb3043-3"><a href="text.html#cb3043-3"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb3043-4"><a href="text.html#cb3043-4"></a><span class="kw">gsub</span>(pat, repl, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;123&quot; &quot;123&quot; &quot;123&quot;</code></pre>
<p>其中的<code>\b</code>模式表示单词边界，
这可以排除在一个没有用空格或标点分隔的字符串内部拆分出数字的情况。</p>
<p>例：为了交换横纵坐标，可以用如下替换</p>
<div class="sourceCode" id="cb3045"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3045-1"><a href="text.html#cb3045-1"></a>s &lt;-<span class="st"> &quot;1st: (5,3.6), 2nd: (2.5, 1.1)&quot;</span></span>
<span id="cb3045-2"><a href="text.html#cb3045-2"></a>pat &lt;-<span class="st"> </span><span class="kw">paste0</span>(</span>
<span id="cb3045-3"><a href="text.html#cb3045-3"></a>  <span class="st">&quot;[(]([[:digit:].]+),&quot;</span>,</span>
<span id="cb3045-4"><a href="text.html#cb3045-4"></a>  <span class="st">&quot;[[:space:]]*([[:digit:].]+)[)]&quot;</span>)</span>
<span id="cb3045-5"><a href="text.html#cb3045-5"></a>repl &lt;-<span class="st"> &quot;(</span><span class="ch">\\</span><span class="st">2, </span><span class="ch">\\</span><span class="st">1)&quot;</span></span>
<span id="cb3045-6"><a href="text.html#cb3045-6"></a><span class="kw">gsub</span>(pat, repl, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;1st: (3.6, 5), 2nd: (1.1, 2.5)&quot;</code></pre>
<p>例如，要匹配yyyy-mm-dd这样的日期，
并将其改写为mm/dd/yyyy，
就可以用这样的替换模式：</p>
<div class="sourceCode" id="cb3047"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3047-1"><a href="text.html#cb3047-1"></a>pat &lt;-<span class="st"> &quot;([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})&quot;</span></span>
<span id="cb3047-2"><a href="text.html#cb3047-2"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">2/</span><span class="ch">\\</span><span class="st">3/</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb3047-3"><a href="text.html#cb3047-3"></a><span class="kw">gsub</span>(pat, repl, <span class="kw">c</span>(<span class="st">&quot;1998-05-31&quot;</span>, <span class="st">&quot;2017-01-14&quot;</span>))</span></code></pre></div>
<pre><code>## [1] &quot;05/31/1998&quot; &quot;01/14/2017&quot;</code></pre>
<p>分组除了可以做替换外，
还可以用来表示模式中的重复出现内容。
例如，<code>([a-z]{3})\1</code>这样的模式可以匹配如<code>abcabc</code>, <code>uxzuxz</code>这样的三字母重复。如</p>
<div class="sourceCode" id="cb3049"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3049-1"><a href="text.html#cb3049-1"></a><span class="kw">grep</span>(<span class="st">&quot;([a-z]{3})</span><span class="ch">\\</span><span class="st">1&quot;</span>, <span class="kw">c</span>(<span class="st">&quot;abcabc&quot;</span>, <span class="st">&quot;aabbcc&quot;</span>))</span></code></pre></div>
<pre><code>## [1] 1</code></pre>
<p>又例如，下面的程序找出了年（后两位）、月、日数字相同的日期：</p>
<div class="sourceCode" id="cb3051"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3051-1"><a href="text.html#cb3051-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;2008-08-08&quot;</span>, <span class="st">&quot;2017-01-18&quot;</span>)</span>
<span id="cb3051-2"><a href="text.html#cb3051-2"></a>m &lt;-<span class="st"> </span><span class="kw">regexpr</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d(</span><span class="ch">\\</span><span class="st">d</span><span class="ch">\\</span><span class="st">d)-</span><span class="ch">\\</span><span class="st">1-</span><span class="ch">\\</span><span class="st">1&quot;</span>, x)</span>
<span id="cb3051-3"><a href="text.html#cb3051-3"></a><span class="kw">regmatches</span>(x, m)</span></code></pre></div>
<pre><code>## [1] &quot;2008-08-08&quot;</code></pre>
<p>下面是一个非捕获分组示例。
设需要把1921-2020之间的世纪号删去，可以用</p>
<div class="sourceCode" id="cb3053"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3053-1"><a href="text.html#cb3053-1"></a>pat &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A(?:19|20)([0-9]{2})</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb3053-2"><a href="text.html#cb3053-2"></a>repl &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb3053-3"><a href="text.html#cb3053-3"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1978&quot;</span>, <span class="st">&quot;2017&quot;</span>, <span class="st">&quot;2035&quot;</span>)</span>
<span id="cb3053-4"><a href="text.html#cb3053-4"></a><span class="kw">gsub</span>(pat, repl, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span></code></pre></div>
<pre><code>## [1] &quot;78&quot; &quot;17&quot; &quot;35&quot;</code></pre>
<p>其中用了非捕获分组使得备择模式<code>19|20</code>优先匹配。
注意模式并没有能保证日期在1921-2020之间。更周密的程序可以写成：</p>
<div class="sourceCode" id="cb3055"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3055-1"><a href="text.html#cb3055-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;1978&quot;</span>, <span class="st">&quot;2017&quot;</span>, <span class="st">&quot;2035&quot;</span>)</span>
<span id="cb3055-2"><a href="text.html#cb3055-2"></a>p1 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A19(2[1-9]|[3-9][0-9])</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb3055-3"><a href="text.html#cb3055-3"></a>r1 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">1&quot;</span></span>
<span id="cb3055-4"><a href="text.html#cb3055-4"></a>p2 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A20([01][0-9]|20)</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb3055-5"><a href="text.html#cb3055-5"></a>x &lt;-<span class="st"> </span><span class="kw">gsub</span>(p1, r1, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3055-6"><a href="text.html#cb3055-6"></a>x &lt;-<span class="st"> </span><span class="kw">gsub</span>(p2, r1, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3055-7"><a href="text.html#cb3055-7"></a>x</span></code></pre></div>
<pre><code>## [1] &quot;78&quot;   &quot;17&quot;   &quot;2035&quot;</code></pre>
</div>
</div>
<div id="text-regexex" class="section level2">
<h2><span class="header-section-number">36.6</span> 正则表达式应用例子</h2>
<div id="text-regexex-pre" class="section level3">
<h3><span class="header-section-number">36.6.1</span> 数据预处理</h3>
<p>在原始数据中，
经常需要审核数据是否合法，
已经把一些常见错误输入自动更正。
这都可以用正则表达式实现。</p>
<div id="text-regexex-pre-trim" class="section level4">
<h4><span class="header-section-number">36.6.1.1</span> 除去字符串开头和结尾的空格</h4>
<p>函数<code>stringr::str_trim()</code>和<code>trimws()</code>可以除去字符串开头与结尾的空格，
也可以仅除去开头或仅除去结尾的空格。</p>
<p>这个任务如果用正则表达式字符串替换函数来编写，可以写成：</p>
<div class="sourceCode" id="cb3057"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3057-1"><a href="text.html#cb3057-1"></a><span class="co">### 把字符串向量x的元素去除首尾的空白。</span></span>
<span id="cb3057-2"><a href="text.html#cb3057-2"></a>strip &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3057-3"><a href="text.html#cb3057-3"></a>  x &lt;-<span class="st"> </span><span class="kw">str_replace_all</span>(x, <span class="st">&quot;^[[:space:]]+&quot;</span>, <span class="st">&quot;&quot;</span>)</span>
<span id="cb3057-4"><a href="text.html#cb3057-4"></a>  x &lt;-<span class="st"> </span><span class="kw">str_replace_all</span>(x, <span class="st">&quot;[[:space:]]+$&quot;</span>, <span class="st">&quot;&quot;</span>)</span>
<span id="cb3057-5"><a href="text.html#cb3057-5"></a>  x</span>
<span id="cb3057-6"><a href="text.html#cb3057-6"></a>}</span></code></pre></div>
<p>或者</p>
<div class="sourceCode" id="cb3058"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3058-1"><a href="text.html#cb3058-1"></a><span class="co">### 把字符串向量x的元素去除首尾的空白。</span></span>
<span id="cb3058-2"><a href="text.html#cb3058-2"></a>strip &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3058-3"><a href="text.html#cb3058-3"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^[[:space:]]+&quot;</span>, <span class="st">&quot;&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3058-4"><a href="text.html#cb3058-4"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[[:space:]]+$&quot;</span>, <span class="st">&quot;&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3058-5"><a href="text.html#cb3058-5"></a>  x</span>
<span id="cb3058-6"><a href="text.html#cb3058-6"></a>}</span></code></pre></div>
<p>这个版本可以除去包括空格在内的所有首尾空白字符。</p>
</div>
<div id="text-regexex-pre-space" class="section level4">
<h4><span class="header-section-number">36.6.1.2</span> 除去字符串向量每个元素中所有空格</h4>
<div class="sourceCode" id="cb3059"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3059-1"><a href="text.html#cb3059-1"></a>compress &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3059-2"><a href="text.html#cb3059-2"></a>  <span class="kw">str_replace_all</span>(x, <span class="st">&quot; &quot;</span>, <span class="st">&quot;&quot;</span>)</span>
<span id="cb3059-3"><a href="text.html#cb3059-3"></a>}</span></code></pre></div>
<p>或者</p>
<div class="sourceCode" id="cb3060"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3060-1"><a href="text.html#cb3060-1"></a>compress &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3060-2"><a href="text.html#cb3060-2"></a>  <span class="kw">gsub</span>(<span class="st">&quot; &quot;</span>, <span class="st">&quot;&quot;</span>, x, <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span>
<span id="cb3060-3"><a href="text.html#cb3060-3"></a>}</span></code></pre></div>
<p>这可以解决<code>"李明"</code>与<code>"李  明"</code>不相等这样的问题。
类似的程序也可以用来把中文的标点替换成英文的标点。</p>
</div>
<div id="text-regexex-pre-datevalid" class="section level4">
<h4><span class="header-section-number">36.6.1.3</span> 判断日期是否合法</h4>
<p>设日期必须为<code>yyyy-mm-dd</code>格式，
年的数字可以是两位、三位、四位，
程序为:</p>
<div class="sourceCode" id="cb3061"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3061-1"><a href="text.html#cb3061-1"></a>is_yyyymmdd &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3061-2"><a href="text.html#cb3061-2"></a>  pyear &lt;-<span class="st"> &quot;([0-9]{2}|[1-9][0-9]{2}|[1-2][0-9]{3})&quot;</span></span>
<span id="cb3061-3"><a href="text.html#cb3061-3"></a>  pmon &lt;-<span class="st"> &quot;([1-9]|0[1-9]|1[0-2])&quot;</span></span>
<span id="cb3061-4"><a href="text.html#cb3061-4"></a>  pday &lt;-<span class="st"> &quot;([1-9]|0[1-9]|1[0-9]|2[0-9]|3[01])&quot;</span></span>
<span id="cb3061-5"><a href="text.html#cb3061-5"></a>  pat &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">A&quot;</span>, pyear, <span class="st">&quot;-&quot;</span>, pmon, <span class="st">&quot;-&quot;</span>, pday, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">Z&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb3061-6"><a href="text.html#cb3061-6"></a>  <span class="kw">str_detect</span>(x, pat)</span>
<span id="cb3061-7"><a href="text.html#cb3061-7"></a>}</span></code></pre></div>
<p>或</p>
<div class="sourceCode" id="cb3062"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3062-1"><a href="text.html#cb3062-1"></a>is.yyyymmdd &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3062-2"><a href="text.html#cb3062-2"></a>  pyear &lt;-<span class="st"> &quot;([0-9]{2}|[1-9][0-9]{2}|[1-2][0-9]{3})&quot;</span></span>
<span id="cb3062-3"><a href="text.html#cb3062-3"></a>  pmon &lt;-<span class="st"> &quot;([1-9]|0[1-9]|1[0-2])&quot;</span></span>
<span id="cb3062-4"><a href="text.html#cb3062-4"></a>  pday &lt;-<span class="st"> &quot;([1-9]|0[1-9]|1[0-9]|2[0-9]|3[01])&quot;</span></span>
<span id="cb3062-5"><a href="text.html#cb3062-5"></a>  pat &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">A&quot;</span>, pyear, <span class="st">&quot;-&quot;</span>, pmon, <span class="st">&quot;-&quot;</span>, pday, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">Z&quot;</span>, <span class="dt">sep=</span><span class="st">&quot;&quot;</span>)</span>
<span id="cb3062-6"><a href="text.html#cb3062-6"></a>  <span class="kw">grepl</span>(pat, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3062-7"><a href="text.html#cb3062-7"></a>}</span></code></pre></div>
<p>这样的规则还没有排除诸如9月31号、2月30号这样的错误。</p>
<p>例:</p>
<div class="sourceCode" id="cb3063"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3063-1"><a href="text.html#cb3063-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;49-10-1&quot;</span>, <span class="st">&quot;1949-10-01&quot;</span>, <span class="st">&quot;532-3-15&quot;</span>, <span class="st">&quot;2015-6-1&quot;</span>, </span>
<span id="cb3063-2"><a href="text.html#cb3063-2"></a>       <span class="st">&quot;2017-02-30&quot;</span>, <span class="st">&quot;2017-13-11&quot;</span>, <span class="st">&quot;2017-1-32&quot;</span>)</span>
<span id="cb3063-3"><a href="text.html#cb3063-3"></a><span class="kw">is_yyyymmdd</span>(x)</span></code></pre></div>
<pre><code>## [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE</code></pre>
<p>注意错误的2月30号没有识别出来。</p>
</div>
<div id="text-regexex-pre-yymmdd" class="section level4">
<h4><span class="header-section-number">36.6.1.4</span> 把字符型日期变成yyyy-mm-dd格式。</h4>
<div class="sourceCode" id="cb3065"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3065-1"><a href="text.html#cb3065-1"></a>make_date &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3065-2"><a href="text.html#cb3065-2"></a>  x <span class="op">%&gt;%</span></span>
<span id="cb3065-3"><a href="text.html#cb3065-3"></a><span class="st">    </span><span class="kw">str_trim</span>() <span class="op">%&gt;%</span></span>
<span id="cb3065-4"><a href="text.html#cb3065-4"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;[[:space:]]+&quot;</span>, <span class="st">&quot;-&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3065-5"><a href="text.html#cb3065-5"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;/&quot;</span>, <span class="st">&quot;-&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3065-6"><a href="text.html#cb3065-6"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;[.]&quot;</span>, <span class="st">&quot;-&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3065-7"><a href="text.html#cb3065-7"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;^([0-9]{2})(-[0-9]{1,2}-[0-9]{1,2})$&quot;</span>, <span class="st">&quot;20</span><span class="ch">\\</span><span class="st">1</span><span class="ch">\\</span><span class="st">2&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3065-8"><a href="text.html#cb3065-8"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;^([0-9]{4})-([0-9])-([0-9]{1,2})$&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1-0</span><span class="ch">\\</span><span class="st">2-</span><span class="ch">\\</span><span class="st">3&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3065-9"><a href="text.html#cb3065-9"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;^([0-9]{4}-[0-9]{2})-([0-9])$&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1-0</span><span class="ch">\\</span><span class="st">2&quot;</span>)</span>
<span id="cb3065-10"><a href="text.html#cb3065-10"></a>}</span></code></pre></div>
<p>或者</p>
<div class="sourceCode" id="cb3066"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3066-1"><a href="text.html#cb3066-1"></a>make.date &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3066-2"><a href="text.html#cb3066-2"></a>  x &lt;-<span class="st"> </span><span class="kw">trimws</span>(x)</span>
<span id="cb3066-3"><a href="text.html#cb3066-3"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[[:space:]]+&quot;</span>, <span class="st">&quot;-&quot;</span>, x)</span>
<span id="cb3066-4"><a href="text.html#cb3066-4"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;/&quot;</span>, <span class="st">&quot;-&quot;</span>, x)</span>
<span id="cb3066-5"><a href="text.html#cb3066-5"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[.]&quot;</span>, <span class="st">&quot;-&quot;</span>, x)</span>
<span id="cb3066-6"><a href="text.html#cb3066-6"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^([0-9]{2})(-[0-9]{1,2}-[0-9]{1,2})$&quot;</span>, <span class="st">&quot;20</span><span class="ch">\\</span><span class="st">1</span><span class="ch">\\</span><span class="st">2&quot;</span>, x)</span>
<span id="cb3066-7"><a href="text.html#cb3066-7"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^([0-9]{4})-([0-9])-([0-9]{1,2})$&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1-0</span><span class="ch">\\</span><span class="st">2-</span><span class="ch">\\</span><span class="st">3&quot;</span>, x)</span>
<span id="cb3066-8"><a href="text.html#cb3066-8"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^([0-9]{4}-[0-9]{2})-([0-9])$&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1-0</span><span class="ch">\\</span><span class="st">2&quot;</span>, x)</span>
<span id="cb3066-9"><a href="text.html#cb3066-9"></a></span>
<span id="cb3066-10"><a href="text.html#cb3066-10"></a>  x</span>
<span id="cb3066-11"><a href="text.html#cb3066-11"></a>}</span></code></pre></div>
<p>另一办法是用<code>strsplit()</code>拆分出三个部分，
转换为整数，
再转换回字符型。</p>
<p>测试:</p>
<div class="sourceCode" id="cb3067"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3067-1"><a href="text.html#cb3067-1"></a>x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;49/10/1&quot;</span>, <span class="st">&quot;1949.10.01&quot;</span>, <span class="st">&quot;532 3 15&quot;</span>, <span class="st">&quot;2015/6.1&quot;</span>, </span>
<span id="cb3067-2"><a href="text.html#cb3067-2"></a>       <span class="st">&quot;20170230&quot;</span>, <span class="st">&quot;2017.13/11&quot;</span>, <span class="st">&quot;2017 1 32&quot;</span>)</span>
<span id="cb3067-3"><a href="text.html#cb3067-3"></a><span class="kw">make_date</span>(x)</span></code></pre></div>
<pre><code>## [1] &quot;2049-10-01&quot; &quot;1949-10-01&quot; &quot;532-3-15&quot;   &quot;2015-06-01&quot; &quot;20170230&quot;  
## [6] &quot;2017-13-11&quot; &quot;2017-01-32&quot;</code></pre>
<p>目前的函数还不能处理没有分隔符的情况，
也不能验证日期的合法性。</p>
</div>
<div id="text-regexex-pre-para" class="section level4">
<h4><span class="header-section-number">36.6.1.5</span> 合并段落为一行</h4>
<p>在某些纯文本格式中，
各段之间用空行分隔，
没有用空行分隔的各行看成同一段。
如下的函数把其中的不表示分段的换行删去从而合并这些段落。
函数以一个文件名作为输入，
合并段落后存回原文件。
注意，
这样修改文件的函数在调试时，
应该注意先备份文件，
等程序没有任何错误以后才可以忽略备份。</p>
<div class="sourceCode" id="cb3069"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3069-1"><a href="text.html#cb3069-1"></a>combine_paragraph &lt;-<span class="st"> </span><span class="cf">function</span>(fname){</span>
<span id="cb3069-2"><a href="text.html#cb3069-2"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(fname) </span>
<span id="cb3069-3"><a href="text.html#cb3069-3"></a>  </span>
<span id="cb3069-4"><a href="text.html#cb3069-4"></a>  s &lt;-<span class="st"> </span><span class="kw">str_flattern</span>(lines)</span>
<span id="cb3069-5"><a href="text.html#cb3069-5"></a>  s &lt;-<span class="st"> </span>s <span class="op">%&gt;%</span></span>
<span id="cb3069-6"><a href="text.html#cb3069-6"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;^[[:space:]]+</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3069-7"><a href="text.html#cb3069-7"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;([^</span><span class="ch">\n</span><span class="st">]+)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1 &quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3069-8"><a href="text.html#cb3069-8"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;([^</span><span class="ch">\n</span><span class="st">]+)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1</span><span class="ch">\n\n</span><span class="st">&quot;</span>)</span>
<span id="cb3069-9"><a href="text.html#cb3069-9"></a>  </span>
<span id="cb3069-10"><a href="text.html#cb3069-10"></a>  <span class="kw">writeLines</span>(<span class="kw">str_split</span>(s, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)[[<span class="dv">1</span>]],</span>
<span id="cb3069-11"><a href="text.html#cb3069-11"></a>             <span class="dt">con=</span>fname)</span>
<span id="cb3069-12"><a href="text.html#cb3069-12"></a>}</span></code></pre></div>
<p>函数首先把仅有空格的行中的空格删除，
将有内容的行的行尾换行符替换成一个空格，
再把剩余的有内容的行的行尾换行符多加一个换行符。</p>
<p>上面的程序中特意用了基本R的<code>readLines()</code>函数而不是readr包的<code>read_lines()</code>函数,
因为<code>readLines()</code>使用操作系统的默认中文编码，
而<code>read_lines()</code>默认使用UTF-8编码，
需要用选项<code>locale=locale(encoding="GB18030")</code>才能在中文MS Windows中正确读取中文文件。</p>
<p>下面的版本不使用stringr：</p>
<div class="sourceCode" id="cb3070"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3070-1"><a href="text.html#cb3070-1"></a>combine.paragraph &lt;-<span class="st"> </span><span class="cf">function</span>(fname){</span>
<span id="cb3070-2"><a href="text.html#cb3070-2"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(fname)</span>
<span id="cb3070-3"><a href="text.html#cb3070-3"></a>  s &lt;-<span class="st"> </span><span class="kw">paste</span>(lines, <span class="dt">collapse=</span><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb3070-4"><a href="text.html#cb3070-4"></a>  s &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;^[[:space:]]+</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3070-5"><a href="text.html#cb3070-5"></a>  s &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;([^</span><span class="ch">\n</span><span class="st">]+)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1 &quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3070-6"><a href="text.html#cb3070-6"></a>  s &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;([^</span><span class="ch">\n</span><span class="st">]+)</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">1</span><span class="ch">\n\n</span><span class="st">&quot;</span>, s, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3070-7"><a href="text.html#cb3070-7"></a>  <span class="kw">writeLines</span>(<span class="kw">strsplit</span>(s, <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>, <span class="dt">fixed=</span><span class="ot">TRUE</span>)[[<span class="dv">1</span>]],</span>
<span id="cb3070-8"><a href="text.html#cb3070-8"></a>             <span class="dt">con=</span>fname)</span>
<span id="cb3070-9"><a href="text.html#cb3070-9"></a>}</span></code></pre></div>
</div>
</div>
<div id="text-regexex-excelmore" class="section level3">
<h3><span class="header-section-number">36.6.2</span> 不规则Excel文件处理</h3>
<ul>
<li>作为字符型数据处理示例， 考察如下的一个Excel表格数据。</li>
</ul>
<p>假设一个中学把所有课外小组的信息汇总到了Excel表的一个工作簿中。
每个课外小组占一块区域，各小组上下排列，
但不能作为一个数据框读取。
下图为这样的文件的一个简化样例：</p>
<div class="figure">
<img src="static/picture/img-multitab.jpg" alt="" />
<p class="caption">不规则Excel文件样例图形</p>
</div>
<p>实际数据可能有很多个小组， 而且数据是随时更新的，
所以复制粘贴另存的方法不太可行，
需要用一个通用的程序处理。
Excel文件(.xls后缀或.xlsx后缀)不是文本型数据。
在Excel中，用“另存为”把文件保存为CSV格式， 内容如下：</p>
<pre><code>XXX中学兴趣组情况总表,,,
,,,
组名：,物理,指导教师：,刘一心
姓名,性别,班级,
伊家宝,男,初二(3),
闻月,女,初二(5),
刘阳,男,初三(1),
宋佰霖,男,初三(2),
洪晓梅,女,初三(1),
,,,
组名：,生物,指导教师：,赵晓辉
姓名,性别,班级,
刘佳琦,女,初二(1),
李雨婷,女,初二(5),
张宠,男,初三(4),</code></pre>
<p>生成测试用的数据文件：</p>
<div class="sourceCode" id="cb3072"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3072-1"><a href="text.html#cb3072-1"></a>demo.multitab.data &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb3072-2"><a href="text.html#cb3072-2"></a>s &lt;-<span class="st"> &quot;</span></span>
<span id="cb3072-3"><a href="text.html#cb3072-3"></a><span class="st">XXX中学兴趣组情况总表,,,</span></span>
<span id="cb3072-4"><a href="text.html#cb3072-4"></a><span class="st">,,,</span></span>
<span id="cb3072-5"><a href="text.html#cb3072-5"></a><span class="st">组名：,物理,指导教师：,刘一心</span></span>
<span id="cb3072-6"><a href="text.html#cb3072-6"></a><span class="st">姓名,性别,班级,</span></span>
<span id="cb3072-7"><a href="text.html#cb3072-7"></a><span class="st">伊家宝,男,初二(3),</span></span>
<span id="cb3072-8"><a href="text.html#cb3072-8"></a><span class="st">闻月,女,初二(5),</span></span>
<span id="cb3072-9"><a href="text.html#cb3072-9"></a><span class="st">刘阳,男,初三(1),</span></span>
<span id="cb3072-10"><a href="text.html#cb3072-10"></a><span class="st">宋佰霖,男,初三(2),</span></span>
<span id="cb3072-11"><a href="text.html#cb3072-11"></a><span class="st">洪晓梅,女,初三(1),</span></span>
<span id="cb3072-12"><a href="text.html#cb3072-12"></a><span class="st">,,,</span></span>
<span id="cb3072-13"><a href="text.html#cb3072-13"></a><span class="st">组名：,生物,指导教师：,赵晓辉</span></span>
<span id="cb3072-14"><a href="text.html#cb3072-14"></a><span class="st">姓名,性别,班级,</span></span>
<span id="cb3072-15"><a href="text.html#cb3072-15"></a><span class="st">刘佳琦,女,初二(1),</span></span>
<span id="cb3072-16"><a href="text.html#cb3072-16"></a><span class="st">李雨婷,女,初二(5),</span></span>
<span id="cb3072-17"><a href="text.html#cb3072-17"></a><span class="st">张宠,男,初三(4),</span></span>
<span id="cb3072-18"><a href="text.html#cb3072-18"></a><span class="st">&quot;</span></span>
<span id="cb3072-19"><a href="text.html#cb3072-19"></a><span class="kw">writeLines</span>(s, <span class="st">&quot;multitab.csv&quot;</span>)</span>
<span id="cb3072-20"><a href="text.html#cb3072-20"></a>}</span>
<span id="cb3072-21"><a href="text.html#cb3072-21"></a><span class="kw">demo.multitab.data</span>()</span></code></pre></div>
<p>读入测试用的数据，转换为一整个数据框:</p>
<div class="sourceCode" id="cb3073"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3073-1"><a href="text.html#cb3073-1"></a>demo_multitab &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb3073-2"><a href="text.html#cb3073-2"></a>  <span class="co">## 读入所有行</span></span>
<span id="cb3073-3"><a href="text.html#cb3073-3"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="st">&quot;multitab.csv&quot;</span>)</span>
<span id="cb3073-4"><a href="text.html#cb3073-4"></a></span>
<span id="cb3073-5"><a href="text.html#cb3073-5"></a>  <span class="co">## 去掉首尾空格</span></span>
<span id="cb3073-6"><a href="text.html#cb3073-6"></a>  lines &lt;-<span class="st"> </span><span class="kw">str_trim</span>(lines)</span>
<span id="cb3073-7"><a href="text.html#cb3073-7"></a>  </span>
<span id="cb3073-8"><a href="text.html#cb3073-8"></a>  <span class="co">## 删去所有空行和只有逗号的行</span></span>
<span id="cb3073-9"><a href="text.html#cb3073-9"></a>  empty &lt;-<span class="st"> </span><span class="kw">str_detect</span>(lines, <span class="st">&quot;^[[:space:],]*$&quot;</span>)</span>
<span id="cb3073-10"><a href="text.html#cb3073-10"></a>  <span class="cf">if</span>(<span class="kw">length</span>(empty)<span class="op">&gt;</span><span class="dv">0</span>){</span>
<span id="cb3073-11"><a href="text.html#cb3073-11"></a>    lines &lt;-<span class="st"> </span>lines[<span class="op">!</span>empty]</span>
<span id="cb3073-12"><a href="text.html#cb3073-12"></a>  }</span>
<span id="cb3073-13"><a href="text.html#cb3073-13"></a></span>
<span id="cb3073-14"><a href="text.html#cb3073-14"></a>  <span class="co">## 找到所有包含 “组名：”的行对应的行号</span></span>
<span id="cb3073-15"><a href="text.html#cb3073-15"></a>  heads &lt;-<span class="st"> </span><span class="kw">str_which</span>(lines, <span class="st">&quot;组名：&quot;</span>)</span>
<span id="cb3073-16"><a href="text.html#cb3073-16"></a></span>
<span id="cb3073-17"><a href="text.html#cb3073-17"></a>  <span class="co">## 定位每个表的开始行和结束行(不包括组名和表头所在的行)</span></span>
<span id="cb3073-18"><a href="text.html#cb3073-18"></a>  start &lt;-<span class="st"> </span>heads <span class="op">+</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb3073-19"><a href="text.html#cb3073-19"></a>  end &lt;-<span class="st"> </span><span class="kw">c</span>(heads[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>, <span class="kw">length</span>(lines))</span>
<span id="cb3073-20"><a href="text.html#cb3073-20"></a>  ngroups &lt;-<span class="st"> </span><span class="kw">length</span>(heads)</span>
<span id="cb3073-21"><a href="text.html#cb3073-21"></a></span>
<span id="cb3073-22"><a href="text.html#cb3073-22"></a>  <span class="co">## 先把数据读入一个列表。</span></span>
<span id="cb3073-23"><a href="text.html#cb3073-23"></a>  <span class="cf">for</span>(ii <span class="cf">in</span> <span class="kw">seq</span>(ngroups)){</span>
<span id="cb3073-24"><a href="text.html#cb3073-24"></a>    <span class="co">## 组名和指导教师所在行：</span></span>
<span id="cb3073-25"><a href="text.html#cb3073-25"></a>    line &lt;-<span class="st"> </span>lines[heads[ii]]</span>
<span id="cb3073-26"><a href="text.html#cb3073-26"></a>    v &lt;-<span class="st"> </span><span class="kw">str_split</span>(line, <span class="st">&quot;,&quot;</span>)[[<span class="dv">1</span>]]</span>
<span id="cb3073-27"><a href="text.html#cb3073-27"></a>    <span class="co">## 组名：v[2] 指导教师: v[4]</span></span>
<span id="cb3073-28"><a href="text.html#cb3073-28"></a></span>
<span id="cb3073-29"><a href="text.html#cb3073-29"></a>    <span class="co">## 将表格内容各行合并成一个用换行符分隔的长字符串，</span></span>
<span id="cb3073-30"><a href="text.html#cb3073-30"></a>    <span class="co">## 然后变成可读取的文件</span></span>
<span id="cb3073-31"><a href="text.html#cb3073-31"></a>    s &lt;-<span class="st"> </span><span class="kw">str_flatten</span>(lines[start[ii]<span class="op">:</span>end[ii]], <span class="dt">collapse=</span><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb3073-32"><a href="text.html#cb3073-32"></a>    con &lt;-<span class="st"> </span><span class="kw">textConnection</span>(s, <span class="st">&quot;rt&quot;</span>)</span>
<span id="cb3073-33"><a href="text.html#cb3073-33"></a>    da1 &lt;-<span class="st"> </span><span class="kw">read.csv</span>(</span>
<span id="cb3073-34"><a href="text.html#cb3073-34"></a>      con, <span class="dt">header=</span><span class="ot">FALSE</span>, </span>
<span id="cb3073-35"><a href="text.html#cb3073-35"></a>      <span class="dt">colClasses=</span><span class="kw">c</span>(<span class="st">&quot;character&quot;</span>, <span class="st">&quot;character&quot;</span>, <span class="st">&quot;character&quot;</span>, <span class="st">&quot;NULL&quot;</span>))</span>
<span id="cb3073-36"><a href="text.html#cb3073-36"></a>    <span class="kw">close</span>(con)</span>
<span id="cb3073-37"><a href="text.html#cb3073-37"></a>    <span class="kw">names</span>(da1) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;姓名&quot;</span>, <span class="st">&quot;性别&quot;</span>, <span class="st">&quot;班级&quot;</span>)</span>
<span id="cb3073-38"><a href="text.html#cb3073-38"></a>    da1 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="st">&quot;组名&quot;</span>=v[<span class="dv">2</span>], <span class="st">&quot;指导教师&quot;</span>=v[<span class="dv">4</span>], da1)</span>
<span id="cb3073-39"><a href="text.html#cb3073-39"></a></span>
<span id="cb3073-40"><a href="text.html#cb3073-40"></a>    <span class="cf">if</span>(ii<span class="op">==</span><span class="dv">1</span>) {</span>
<span id="cb3073-41"><a href="text.html#cb3073-41"></a>      da &lt;-<span class="st"> </span>da1</span>
<span id="cb3073-42"><a href="text.html#cb3073-42"></a>    } <span class="cf">else</span> {</span>
<span id="cb3073-43"><a href="text.html#cb3073-43"></a>      da &lt;-<span class="st"> </span><span class="kw">rbind</span>(da, da1)</span>
<span id="cb3073-44"><a href="text.html#cb3073-44"></a>    }</span>
<span id="cb3073-45"><a href="text.html#cb3073-45"></a>  }</span>
<span id="cb3073-46"><a href="text.html#cb3073-46"></a></span>
<span id="cb3073-47"><a href="text.html#cb3073-47"></a>  da</span>
<span id="cb3073-48"><a href="text.html#cb3073-48"></a>}</span>
<span id="cb3073-49"><a href="text.html#cb3073-49"></a>da &lt;-<span class="st"> </span><span class="kw">demo_multitab</span>()</span>
<span id="cb3073-50"><a href="text.html#cb3073-50"></a>knitr<span class="op">::</span><span class="kw">kable</span>(da)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">组名</th>
<th align="left">指导教师</th>
<th align="left">姓名</th>
<th align="left">性别</th>
<th align="left">班级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">物理</td>
<td align="left">刘一心</td>
<td align="left">伊家宝</td>
<td align="left">男</td>
<td align="left">初二(3)</td>
</tr>
<tr class="even">
<td align="left">物理</td>
<td align="left">刘一心</td>
<td align="left">闻月</td>
<td align="left">女</td>
<td align="left">初二(5)</td>
</tr>
<tr class="odd">
<td align="left">物理</td>
<td align="left">刘一心</td>
<td align="left">刘阳</td>
<td align="left">男</td>
<td align="left">初三(1)</td>
</tr>
<tr class="even">
<td align="left">物理</td>
<td align="left">刘一心</td>
<td align="left">宋佰霖</td>
<td align="left">男</td>
<td align="left">初三(2)</td>
</tr>
<tr class="odd">
<td align="left">物理</td>
<td align="left">刘一心</td>
<td align="left">洪晓梅</td>
<td align="left">女</td>
<td align="left">初三(1)</td>
</tr>
<tr class="even">
<td align="left">生物</td>
<td align="left">赵晓辉</td>
<td align="left">刘佳琦</td>
<td align="left">女</td>
<td align="left">初二(1)</td>
</tr>
<tr class="odd">
<td align="left">生物</td>
<td align="left">赵晓辉</td>
<td align="left">李雨婷</td>
<td align="left">女</td>
<td align="left">初二(5)</td>
</tr>
<tr class="even">
<td align="left">生物</td>
<td align="left">赵晓辉</td>
<td align="left">张宠</td>
<td align="left">男</td>
<td align="left">初三(4)</td>
</tr>
</tbody>
</table>
<p>不使用stringr的版本：</p>
<div class="sourceCode" id="cb3074"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3074-1"><a href="text.html#cb3074-1"></a>demo.multitab &lt;-<span class="st"> </span><span class="cf">function</span>(){</span>
<span id="cb3074-2"><a href="text.html#cb3074-2"></a>  <span class="co">## 读入所有行</span></span>
<span id="cb3074-3"><a href="text.html#cb3074-3"></a>  lines &lt;-<span class="st"> </span><span class="kw">readLines</span>(<span class="st">&quot;multitab.csv&quot;</span>)</span>
<span id="cb3074-4"><a href="text.html#cb3074-4"></a></span>
<span id="cb3074-5"><a href="text.html#cb3074-5"></a>  <span class="co">## 去掉首尾空格</span></span>
<span id="cb3074-6"><a href="text.html#cb3074-6"></a>  lines &lt;-<span class="st"> </span><span class="kw">trimws</span>(lines)</span>
<span id="cb3074-7"><a href="text.html#cb3074-7"></a>  </span>
<span id="cb3074-8"><a href="text.html#cb3074-8"></a>  <span class="co">## 删去所有空行和只有逗号的行</span></span>
<span id="cb3074-9"><a href="text.html#cb3074-9"></a>  <span class="co">## (1) 不用正则表达式做法</span></span>
<span id="cb3074-10"><a href="text.html#cb3074-10"></a>  <span class="co">#empty &lt;- which(lines == &quot;&quot; | substring(lines, 1, 3)==&quot;,,,&quot;)</span></span>
<span id="cb3074-11"><a href="text.html#cb3074-11"></a>  <span class="co">## (2) 用正则表达式做法：</span></span>
<span id="cb3074-12"><a href="text.html#cb3074-12"></a>  empty &lt;-<span class="st"> </span><span class="kw">grep</span>(<span class="st">&quot;^[[:space:],]*$&quot;</span>, lines)</span>
<span id="cb3074-13"><a href="text.html#cb3074-13"></a>  <span class="cf">if</span>(<span class="kw">length</span>(empty)<span class="op">&gt;</span><span class="dv">0</span>){</span>
<span id="cb3074-14"><a href="text.html#cb3074-14"></a>    lines &lt;-<span class="st"> </span>lines[<span class="op">-</span>empty]</span>
<span id="cb3074-15"><a href="text.html#cb3074-15"></a>  }</span>
<span id="cb3074-16"><a href="text.html#cb3074-16"></a></span>
<span id="cb3074-17"><a href="text.html#cb3074-17"></a>  <span class="co">## 找到所有包含 “组名：”的行对应的行号</span></span>
<span id="cb3074-18"><a href="text.html#cb3074-18"></a>  heads &lt;-<span class="st"> </span><span class="kw">grep</span>(<span class="st">&quot;组名：&quot;</span>, lines, <span class="dt">fixed=</span><span class="ot">TRUE</span>)</span>
<span id="cb3074-19"><a href="text.html#cb3074-19"></a></span>
<span id="cb3074-20"><a href="text.html#cb3074-20"></a>  <span class="co">## 定位每个表的开始行和结束行(不包括组名和表头所在的行)</span></span>
<span id="cb3074-21"><a href="text.html#cb3074-21"></a>  start &lt;-<span class="st"> </span>heads <span class="op">+</span><span class="st"> </span><span class="dv">2</span></span>
<span id="cb3074-22"><a href="text.html#cb3074-22"></a>  end &lt;-<span class="st"> </span><span class="kw">c</span>(heads[<span class="op">-</span><span class="dv">1</span>]<span class="op">-</span><span class="dv">1</span>, <span class="kw">length</span>(lines))</span>
<span id="cb3074-23"><a href="text.html#cb3074-23"></a>  ngroups &lt;-<span class="st"> </span><span class="kw">length</span>(heads)</span>
<span id="cb3074-24"><a href="text.html#cb3074-24"></a></span>
<span id="cb3074-25"><a href="text.html#cb3074-25"></a>  <span class="co">## 先把数据读入一个列表。</span></span>
<span id="cb3074-26"><a href="text.html#cb3074-26"></a>  <span class="cf">for</span>(ii <span class="cf">in</span> <span class="kw">seq</span>(ngroups)){</span>
<span id="cb3074-27"><a href="text.html#cb3074-27"></a>    <span class="co">## 组名和指导教师所在行：</span></span>
<span id="cb3074-28"><a href="text.html#cb3074-28"></a>    line &lt;-<span class="st"> </span>lines[heads[ii]]</span>
<span id="cb3074-29"><a href="text.html#cb3074-29"></a>    v &lt;-<span class="st"> </span><span class="kw">strsplit</span>(line, <span class="st">&quot;,&quot;</span>)[[<span class="dv">1</span>]]</span>
<span id="cb3074-30"><a href="text.html#cb3074-30"></a>    <span class="co">## 组名：v[2] 指导教师: v[4]</span></span>
<span id="cb3074-31"><a href="text.html#cb3074-31"></a></span>
<span id="cb3074-32"><a href="text.html#cb3074-32"></a>    <span class="co">## 将表格内容各行合并成一个用换行符分隔的长字符串，</span></span>
<span id="cb3074-33"><a href="text.html#cb3074-33"></a>    <span class="co">## 然后变成可读取的文件</span></span>
<span id="cb3074-34"><a href="text.html#cb3074-34"></a>    s &lt;-<span class="st"> </span><span class="kw">paste</span>(lines[start[ii]<span class="op">:</span>end[ii]], <span class="dt">collapse=</span><span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)</span>
<span id="cb3074-35"><a href="text.html#cb3074-35"></a>    con &lt;-<span class="st"> </span><span class="kw">textConnection</span>(s, <span class="st">&quot;rt&quot;</span>)</span>
<span id="cb3074-36"><a href="text.html#cb3074-36"></a>    da1 &lt;-<span class="st"> </span><span class="kw">read.csv</span>(</span>
<span id="cb3074-37"><a href="text.html#cb3074-37"></a>      con, <span class="dt">header=</span><span class="ot">FALSE</span>, </span>
<span id="cb3074-38"><a href="text.html#cb3074-38"></a>      <span class="dt">colClasses=</span><span class="kw">c</span>(<span class="st">&quot;character&quot;</span>, <span class="st">&quot;character&quot;</span>, <span class="st">&quot;character&quot;</span>, <span class="st">&quot;NULL&quot;</span>))</span>
<span id="cb3074-39"><a href="text.html#cb3074-39"></a>    <span class="kw">close</span>(con)</span>
<span id="cb3074-40"><a href="text.html#cb3074-40"></a>    <span class="kw">names</span>(da1) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;姓名&quot;</span>, <span class="st">&quot;性别&quot;</span>, <span class="st">&quot;班级&quot;</span>)</span>
<span id="cb3074-41"><a href="text.html#cb3074-41"></a>    da1 &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="st">&quot;组名&quot;</span>=v[<span class="dv">2</span>], <span class="st">&quot;指导教师&quot;</span>=v[<span class="dv">4</span>], da1)</span>
<span id="cb3074-42"><a href="text.html#cb3074-42"></a></span>
<span id="cb3074-43"><a href="text.html#cb3074-43"></a>    <span class="cf">if</span>(ii<span class="op">==</span><span class="dv">1</span>) {</span>
<span id="cb3074-44"><a href="text.html#cb3074-44"></a>      da &lt;-<span class="st"> </span>da1</span>
<span id="cb3074-45"><a href="text.html#cb3074-45"></a>    } <span class="cf">else</span> {</span>
<span id="cb3074-46"><a href="text.html#cb3074-46"></a>      da &lt;-<span class="st"> </span><span class="kw">rbind</span>(da, da1)</span>
<span id="cb3074-47"><a href="text.html#cb3074-47"></a>    }</span>
<span id="cb3074-48"><a href="text.html#cb3074-48"></a>  }</span>
<span id="cb3074-49"><a href="text.html#cb3074-49"></a></span>
<span id="cb3074-50"><a href="text.html#cb3074-50"></a>  da</span>
<span id="cb3074-51"><a href="text.html#cb3074-51"></a>}</span>
<span id="cb3074-52"><a href="text.html#cb3074-52"></a>da &lt;-<span class="st"> </span><span class="kw">demo.multitab</span>()</span>
<span id="cb3074-53"><a href="text.html#cb3074-53"></a>da</span></code></pre></div>
<p>在程序中，
用<code>readLines</code>函数读取文本文件各行到一个字符型向量。
用<code>grep</code>可以找到每个小组开头的行（有“组名：”的行）。
然后可以找出每个小组学生名单的开始行号和结束行号。
各小组循环处理，读入后每个小组并入结果数据框中。
用<code>strsplit</code>函数拆分用逗号分开的数据项。
用<code>textConnection</code>函数可以把一个字符串当作文件读取，
这样<code>read.csv</code>函数可以从一个字符串读入数据。</p>
</div>
<div id="text-regexex-wordfreq" class="section level3">
<h3><span class="header-section-number">36.6.3</span> 字频统计</h3>
<p>正则表达式中的字符类<code>[:alpha:]</code>指的是当前系统中的字母，
所以在中文环境中的中文字也是字母，
但中文标点不算。
下面是《红楼梦》中“秋窗风雨夕”的文本：</p>
<pre><code>秋花惨淡秋草黄，耿耿秋灯秋夜长。
已觉秋窗秋不尽，那堪风雨助凄凉！
助秋风雨来何速！惊破秋窗秋梦绿。
抱得秋情不忍眠，自向秋屏移泪烛。
泪烛摇摇爇短檠，牵愁照恨动离情。
谁家秋院无风入？何处秋窗无雨声？
罗衾不奈秋风力，残漏声催秋雨急。
连宵脉脉复飕飕，灯前似伴离人泣。
寒烟小院转萧条，疏竹虚窗时滴沥。
不知风雨几时休，已教泪洒窗纱湿。</code></pre>
<p>希望统计每个字的出现次数，
并显示频数前十的字。
设变量<code>poem_autumnwindow</code>中包含了上述诗词的文本。</p>
<p>首先用<code>str_extract_all()</code>提取每个中文字，组成一个字符型向量：</p>
<div class="sourceCode" id="cb3076"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3076-1"><a href="text.html#cb3076-1"></a>words_vec &lt;-<span class="st"> </span><span class="kw">str_extract_all</span>(poem_autumnwindow, <span class="st">&quot;[[:alpha:]]&quot;</span>)[[<span class="dv">1</span>]]</span>
<span id="cb3076-2"><a href="text.html#cb3076-2"></a><span class="kw">head</span>(words_vec)</span></code></pre></div>
<pre><code>## [1] &quot;秋&quot; &quot;花&quot; &quot;惨&quot; &quot;淡&quot; &quot;秋&quot; &quot;草&quot;</code></pre>
<p>用<code>table()</code>函数计算频数，并按频数排序，输出前10结果：</p>
<div class="sourceCode" id="cb3078"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3078-1"><a href="text.html#cb3078-1"></a>words_freq &lt;-<span class="st"> </span><span class="kw">sort</span>(<span class="kw">table</span>(words_vec), <span class="dt">decreasing=</span><span class="ot">TRUE</span>)</span>
<span id="cb3078-2"><a href="text.html#cb3078-2"></a>knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">head</span>(words_freq, <span class="dv">10</span>))</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">words_vec</th>
<th align="right">Freq</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">秋</td>
<td align="right">15</td>
</tr>
<tr class="even">
<td align="left">窗</td>
<td align="right">5</td>
</tr>
<tr class="odd">
<td align="left">风</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="left">雨</td>
<td align="right">5</td>
</tr>
<tr class="odd">
<td align="left">不</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td align="left">泪</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="left">灯</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">耿</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="left">何</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="left">离</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
</div>
<div id="text-regexex-digits" class="section level3">
<h3><span class="header-section-number">36.6.4</span> 数字验证</h3>
<div id="text-regexex-digits-int" class="section level4">
<h4><span class="header-section-number">36.6.4.1</span> 整数</h4>
<p>字符串完全为十进制正整数的模式，写成R字符型常量：</p>
<div class="sourceCode" id="cb3079"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3079-1"><a href="text.html#cb3079-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[0-9]+</span><span class="ch">\\</span><span class="st">Z&quot;</span></span></code></pre></div>
<p>这个模式也允许正整数以0开始，如果不允许以零开始，可以写成</p>
<div class="sourceCode" id="cb3080"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3080-1"><a href="text.html#cb3080-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[1-9][0-9]*</span><span class="ch">\\</span><span class="st">Z&quot;</span></span></code></pre></div>
<p>对于一般的整数，字符串完全为十进制整数，但是允许前后有空格，
正负号与数字之间允许有空格，模式可以写成：</p>
<div class="sourceCode" id="cb3081"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3081-1"><a href="text.html#cb3081-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[ ]*[+-]?[ ]*[1-9][0-9]*</span><span class="ch">\\</span><span class="st">Z&quot;</span></span></code></pre></div>
</div>
<div id="text-regexex-digits-hex" class="section level4">
<h4><span class="header-section-number">36.6.4.2</span> 十六进制数字</h4>
<p>字符串仅有十六进制数字，模式写成R字符型常量为</p>
<div class="sourceCode" id="cb3082"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3082-1"><a href="text.html#cb3082-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[0-9A-Fa-f]+</span><span class="ch">\\</span><span class="st">Z&quot;</span></span></code></pre></div>
<p>在文中匹配带有<code>0x</code>前缀的十六进制数字，模式为</p>
<div class="sourceCode" id="cb3083"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3083-1"><a href="text.html#cb3083-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b0x[0-9A-Fa-f]+</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
</div>
<div id="text-regexex-digits-bin" class="section level4">
<h4><span class="header-section-number">36.6.4.3</span> 二进制数字</h4>
<p>为了在文中匹配一个以<code>B</code>或<code>b</code>结尾的二进制非负整数，可以用</p>
<div class="sourceCode" id="cb3084"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3084-1"><a href="text.html#cb3084-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b[01]+[Bb]</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
</div>
<div id="text-regexex-digits-intb" class="section level4">
<h4><span class="header-section-number">36.6.4.4</span> 有范围的整数</h4>
<p>1-12:</p>
<div class="sourceCode" id="cb3085"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3085-1"><a href="text.html#cb3085-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b1[012]|[1-9]</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
<p>1-24:</p>
<div class="sourceCode" id="cb3086"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3086-1"><a href="text.html#cb3086-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b2[0-4]|1[0-9]|[1-9]</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
<p>1-31:</p>
<div class="sourceCode" id="cb3087"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3087-1"><a href="text.html#cb3087-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b3[01]|[12][0-9]|[1-9]</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
<p>1900-2099:</p>
<div class="sourceCode" id="cb3088"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3088-1"><a href="text.html#cb3088-1"></a><span class="st">&quot;</span><span class="ch">\\</span><span class="st">b(?:19|20)[0-9]{2}</span><span class="ch">\\</span><span class="st">b&quot;</span></span></code></pre></div>
<p>这里的分组仅用于在19和20之间选择，
不需要捕获，所以用了<code>(?:</code>的非捕获分组格式。</p>
</div>
<div id="text-regexex-isnum" class="section level4">
<h4><span class="header-section-number">36.6.4.5</span> 判断字符型向量每个元素是否数值</h4>
<p>如下的R函数用了多种数字的正则表达式来判断字符型向量每个元素是否合法数值。</p>
<div class="sourceCode" id="cb3089"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3089-1"><a href="text.html#cb3089-1"></a>all_numbers &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3089-2"><a href="text.html#cb3089-2"></a>  x &lt;-<span class="st"> </span>x <span class="op">%&gt;%</span></span>
<span id="cb3089-3"><a href="text.html#cb3089-3"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[ ]+&quot;</span>, <span class="st">&quot;&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3089-4"><a href="text.html#cb3089-4"></a><span class="st">    </span><span class="kw">str_replace_all</span>(<span class="st">&quot;[ ]+</span><span class="ch">\\</span><span class="st">Z&quot;</span>, <span class="st">&quot;&quot;</span>)</span>
<span id="cb3089-5"><a href="text.html#cb3089-5"></a></span>
<span id="cb3089-6"><a href="text.html#cb3089-6"></a>  pint &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[0-9]+</span><span class="ch">\\</span><span class="st">Z&quot;</span>  <span class="co"># 整数, 允许有前导零</span></span>
<span id="cb3089-7"><a href="text.html#cb3089-7"></a>  <span class="co">## 浮点数1, 整数部分必须，小数部分可选，指数部分可选</span></span>
<span id="cb3089-8"><a href="text.html#cb3089-8"></a>  pf1 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[0-9]+([.][0-9]*)?([Ee][+-]?[0-9]+)?</span><span class="ch">\\</span><span class="st">Z&quot;</span> </span>
<span id="cb3089-9"><a href="text.html#cb3089-9"></a>  <span class="co">## 浮点数2, 整数部分省略，小数部分必须，指数部分可选</span></span>
<span id="cb3089-10"><a href="text.html#cb3089-10"></a>  pf2 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[.][0-9]+([Ee][+-]?[0-9]+)?</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb3089-11"><a href="text.html#cb3089-11"></a>  pat &lt;-<span class="st"> </span><span class="kw">str_c</span>(pint, pf1, pf2, <span class="dt">sep=</span><span class="st">&quot;|&quot;</span>)</span>
<span id="cb3089-12"><a href="text.html#cb3089-12"></a>  </span>
<span id="cb3089-13"><a href="text.html#cb3089-13"></a>  <span class="kw">str_detect</span>(x, pat)</span>
<span id="cb3089-14"><a href="text.html#cb3089-14"></a>}</span></code></pre></div>
<p>不使用stringr的版本：</p>
<div class="sourceCode" id="cb3090"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3090-1"><a href="text.html#cb3090-1"></a>all.numbers &lt;-<span class="st"> </span><span class="cf">function</span>(x){</span>
<span id="cb3090-2"><a href="text.html#cb3090-2"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;</span><span class="ch">\\</span><span class="st">A[ ]+&quot;</span>, <span class="st">&quot;&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3090-3"><a href="text.html#cb3090-3"></a>  x &lt;-<span class="st"> </span><span class="kw">gsub</span>(<span class="st">&quot;[ ]+</span><span class="ch">\\</span><span class="st">Z&quot;</span>, <span class="st">&quot;&quot;</span>, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3090-4"><a href="text.html#cb3090-4"></a></span>
<span id="cb3090-5"><a href="text.html#cb3090-5"></a>  pint &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[0-9]+</span><span class="ch">\\</span><span class="st">Z&quot;</span>  <span class="co"># 整数, 允许有前导零</span></span>
<span id="cb3090-6"><a href="text.html#cb3090-6"></a>  <span class="co">## 浮点数1, 整数部分必须，小数部分可选，指数部分可选</span></span>
<span id="cb3090-7"><a href="text.html#cb3090-7"></a>  pf1 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[0-9]+([.][0-9]*)?([Ee][+-]?[0-9]+)?</span><span class="ch">\\</span><span class="st">Z&quot;</span> </span>
<span id="cb3090-8"><a href="text.html#cb3090-8"></a>  <span class="co">## 浮点数2, 整数部分省略，小数部分必须，指数部分可选</span></span>
<span id="cb3090-9"><a href="text.html#cb3090-9"></a>  pf2 &lt;-<span class="st"> &quot;</span><span class="ch">\\</span><span class="st">A[+-]?[.][0-9]+([Ee][+-]?[0-9]+)?</span><span class="ch">\\</span><span class="st">Z&quot;</span></span>
<span id="cb3090-10"><a href="text.html#cb3090-10"></a>  pat &lt;-<span class="st"> </span><span class="kw">paste</span>(pint, pf1, pf2, <span class="dt">sep=</span><span class="st">&quot;|&quot;</span>)</span>
<span id="cb3090-11"><a href="text.html#cb3090-11"></a>  <span class="kw">grepl</span>(pat, x, <span class="dt">perl=</span><span class="ot">TRUE</span>)</span>
<span id="cb3090-12"><a href="text.html#cb3090-12"></a>}</span></code></pre></div>
<p>测试：</p>
<div class="sourceCode" id="cb3091"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3091-1"><a href="text.html#cb3091-1"></a><span class="kw">all_numbers</span>(<span class="kw">c</span>(<span class="st">&quot;1&quot;</span>, <span class="st">&quot;12&quot;</span>, <span class="st">&quot;-12&quot;</span>, <span class="st">&quot;12.&quot;</span>, <span class="st">&quot;-12.&quot;</span>,</span>
<span id="cb3091-2"><a href="text.html#cb3091-2"></a>              <span class="st">&quot;123.45&quot;</span>, <span class="st">&quot;-123.45&quot;</span>, <span class="st">&quot;.45&quot;</span>, <span class="st">&quot;-.45&quot;</span>,</span>
<span id="cb3091-3"><a href="text.html#cb3091-3"></a>              <span class="st">&quot;1E3&quot;</span>, <span class="st">&quot;-12E-10&quot;</span>, <span class="st">&quot;1.1E3&quot;</span>, <span class="st">&quot;-1.1E-3&quot;</span>,</span>
<span id="cb3091-4"><a href="text.html#cb3091-4"></a>              <span class="st">&quot;1.0.0&quot;</span>, <span class="st">&quot;1.0-0.5&quot;</span>))</span></code></pre></div>
<pre><code>##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [13]  TRUE FALSE FALSE</code></pre>
</div>
</div>
<div id="text-regexex-digfn" class="section level3">
<h3><span class="header-section-number">36.6.5</span> 文件名中的数字提取</h3>
<p>设有如下的一些文件名：</p>
<div class="sourceCode" id="cb3093"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3093-1"><a href="text.html#cb3093-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;10-0.16-1700.0-42.csv&quot;</span>, <span class="st">&quot;12-0.22-1799.1.csv&quot;</span>)</span></code></pre></div>
<p>希望提取出每个文件名中用减号分隔开的数字，
如第一个文件名中的10, 0.16, 1700.0, 42,
第二个文件名中的12, 0.22, 1799.1，
数字的个数不需要相同。</p>
<p>先定义数字的模式，
注意长备择模式中长的模式要写在前面，
否则会被短的模式优先匹配：</p>
<div class="sourceCode" id="cb3094"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3094-1"><a href="text.html#cb3094-1"></a>pat &lt;-<span class="st"> &quot;[0-9]+[.][0-9]+|[0-9]+&quot;</span></span></code></pre></div>
<p>用<code>stringr::str_match_all()</code>提取其中的匹配数字：</p>
<div class="sourceCode" id="cb3095"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3095-1"><a href="text.html#cb3095-1"></a>s1 &lt;-<span class="st"> </span><span class="kw">str_match_all</span>(s, pat); s1</span></code></pre></div>
<pre><code>## [[1]]
##      [,1]    
## [1,] &quot;10&quot;    
## [2,] &quot;0.16&quot;  
## [3,] &quot;1700.0&quot;
## [4,] &quot;42&quot;    
## 
## [[2]]
##      [,1]    
## [1,] &quot;12&quot;    
## [2,] &quot;0.22&quot;  
## [3,] &quot;1799.1&quot;</code></pre>
<p>每个列表元素是一个矩阵，
其中第一列的各行是对模式的多次匹配，
取出这些匹配为一个字符型向量：</p>
<div class="sourceCode" id="cb3097"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3097-1"><a href="text.html#cb3097-1"></a>s2 &lt;-<span class="st"> </span><span class="kw">Map</span>(<span class="cf">function</span>(x) x[,<span class="dv">1</span>], s1); s2</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;10&quot;     &quot;0.16&quot;   &quot;1700.0&quot; &quot;42&quot;    
## 
## [[2]]
## [1] &quot;12&quot;     &quot;0.22&quot;   &quot;1799.1&quot;</code></pre>
<p>如果需要，也可以将拆分出的字符型的数字结果转换成数值型：</p>
<div class="sourceCode" id="cb3099"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3099-1"><a href="text.html#cb3099-1"></a>s3 &lt;-<span class="st"> </span><span class="kw">Map</span>(as.numeric, s2); s3</span></code></pre></div>
<pre><code>## [[1]]
## [1]   10.00    0.16 1700.00   42.00
## 
## [[2]]
## [1]   12.00    0.22 1799.10</code></pre>
<p>这个问题也可以用<code>strsplit()</code>或者<code>stringr::str_split()</code>解决。如：</p>
<div class="sourceCode" id="cb3101"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3101-1"><a href="text.html#cb3101-1"></a>s &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;10-0.16-1700.0-42.csv&quot;</span>, <span class="st">&quot;12-0.22-1799.1.csv&quot;</span>)</span>
<span id="cb3101-2"><a href="text.html#cb3101-2"></a>s1 &lt;-<span class="st"> </span><span class="kw">substring</span>(s, <span class="dv">1</span>, <span class="kw">nchar</span>(s)<span class="op">-</span><span class="dv">4</span>) <span class="co"># 去掉&quot;.csv&quot;</span></span>
<span id="cb3101-3"><a href="text.html#cb3101-3"></a><span class="kw">print</span>(s1)</span></code></pre></div>
<pre><code>## [1] &quot;10-0.16-1700.0-42&quot; &quot;12-0.22-1799.1&quot;</code></pre>
<div class="sourceCode" id="cb3103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3103-1"><a href="text.html#cb3103-1"></a>s2 &lt;-<span class="st"> </span><span class="kw">strsplit</span>(s1, <span class="st">&quot;[-]&quot;</span>)  <span class="co"># 按减号分成几个部分，结果为列表</span></span>
<span id="cb3103-2"><a href="text.html#cb3103-2"></a><span class="kw">print</span>(s2)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;10&quot;     &quot;0.16&quot;   &quot;1700.0&quot; &quot;42&quot;    
## 
## [[2]]
## [1] &quot;12&quot;     &quot;0.22&quot;   &quot;1799.1&quot;</code></pre>
<div class="sourceCode" id="cb3105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3105-1"><a href="text.html#cb3105-1"></a>s3 &lt;-<span class="st"> </span><span class="kw">Map</span>(as.numeric, s2)  <span class="co"># 转换为数值型</span></span>
<span id="cb3105-2"><a href="text.html#cb3105-2"></a><span class="kw">print</span>(s3)</span></code></pre></div>
<pre><code>## [[1]]
## [1]   10.00    0.16 1700.00   42.00
## 
## [[2]]
## [1]   12.00    0.22 1799.10</code></pre>
</div>
</div>
<div id="text-webscape" class="section level2">
<h2><span class="header-section-number">36.7</span> 网站数据获取</h2>
<p>很多网站定期频繁发布数据，
所以传统的手工复制粘贴整理是不现实的。
有些网站提供了下载功能，
有些则仅能显示。</p>
<p>这些数据网页往往有固定模式，
如果网页不是依赖JavaScript来展示的话，
可以读取网页然后通过字符型数据处理方法获得数据。</p>
<p>R扩展包rvest可以对网页按照其中的网页构成节点路径(xpath)提取数据，
转换为R数据框。</p>
<p>以上海证券交易所的上证综指成份股列表为例。
使用Google Chrome浏览器打开如下的页面：</p>
<p><a href="http://www.sse.com.cn/market/sseindex/indexlist/s/i000001/const_list.shtml" class="uri">http://www.sse.com.cn/market/sseindex/indexlist/s/i000001/const_list.shtml</a></p>
<p>将显示上证综指成份股的名称与编码的列表页面。
利用Chrome浏览器的功能先获取表格所在页面部分的xpath，
办法是鼠标右键单击表格开头部分，
选择“检查”（inspect），
这时会在浏览器右边打开一个html源代码窗口，
当前加亮显示部分是表格开头内容的源代码，
将鼠标单击到上层的<code>&lt;table class="tablestyle"&gt;</code>处，
右键单击选择“Copy-Copy XPath”，
得到如下的xpath地址：<code>'//*[@id="content_ab"]/div[1]/table'</code>。</p>
<p>然后，
用rvest的<code>html_nodes()</code>函数提取页面中用xpath指定的成分，
用<code>html_table()</code>函数将HTML表格转换为数据框，
结果是一个数据框列表，
因为仅有一个，
所以取列表第一项即可。
程序如下：</p>
<div class="sourceCode" id="cb3107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3107-1"><a href="text.html#cb3107-1"></a><span class="kw">library</span>(rvest)</span>
<span id="cb3107-2"><a href="text.html#cb3107-2"></a></span>
<span id="cb3107-3"><a href="text.html#cb3107-3"></a><span class="co">## 网页地址</span></span>
<span id="cb3107-4"><a href="text.html#cb3107-4"></a>urlb &lt;-<span class="st"> &quot;http://www.sse.com.cn/market/sseindex/indexlist/s/i000001/const_list.shtml&quot;</span></span>
<span id="cb3107-5"><a href="text.html#cb3107-5"></a><span class="co">## 网页中数据表的xpath</span></span>
<span id="cb3107-6"><a href="text.html#cb3107-6"></a>xpath &lt;-<span class="st"> &#39;//*[@id=&quot;content_ab&quot;]/div[1]/table&#39;</span></span>
<span id="cb3107-7"><a href="text.html#cb3107-7"></a></span>
<span id="cb3107-8"><a href="text.html#cb3107-8"></a><span class="co">## 读入网页并提取其中的表格节点</span></span>
<span id="cb3107-9"><a href="text.html#cb3107-9"></a>nodes &lt;-<span class="st"> </span><span class="kw">html_nodes</span>(</span>
<span id="cb3107-10"><a href="text.html#cb3107-10"></a>  <span class="kw">read_html</span>(urlb), <span class="dt">xpath=</span>xpath)</span>
<span id="cb3107-11"><a href="text.html#cb3107-11"></a></span>
<span id="cb3107-12"><a href="text.html#cb3107-12"></a><span class="co">## 从表格节点转换为表格列表</span></span>
<span id="cb3107-13"><a href="text.html#cb3107-13"></a>tables &lt;-<span class="st"> </span><span class="kw">html_table</span>(nodes)</span>
<span id="cb3107-14"><a href="text.html#cb3107-14"></a>restab &lt;-<span class="st"> </span>tables[[<span class="dv">1</span>]]</span>
<span id="cb3107-15"><a href="text.html#cb3107-15"></a><span class="kw">head</span>(restab)</span>
<span id="cb3107-16"><a href="text.html#cb3107-16"></a><span class="co">##                                  X1                               X2</span></span>
<span id="cb3107-17"><a href="text.html#cb3107-17"></a><span class="co">## 1 浦发银行\r\n            (600000) 白云机场\r\n            (600004)</span></span>
<span id="cb3107-18"><a href="text.html#cb3107-18"></a><span class="co">## 2 中国国贸\r\n            (600007) 首创股份\r\n            (600008)</span></span>
<span id="cb3107-19"><a href="text.html#cb3107-19"></a><span class="co">##                                 X3</span></span>
<span id="cb3107-20"><a href="text.html#cb3107-20"></a><span class="co">## 1 东风汽车\r\n            (600006)</span></span>
<span id="cb3107-21"><a href="text.html#cb3107-21"></a><span class="co">## 2 上海机场\r\n            (600009)</span></span></code></pre></div>
<p>可见每一行有三个股票，
我们将数据中的<code>\r\n</code>和空格去掉，
然后转换成名称与代码分开的格式：</p>
<div class="sourceCode" id="cb3108"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3108-1"><a href="text.html#cb3108-1"></a><span class="kw">library</span>(tidyverse)</span>
<span id="cb3108-2"><a href="text.html#cb3108-2"></a></span>
<span id="cb3108-3"><a href="text.html#cb3108-3"></a>pat1 &lt;-<span class="st"> &quot;^(.*?)</span><span class="ch">\\</span><span class="st">((.*?)</span><span class="ch">\\</span><span class="st">)&quot;</span></span>
<span id="cb3108-4"><a href="text.html#cb3108-4"></a>tab1 &lt;-<span class="st"> </span>restab <span class="op">%&gt;%</span></span>
<span id="cb3108-5"><a href="text.html#cb3108-5"></a><span class="st">  </span><span class="co">## 将三列合并为一列，结果为字符型向量</span></span>
<span id="cb3108-6"><a href="text.html#cb3108-6"></a><span class="st">  </span><span class="kw">reduce</span>(c) <span class="op">%&gt;%</span><span class="st"> </span></span>
<span id="cb3108-7"><a href="text.html#cb3108-7"></a><span class="st">  </span><span class="co">## 去掉空格和换行符，结果为字符型向量</span></span>
<span id="cb3108-8"><a href="text.html#cb3108-8"></a><span class="st">  </span>stringr<span class="op">::</span><span class="kw">str_replace_all</span>(<span class="st">&quot;[[:space:]]&quot;</span>, <span class="st">&quot;&quot;</span>) <span class="op">%&gt;%</span></span>
<span id="cb3108-9"><a href="text.html#cb3108-9"></a><span class="st">  </span><span class="co">## 提取公司简称和代码到一个矩阵行，结果为字符型矩阵</span></span>
<span id="cb3108-10"><a href="text.html#cb3108-10"></a><span class="st">  </span>stringr<span class="op">::</span><span class="kw">str_match</span>(pat1) </span>
<span id="cb3108-11"><a href="text.html#cb3108-11"></a>tab &lt;-<span class="st"> </span><span class="kw">tibble</span>(</span>
<span id="cb3108-12"><a href="text.html#cb3108-12"></a>  <span class="dt">name =</span> tab1[,<span class="dv">2</span>],</span>
<span id="cb3108-13"><a href="text.html#cb3108-13"></a>  <span class="dt">code =</span> tab1[,<span class="dv">3</span>])</span>
<span id="cb3108-14"><a href="text.html#cb3108-14"></a><span class="kw">head</span>(tab)</span>
<span id="cb3108-15"><a href="text.html#cb3108-15"></a><span class="co">## # A tibble: 6 x 2</span></span>
<span id="cb3108-16"><a href="text.html#cb3108-16"></a><span class="co">##   name     code  </span></span>
<span id="cb3108-17"><a href="text.html#cb3108-17"></a><span class="co">##   &lt;chr&gt;    &lt;chr&gt; </span></span>
<span id="cb3108-18"><a href="text.html#cb3108-18"></a><span class="co">## 1 浦发银行 600000</span></span>
<span id="cb3108-19"><a href="text.html#cb3108-19"></a><span class="co">## 2 中国国贸 600007</span></span>
<span id="cb3108-20"><a href="text.html#cb3108-20"></a><span class="co">## 3 包钢股份 600010</span></span>
<span id="cb3108-21"><a href="text.html#cb3108-21"></a><span class="co">## 4 华夏银行 600015</span></span>
<span id="cb3108-22"><a href="text.html#cb3108-22"></a><span class="co">## 5 上港集团 600018</span></span>
<span id="cb3108-23"><a href="text.html#cb3108-23"></a><span class="co">## 6 上海电力 600021</span></span></code></pre></div>
<div class="sourceCode" id="cb3109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3109-1"><a href="text.html#cb3109-1"></a><span class="kw">str</span>(tab)</span>
<span id="cb3109-2"><a href="text.html#cb3109-2"></a><span class="co">## Classes ‘tbl_df’, ‘tbl’ and &#39;data.frame&#39;:    1551 obs. of  2 variables:</span></span>
<span id="cb3109-3"><a href="text.html#cb3109-3"></a><span class="co">## $ name: chr  &quot;浦发银行&quot; &quot;中国国贸&quot; &quot;包钢股份&quot; &quot;华夏银行&quot; ...</span></span>
<span id="cb3109-4"><a href="text.html#cb3109-4"></a><span class="co">##  $ code: chr  &quot;600000&quot; &quot;600007&quot; &quot;600010&quot; &quot;600015&quot; ...</span></span></code></pre></div>
<p>对于不符合规则的网页，
可以用<code>download.file()</code>下载网页文件，
用<code>str_replace_all()</code>或者<code>gsub()</code>去掉不需要的成分。
用<code>str_which()</code>或者<code>grep</code>查找关键行。</p>
<p>有些网页是依靠JavaScript来显示数据的，
比如新浪财经的环球股指汇总网页：</p>
<p><a href="http://finance.sina.com.cn/money/globalindex/" class="uri">http://finance.sina.com.cn/money/globalindex/</a></p>
<p>这样的网页很难用程序提取数据。</p>
</div>
<div id="text-jiebaR" class="section level2">
<h2><span class="header-section-number">36.8</span> 中文分词与词频</h2>
<p>为了对中文文章进行分析，
需要将文章内容拆分为一个个单词。
R扩展包jiebaR可以进行中文分词。
用<code>w &lt;- worker()</code>创建一个分词器，
用<code>segment(txt, w)</code>对字符串txt中的中文内容进行分词，
得到字符型向量，每个元素是一个词。</p>
<p>也可以调用<code>segment(fname, w)</code>，
其中<code>fname</code>是输入文本文件名，
可以自动侦测其中的中文编码，
分词结果会自动保存为文件开头和文件扩展名与<code>fname</code>相同的一个文件，
词之间以空格分隔。</p>
<p>分词后，
R可以很容易地进行词频统计，
如<code>table()</code>函数。</p>
<p>例如，
对金庸的《侠客行》分词：</p>
<div class="sourceCode" id="cb3110"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3110-1"><a href="text.html#cb3110-1"></a><span class="kw">library</span>(jiebaR)</span></code></pre></div>
<pre><code>## 载入需要的程辑包：jiebaRD</code></pre>
<div class="sourceCode" id="cb3112"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3112-1"><a href="text.html#cb3112-1"></a>wk &lt;-<span class="st"> </span><span class="kw">worker</span>()</span>
<span id="cb3112-2"><a href="text.html#cb3112-2"></a>txt &lt;-<span class="st"> </span>readr<span class="op">::</span><span class="kw">read_file</span>(<span class="st">&quot;xkx.txt&quot;</span>, <span class="dt">locale=</span><span class="kw">locale</span>(<span class="dt">encoding=</span><span class="st">&quot;GB18030&quot;</span>))</span>
<span id="cb3112-3"><a href="text.html#cb3112-3"></a>words &lt;-<span class="st"> </span><span class="kw">segment</span>(txt, wk)</span>
<span id="cb3112-4"><a href="text.html#cb3112-4"></a>tab &lt;-<span class="st"> </span><span class="kw">table</span>(words)</span>
<span id="cb3112-5"><a href="text.html#cb3112-5"></a>tab &lt;-<span class="st"> </span><span class="kw">sort</span>(tab, <span class="dt">decreasing =</span> <span class="ot">TRUE</span>)</span>
<span id="cb3112-6"><a href="text.html#cb3112-6"></a><span class="co">## 去掉单个字的词语</span></span>
<span id="cb3112-7"><a href="text.html#cb3112-7"></a>tab2 &lt;-<span class="st"> </span>tab[stringr<span class="op">::</span><span class="kw">str_length</span>(<span class="kw">names</span>(tab)) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>]</span>
<span id="cb3112-8"><a href="text.html#cb3112-8"></a>knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">as.data.frame</span>(<span class="kw">head</span>(tab2, <span class="dv">20</span>)))</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">words</th>
<th align="right">Freq</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">石破天</td>
<td align="right">1800</td>
</tr>
<tr class="even">
<td align="left">什么</td>
<td align="right">697</td>
</tr>
<tr class="odd">
<td align="left">说道</td>
<td align="right">602</td>
</tr>
<tr class="even">
<td align="left">自己</td>
<td align="right">570</td>
</tr>
<tr class="odd">
<td align="left">雪山</td>
<td align="right">451</td>
</tr>
<tr class="even">
<td align="left">白万剑</td>
<td align="right">443</td>
</tr>
<tr class="odd">
<td align="left">丁当</td>
<td align="right">443</td>
</tr>
<tr class="even">
<td align="left">一个</td>
<td align="right">421</td>
</tr>
<tr class="odd">
<td align="left">帮主</td>
<td align="right">387</td>
</tr>
<tr class="even">
<td align="left">武功</td>
<td align="right">381</td>
</tr>
<tr class="odd">
<td align="left">石清</td>
<td align="right">372</td>
</tr>
<tr class="even">
<td align="left">丁不四</td>
<td align="right">345</td>
</tr>
<tr class="odd">
<td align="left">谢烟客</td>
<td align="right">340</td>
</tr>
<tr class="even">
<td align="left">一声</td>
<td align="right">321</td>
</tr>
<tr class="odd">
<td align="left">不是</td>
<td align="right">319</td>
</tr>
<tr class="even">
<td align="left">二人</td>
<td align="right">319</td>
</tr>
<tr class="odd">
<td align="left">不知</td>
<td align="right">308</td>
</tr>
<tr class="even">
<td align="left">咱们</td>
<td align="right">304</td>
</tr>
<tr class="odd">
<td align="left">史婆婆</td>
<td align="right">291</td>
</tr>
<tr class="even">
<td align="left">夫妇</td>
<td align="right">284</td>
</tr>
</tbody>
</table>
<p>词频可以用“词云”数据可视化方式表现。
在词云图形中，
词频大的词显示为较大的字体。
R扩展包wordcloud2可以输入词频统计表，
输出图形格式的词云显示，
以HTML5格式显示。
函数<code>wordcloud2()</code>可以输入<code>table()</code>的结果，
或者有词和词频构成的两列的数据框。</p>
<div class="sourceCode" id="cb3113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3113-1"><a href="text.html#cb3113-1"></a><span class="kw">library</span>(wordcloud2)</span>
<span id="cb3113-2"><a href="text.html#cb3113-2"></a><span class="kw">wordcloud2</span>(<span class="dt">data =</span> <span class="kw">head</span>(tab2, <span class="dv">20</span>))</span></code></pre></div>
<div id="htmlwidget-a1216b54f3940703ac09" style="width:672px;height:480px;" class="wordcloud2 html-widget"></div>
<script type="application/json" data-for="htmlwidget-a1216b54f3940703ac09">{"x":{"word":["石破天","什么","说道","自己","雪山","白万剑","丁当","一个","帮主","武功","石清","丁不四","谢烟客","一声","不是","二人","不知","咱们","史婆婆","夫妇"],"freq":[1800,697,602,570,451,443,443,421,387,381,372,345,340,321,319,319,308,304,291,284],"fontFamily":"Segoe UI","fontWeight":"bold","color":"random-dark","minSize":0,"weightFactor":0.1,"backgroundColor":"white","gridSize":0,"minRotation":-0.785398163397448,"maxRotation":0.785398163397448,"shuffle":true,"rotateRatio":0.4,"shape":"circle","ellipticity":0.65,"figBase64":null,"hover":null},"evals":[],"jsHooks":{"render":[{"code":"function(el,x){\n                        console.log(123);\n                        if(!iii){\n                          window.location.reload();\n                          iii = False;\n\n                        }\n  }","data":null}]}}</script>
<p>注意，这个库支持图形在HTML结果中显示，
且具有一定交互性，
但不直接支持LaTeX转换的PDF输出，
所以需要进行设置。
可以在Rmd源文件开头运行命令：</p>
<div class="sourceCode" id="cb3114"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3114-1"><a href="text.html#cb3114-1"></a>is_html &lt;-<span class="st"> </span>knitr<span class="op">::</span>opts_knit<span class="op">$</span><span class="kw">get</span>(<span class="st">&quot;rmarkdown.pandoc.to&quot;</span>) <span class="op">==</span><span class="st"> &quot;html&quot;</span></span></code></pre></div>
<p>这可以定义一个变量<code>is_html</code>，
仅在输出格式为HTML时才为<code>TRUE</code>，
然后在包含特殊HTML显示的代码段选项中，
加选项<code>eval = is_html</code>。</p>

</div>
</div>



            </section>

          </div>
        </div>
      </div>
<a href="simulation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="rcpp.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="static/js/app.min.js"></script>
<script src="static/js/lunr.js"></script>
<script src="static/js/clipboard.min.js"></script>
<script src="static/js/plugin-search.js"></script>
<script src="static/js/plugin-sharing.js"></script>
<script src="static/js/plugin-fontsettings.js"></script>
<script src="static/js/plugin-bookdown.js"></script>
<script src="static/js/jquery.highlight.js"></script>
<script src="static/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": ["Rbook.pdf"],
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
